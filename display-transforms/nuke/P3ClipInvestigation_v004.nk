#! /Applications/Nuke14.0v1/Nuke14.0v1.app/Contents/MacOS/libnuke-14.0.1.dylib -nx
version 14.0 v1
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="0" y="25" w="2560" h="1470" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1897" stretch="1"/>
            <splitter orientation="2">
                <split size="955"/>
                <splitter orientation="1">
                    <split size="1897"/>
                    <dock id="" activePageId="Viewer.1" focus="true">
                        <page id="Viewer.1"/>
                        <page id="Viewer.2"/>
                    </dock>
                </splitter>
                <split size="495"/>
                <dock id="" activePageId="DAG.1">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                    <page id="DAG.3"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
                <page id="Scenegraph.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/P3ClipInvestigation_v004.nk
 frame 61
 last_frame 200
 lock_range true
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 OCIO_config custom
 customOCIOConfigPath /Users/afry/Documents/GitHub/OpenColorIO-Configs/aces_1.2/config.ocio
 workingSpaceLUT linear
 monitorLut sRGB
 monitorOutLUT rec709
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Reformat {
 inputs 0
 type "to box"
 box_width 512
 box_height 4
 box_fixed true
 name Reformat2
 xpos 419
 ypos -381
}
Ramp {
 p0 {0 0}
 p1 {{width-1} 0}
 name Ramp1
 xpos 419
 ypos -357
}
set N2d563c00 [stack 0]
Grade {
 blackpoint {1 0 0 1}
 whitepoint {1 0 1 1}
 reverse true
 name Grade12
 xpos 1590
 ypos -315
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {1 1 0 1}
 whitepoint {1 1 1 1}
 reverse true
 name Grade11
 xpos 1492
 ypos -315
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {0 0 1 1}
 whitepoint {1 0 1 1}
 reverse true
 name Grade10
 xpos 1352
 ypos -310
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {1 0 1 1}
 whitepoint {1 1 1 1}
 reverse true
 name Grade9
 xpos 1232
 ypos -311
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {0 1 1 1}
 whitepoint {0 1 0 1}
 reverse true
 name Grade8
 xpos 1114
 ypos -314
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {0 1 1 1}
 whitepoint {1 1 1 1}
 reverse true
 name Grade7
 xpos 994
 ypos -314
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {0 1 1 1}
 whitepoint {0 0 1 1}
 reverse true
 name Grade5
 xpos 888
 ypos -306
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {1 1 0 1}
 whitepoint {0 1 0 1}
 reverse true
 name Grade4
 xpos 796
 ypos -306
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {1 1 0 1}
 whitepoint {1 0 0 1}
 reverse true
 name Grade6
 xpos 709
 ypos -307
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {0 0 0 1}
 whitepoint {0 0 1 1}
 reverse true
 name Grade3
 xpos 599
 ypos -311
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {0 0 0 1}
 whitepoint {0 1 0 1}
 reverse true
 name Grade2
 xpos 506
 ypos -311
 postage_stamp true
}
push $N2d563c00
Grade {
 blackpoint {0 0 0 1}
 whitepoint {1 0 0 1}
 reverse true
 name Grade1
 xpos 419
 ypos -312
 postage_stamp true
}
ContactSheet {
 inputs 12
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows {{inputs}}
 columns 1
 name ContactSheet1
 xpos 478
 ypos -198
}
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
 name Shuffle2
 xpos 478
 ypos -148
}
set N2d588800 [stack 0]
PositionToPoints2 {
 display textured
 render_mode textured
 P_channel rgb
 detail 1
 pointSize 10
 name PositionToPoints2
 xpos 478
 ypos -92
}
CMSTestPattern {
 inputs 0
 name CMSTestPattern5
 xpos 204
 ypos -181
}
Read {
 inputs 0
 file_type exr
 file /Users/afry/Downloads/arri_submission_2022/arribar_aces20651_overlay.exr
 format "4608 3164 0 0 4608 3164 1 "
 origset true
 name Read5
 xpos -330
 ypos -500
}
Read {
 inputs 0
 file_type exr
 file /Users/afry/GitHub/ACES_ODT_SampleFrames/ACES_OT_VWG_SampleFrames/ACES_OT_VWG_SampleFrames.####.exr
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 last 78
 origlast 78
 origset true
 name Read4
 xpos -465
 ypos -500
}
AppendClip {
 inputs 2
 meta_from_first false
 time ""
 name AppendClip1
 xpos -457
 ypos -382
}
Group {
 name ExposureStrips
 xpos -457
 ypos -358
 addUserKnob {20 ExposureStrips_tab l ExposureStrips}
 addUserKnob {7 pos l position}
 pos 0.36
 addUserKnob {7 resolution R 0.1 1}
 resolution 0.5
 addUserKnob {7 eoff l exposure R -6 6}
 addUserKnob {7 increment R 0 3}
 increment 1
 addUserKnob {3 strips t "number of strips" +INVISIBLE}
 strips 7
}
 Input {
  inputs 0
  name Input
  xpos -260
  ypos -376
 }
set N9fefb000 [stack 0]
 Crop {
  box {{rint(width*pos)} 0 {rint(width/strips)+rint(width*pos)} {height}}
  reformat true
  crop false
  name Strip
  xpos -260
  ypos -348
 }
 Reformat {
  type scale
  scale {{parent.resolution}}
  name Reformat1
  note_font Helvetica
  xpos -260
  ypos -310
 }
 Dot {
  name Dot1
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xff
  xpos -226
  ypos -221
 }
set N9fe1c200 [stack 0]
 Multiply {
  channels rgb
  value {{2**e}}
  name Exposure8
  label "\[value e]"
  xpos -480
  ypos 57
  addUserKnob {20 Params}
  addUserKnob {7 e l exposure R -12 12}
  e {{parent.increment*n}}
  addUserKnob {3 n}
  n 3
 }
push $N9fe1c200
 Multiply {
  channels rgb
  value {{2**e}}
  name Exposure7
  label "\[value e]"
  xpos -480
  ypos 9
  addUserKnob {20 Params}
  addUserKnob {7 e l exposure R -12 12}
  e {{parent.increment*n}}
  addUserKnob {3 n}
  n 2
 }
push $N9fe1c200
 Multiply {
  channels rgb
  value {{2**e}}
  name Exposure5
  label "\[value e]"
  xpos -480
  ypos -39
  addUserKnob {20 Params}
  addUserKnob {7 e l exposure R -12 12}
  e {{parent.increment*n}}
  addUserKnob {3 n}
  n 1
 }
push $N9fe1c200
 Multiply {
  channels rgb
  value {{2**e}}
  name Exposure4
  label "\[value e]"
  xpos -480
  ypos -87
  addUserKnob {20 Params}
  addUserKnob {7 e l exposure R -12 12}
  e {{parent.increment*n}}
  addUserKnob {3 n}
 }
push $N9fe1c200
 Multiply {
  channels rgb
  value {{2**e}}
  name Exposure2
  label "\[value e]"
  xpos -480
  ypos -135
  addUserKnob {20 Params}
  addUserKnob {7 e l exposure R -12 12}
  e {{parent.increment*n}}
  addUserKnob {3 n}
  n -1
 }
push $N9fe1c200
 Multiply {
  channels rgb
  value {{2**e}}
  name Exposure1
  label "\[value e]"
  xpos -480
  ypos -183
  addUserKnob {20 Params}
  addUserKnob {7 e l exposure R -12 12}
  e {{parent.increment*n}}
  addUserKnob {3 n}
  n -2
 }
push $N9fe1c200
 Multiply {
  channels rgb
  value {{2**e}}
  name Exposure3
  label "\[value e]"
  xpos -480
  ypos -231
  addUserKnob {20 Params}
  addUserKnob {7 e l exposure R -12 12}
  e {{parent.increment*n}}
  addUserKnob {3 n}
  n -3
 }
 ContactSheet {
  inputs 7
  width {{width*columns}}
  height {{height/pixel_aspect*rows}}
  rows 1
  columns 7
  roworder TopBottom
  name ContactSheet1
  xpos -260
  ypos 63
 }
 Multiply {
  channels rgb
  value {{pow(2,e)}}
  name Exposure6
  label "\[value e]"
  xpos -260
  ypos 129
  addUserKnob {20 Params}
  addUserKnob {7 e l exposure R -12 12}
  e {{eoff}}
 }
 Output {
  name Output
  xpos -260
  ypos 206
 }
push $N9fefb000
 Viewer {
  frame 61
  frame_range 1-200
  monitorOutOutputTransform rec709
  name Viewer1
  selected true
  xpos -150
  ypos -352
 }
end_group
EXPTool {
 mode Stops
 red -1
 green -1
 blue -1
 name Exposure2
 xpos -465
 ypos -330
 disable true
}
set N9a7fb000 [stack 0]
Crop {
 box {2239.600098 1392 2370.600098 1646.599976}
 reformat true
 crop false
 name Crop3
 xpos -465
 ypos -136
 disable true
}
set N2d589e00 [stack 0]
Group {
 name DRT_CAM4
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -863
 ypos 12
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 2.2 2.5 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps {{parent.DRT_CAM3.smooth_cusps}}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out P3-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
set N2d595000 [stack 0]
Clamp {
 name Clamp1
 xpos -863
 ypos 115
}
set N6d700a00 [stack 0]
Crop {
 box {1652 1300 2822 1926}
 reformat true
 crop false
 name Crop2
 xpos -726
 ypos 223
}
set N6d700e00 [stack 0]
Dot {
 name Dot4
 xpos -692
 ypos 279
}
set N6d7ff200 [stack 0]
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 rgba.blue 0 2 rgba.red 0 0 rgba.blue 0 2 rgba.green 0 1 rgba.blue 0 2 rgba.blue 0 2"
 name Shuffle7
 xpos -542
 ypos 357
}
Text {
 message B
 font /Library/Fonts/SF-Compact-Display-Bold.otf
 size 100
 yjustify bottom
 box {15 1.5 877 469}
 center {585 313}
 name Text5
 xpos -542
 ypos 381
}
push $N6d7ff200
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 rgba.green 0 1 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.green 0 1 rgba.blue 0 2"
 name Shuffle8
 xpos -637
 ypos 356
}
Text {
 message G
 font /Library/Fonts/SF-Compact-Display-Bold.otf
 size 100
 yjustify bottom
 box {15 1.5 877 469}
 center {585 313}
 name Text6
 xpos -637
 ypos 380
}
push $N6d7ff200
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.alpha 0 3 rgba.alpha 0 3 rgba.red 0 0 rgba.green 0 1 rgba.red 0 0 rgba.blue 0 2"
 name Shuffle9
 xpos -726
 ypos 355
}
Text {
 message R
 font /Library/Fonts/SF-Compact-Display-Bold.otf
 size 100
 yjustify bottom
 box {15 1.5 877 469}
 center {585 313}
 name Text7
 xpos -726
 ypos 379
}
push $N6d7ff200
Text {
 message P3
 font /Library/Fonts/SF-Compact-Display-Bold.otf
 size 100
 yjustify bottom
 box {15 1.5 877 469}
 center {585 313}
 name Text8
 xpos -833
 ypos 383
}
ContactSheet {
 inputs 4
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows 4
 columns 1
 roworder TopBottom
 name ContactSheet3
 xpos -833
 ypos 417
}
push $N6d700e00
push $N2d589e00
Group {
 name DRT_CAM5
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 selected true
 xpos -1084
 ypos -9
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {{parent.DRT_CAM4.chromaCompress} {parent.DRT_CAM4.chromaCompress} {parent.DRT_CAM4.chromaCompress}}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit {{DRT_CAM3.primaries_limit x2 3}}
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend {{parent.DRT_CAM4.cusp_mid_blend}}
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance {{parent.DRT_CAM4.focus_distance}}
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.2 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps {{parent.DRT_CAM3.smooth_cusps}}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
set N6d6f9a00 [stack 0]
Clamp {
 name Clamp2
 xpos -1059
 ypos 94
}
Colorspace {
 primary_out DCI-P3
 name Colorspace1
 xpos -1059
 ypos 126
}
set N9eda6400 [stack 0]
Dot {
 name Dot3
 xpos -996
 ypos 182
}
Crop {
 box {1652 1300 2822 1926}
 reformat true
 crop false
 name Crop1
 xpos -1030
 ypos 215
}
set N9eda6800 [stack 0]
ContactSheet {
 inputs 2
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows 1
 columns 2
 roworder TopBottom
 name ContactSheet4
 xpos -948
 ypos 418
}
push $N9eda6800
Dot {
 name Dot2
 xpos -996
 ypos 239
}
set N9eccec00 [stack 0]
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 rgba.blue 0 2 rgba.red 0 0 rgba.blue 0 2 rgba.green 0 1 rgba.blue 0 2 rgba.blue 0 2"
 name Shuffle6
 xpos -846
 ypos 317
}
Text {
 message B
 font /Library/Fonts/SF-Compact-Display-Bold.otf
 size 100
 yjustify bottom
 box {15 1.5 877 469}
 center {585 313}
 name Text3
 xpos -846
 ypos 341
}
push $N9eccec00
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 rgba.green 0 1 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.green 0 1 rgba.blue 0 2"
 name Shuffle5
 xpos -941
 ypos 316
}
Text {
 message G
 font /Library/Fonts/SF-Compact-Display-Bold.otf
 size 100
 yjustify bottom
 box {15 1.5 877 469}
 center {585 313}
 name Text2
 xpos -941
 ypos 340
}
push $N9eccec00
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.alpha 0 3 rgba.alpha 0 3 rgba.red 0 0 rgba.green 0 1 rgba.red 0 0 rgba.blue 0 2"
 name Shuffle4
 xpos -1030
 ypos 315
}
Text {
 message R
 font /Library/Fonts/SF-Compact-Display-Bold.otf
 size 100
 yjustify bottom
 box {15 1.5 877 469}
 center {585 313}
 name Text1
 xpos -1030
 ypos 339
}
push $N9eccec00
Text {
 message sRGB
 font /Library/Fonts/SF-Compact-Display-Bold.otf
 size 100
 yjustify bottom
 box {15 1.5 877 469}
 center {585 313}
 name Text4
 xpos -1137
 ypos 342
}
ContactSheet {
 inputs 4
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows 4
 columns 1
 roworder TopBottom
 name ContactSheet2
 xpos -1137
 ypos 418
}
push $N2d589e00
Reformat {
 type scale
 scale 0.1
 name Reformat3
 xpos -465
 ypos -95
}
set N9ecd9000 [stack 0]
Group {
 name DRT_CAM9
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 1392
 ypos 27
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 3
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Reformat {
 type "to box"
 box_width 1
 box_height 10
 box_fixed true
 resize distort
 name Reformat5
 xpos 1370
 ypos 116
}
set C491cbc00 [stack 0]
Crop {
 box {0 0 1 10}
 name Crop4
 xpos 1370
 ypos 140
}
set N491c5200 [stack 0]
Transform {
 translate {{width} 0}
 center {0.5 5}
 name Transform1
 xpos 1411
 ypos 176
}
push $N9ecd9000
Group {
 name DRT_CAM7
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 1192
 ypos 36
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 2
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
clone $C491cbc00 {
 xpos 1192
 ypos 120
 selected false
}
Crop {
 box {0 0 1 10}
 name Crop5
 xpos 1192
 ypos 144
}
set N2f372e00 [stack 0]
Merge2 {
 inputs 2
 operation plus
 name Plus
 xpos 1401
 ypos 217
}
Crop {
 box {0 0 2 10}
 reformat true
 crop false
 name Crop6
 xpos 1401
 ypos 241
}
push $N9a7fb000
Group {
 name DRT_CAM10
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -326
 ypos -292
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Multiply {
 value 0.1
 name Multiply7
 xpos -326
 ypos -208
}
set C6d732200 [stack 0]
push $N9a7fb000
EXPTool {
 mode Stops
 red -0.24
 green -0.24
 blue -0.24
 name Exposure1
 xpos -232
 ypos -330
}
Group {
 name DRT_CAM11
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -180
 ypos -295
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 1000}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
clone $C6d732200 {
 xpos -180
 ypos -211
 selected false
}
push $N9eda6400
Group {
 name PlotChromaticity1
 xpos -1160
 ypos 165
 addUserKnob {20 PlotChromaticity_tab l PlotChromaticity}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {6 plot_input l "plot input" t "Enable plotting of the input pixels" +STARTLINE}
 plot_input true
 addUserKnob {41 input_gamut l gamut t "Set the gamut that the input colors are encoded in" -STARTLINE T GamutToXYZ.gamut}
 addUserKnob {4 diagram l in t "Choose the type of chromaticity diagram: \nCIE 1931 xy Chromaticity Diagram\nCIE 1976 u' v' Uniform Chromaticity Scale Diagram" -STARTLINE M {"CIE 1931 xy" "CIE 1976 u' v'" "" ""}}
 addUserKnob {6 enable_sample_color l "sample color" t "Enable plotting of the sampled color" +STARTLINE}
 enable_sample_color true
 addUserKnob {41 sample_color l color t "sample and plot selected color" T SampleColor.color}
 addUserKnob {22 follow_viewer l "follow viewer" t "Follow the selected viewer node. This causes this node to automatically connect to whatever the followed viewer is connected to.\n\nThis is useful if you want to have a 2nd viewer showing a chromaticity plot for whever you're looking at in your main viewer." T "n = nuke.thisNode()\nnuke.root().begin()\nv = nuke.selectedNode()\nif not v or v.Class() != 'Viewer':\n    nuke.message('Please select a viewer node to follow.')\nelse:\n    v\['knobChanged'].setValue('v = nuke.activeViewer().node()\\nif v and v.name() == nuke.thisNode().name():\\n    con = v.input(nuke.activeViewer().activeInput())\\n    plt = nuke.toNode(\"\{0\}\")\\n    plt.setInput(0, con)'.format(n.name()))" +STARTLINE}
 addUserKnob {22 unfollow_viewer l "unfollow viewer" -STARTLINE T "n = nuke.thisNode()\nnuke.root().begin()\nv = nuke.selectedNode()\nif not v or v.Class() != 'Viewer':\n    nuke.message('Please select a viewer node to unfollow.')\nelse:\n    v\['knobChanged'].setValue('')"}
 addUserKnob {26 plot_dimensions_label l " " T "<b>Chromaticity Diagram"}
 addUserKnob {3 resolution l " resolution" t "resolution to output"}
 resolution 2048
 addUserKnob {7 right_margin l "right margin" R 1 1.5}
 right_margin 1.1
 addUserKnob {7 left_margin l "left margin" R 0 0.2}
 left_margin 0.1
 addUserKnob {6 draw_spectral_locus l "spectrum locus" t "draw the spectrum locus: the boundary of color the human eye can see." +STARTLINE}
 draw_spectral_locus true
 addUserKnob {6 draw_line_of_purples l "line of purples" t "draw the \"line of purples\"" -STARTLINE}
 draw_line_of_purples true
 addUserKnob {6 draw_planckian_locus l "planckian locus" t "Display the planckian locus or the blackbody locus." +STARTLINE}
 draw_planckian_locus true
 addUserKnob {6 gamut_grid l "gamut grid" t "Display a gamut boundary with a grid or dot pattern" +STARTLINE}
 addUserKnob {41 gamut_gamutgrid l "" t "gamut for gamutgrid" -STARTLINE T RGBToXYZ_GamutGrid.gamut}
 addUserKnob {4 gamut_grid_style l style t "Choose the style to display the gamut plot" -STARTLINE M {grid dots "" "" "" ""}}
 addUserKnob {4 distribution l dist t "Which chromaticity space should the overlays be constructed in? \n\nYxy is familiar, but not very perceptually uniform.\n\nu'v' is designed to be more perceptually uniform." -STARTLINE M {"1931 Yxy" "1976 u'v'" "" ""}}
 addUserKnob {7 density t "Density of the grid or points" R 10 100}
 density 50
 addUserKnob {6 gamut_a l "gamut a" t "Display a gamut outline" +STARTLINE}
 addUserKnob {41 gamut_a_1 l "" -STARTLINE T RGBToXYZ_GamutA.gamut}
 addUserKnob {6 gamut_b l "gamut b" t "Display a gamut outline" +STARTLINE}
 gamut_b true
 addUserKnob {41 gamut_b_1 l "" -STARTLINE T RGBToXYZ_GamutB.gamut}
 addUserKnob {6 gamut_c l "gamut c" t "Display a gamut outline" +STARTLINE}
 gamut_c true
 addUserKnob {41 gamut_c_1 l "" -STARTLINE T RGBToXYZ_GamutC.gamut}
 addUserKnob {6 draw_pointers_gamut l "pointer's gamut" t "DrawPointer's gamut boundary" +STARTLINE}
 addUserKnob {6 draw_pointers_samples l "pointers sample colors" t "show the individual pointer gamut samples" -STARTLINE}
 addUserKnob {6 draw_macbeth_chart l "macbeth chart" t "draw a ColorChecker24 aka Macbeth Chart" +STARTLINE}
 addUserKnob {6 coordinate_system l "coordinate system" t "Draw CIE xy coordinate grid x and y axes" +STARTLINE}
 coordinate_system true
 addUserKnob {6 map_overlays_to_input_gamut l "map overlays to input gamut" t "This maps the overlays like the spectral locus, pointer's gamut, and the gamut overlay to the working gamut instead of keeping them as XYZ.\n\nFor example if the input gamut is ACEScg, these overlays will be mapped to that. Note that this can cause most of the overlays to be negative or highly saturated which might harm the visual appearance." +STARTLINE}
 map_overlays_to_input_gamut true
}
 Group {
  inputs 0
  name GamutGrid1
  xpos -920
  ypos -201
  postage_stamp true
  addUserKnob {20 GamutGrid}
  addUserKnob {3 style}
  style {{!parent.gamut_grid_style}}
  addUserKnob {3 distribution -STARTLINE}
  distribution {{parent.distribution}}
  addUserKnob {7 density R 10 150}
  density {{parent.density}}
  addUserKnob {26 ""}
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {12 wxy}
  wxy {{parent.RGBToXYZ_GamutGrid.wxy} {parent.RGBToXYZ_GamutGrid.wxy}}
 }
  ColorWheel {
   inputs 0
   format "512 512 0 0 512 512 1 square_512"
   centerSaturation 1
   fillFormat false
   area {-170 -158 682 670}
   name ColorWheel4
   xpos -260
   ypos -15
   postage_stamp false
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop2
   xpos -260
   ypos 27
  }
  Reformat {
   type scale
   scale {{max(parent.density/50,0.25)}}
   resize distort
   filter impulse
   pbb true
   name Reformat3
   xpos -260
   ypos 110
  }
set N6d782000 [stack 0]
push $N6d782000
  ContactSheet {
   inputs 2
   width {{width*columns}}
   height {{height/pixel_aspect*rows}}
   rows 1
   columns 2
   roworder TopBottom
   name ContactSheet2
   xpos -260
   ypos 169
  }
  Dot {
   name Dot1
   label " "
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -226
   ypos 246
  }
  ColorWheel {
   inputs 0
   format "512 512 0 0 512 512 1 square_512"
   fillFormat false
   area {40 40 472 472}
   name ColorWheel1
   xpos -40
   ypos -664
   postage_stamp false
  }
  Reformat {
   type scale
   scale {{max(parent.density/50,0.25)}}
   resize distort
   filter impulse
   pbb true
   name Reformat1
   xpos -40
   ypos -628
  }
  Crop {
   box {0 0 {width} {height}}
   reformat true
   name Crop1
   xpos -40
   ypos -602
  }
  Unpremult {
   name Unpremult1
   xpos -40
   ypos -526
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos -415
  }
  Colorspace {
   colorspace_in CIE-XYZ
   colorspace_out CIE-Yxy
   name Colorspace1
   label "\[value colorspace_in] -> \[value colorspace_out]"
   xpos -40
   ypos -341
  }
set N6d784e00 [stack 0]
  Dot {
   name Dot2
   label " "
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -556
   ypos -331
  }
  Expression {
   expr0 r
   expr1 "4*g / ( -2*g + 12*b + 3)"
   expr2 "9*b / ( -2*g + 12*b + 3)"
   name Expression5
   label "CIE Yxy to CIELuv"
   xpos -590
   ypos -304
   disable {{!parent.distribution}}
  }
  Expression {
   expr0 r
   expr1 "(-(degrees(atan2(g-white.x, b-white.y))-180)+270)%360/360"
   expr2 "hypot(g-white.x, b-white.y)"
   expr3 a
   name Expression3
   xpos -590
   ypos -261
   cached true
   addUserKnob {20 User}
   addUserKnob {12 white}
   white {{"parent.distribution ? 4*parent.wxy.x / ( -2 * parent.wxy.x + 12 * parent.wxy.y + 3) : parent.wxy"} {"parent.distribution ? 9*parent.wxy.y / ( -2*parent.wxy.x + 12*parent.wxy.y + 3) : parent.wxy"}}
  }
set N6d785200 [stack 0]
  Posterize {
   channels rgb
   Colors {{rint(parent.density/3*2)}}
   name Posterize1
   xpos -590
   ypos -191
  }
set N6d773600 [stack 0]
push $N6d785200
  Dot {
   name Dot15
   xpos -446
   ypos -257
  }
  Copy {
   inputs 2
   from0 rgba.blue
   to0 rgba.blue
   name Copy1
   xpos -480
   ypos -154
  }
push $N6d773600
push $N6d785200
  Dot {
   name Dot16
   xpos -666
   ypos -257
  }
  Copy {
   inputs 2
   from0 rgba.green
   to0 rgba.green
   name Copy2
   xpos -700
   ypos -153
  }
  ContactSheet {
   inputs 2
   width {{width*columns}}
   height {{height/pixel_aspect*rows}}
   rows 1
   columns 2
   center true
   roworder TopBottom
   name ContactSheet3
   xpos -590
   ypos -106
  }
  Expression {
   expr0 r
   expr1 cos(radians(g*360))*b+white.x
   expr2 sin(radians(g*360))*b+white.y
   expr3 a
   name Expression19
   xpos -590
   ypos -58
   cached true
   addUserKnob {20 User}
   addUserKnob {12 white}
   white {{parent.Expression3.white} {parent.Expression3.white}}
  }
  Expression {
   expr0 r
   expr1 "9*g / ( 6*g - 16*b + 12)"
   expr2 "4*b/ ( 6*g - 16*b + 12)"
   name Expression2
   label "CIELuv to CIE Yxy"
   xpos -590
   ypos -16
   disable {{!parent.distribution}}
  }
  Colorspace {
   colorspace_in CIE-Yxy
   colorspace_out CIE-XYZ
   name Colorspace2
   label "\[value colorspace_in] -> \[value colorspace_out]"
   xpos -590
   ypos 32
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   invert true
   name ColorMatrix1
   label "XYZ to RGB"
   xpos -590
   ypos 81
  }
  Clamp {
   channels rgba
   maximum_enable false
   name ClampMin2
   xpos -590
   ypos 119
  }
  Clamp {
   channels alpha
   minimum 1
   MinClampTo_enable true
   MaxClampTo_enable true
   name Clamp1
   xpos -590
   ypos 152
  }
  Premult {
   name Premult1
   xpos -590
   ypos 194
  }
  Merge2 {
   inputs 2
   operation under
   bbox B
   name Merge2
   xpos -590
   ypos 242
  }
  Fill {
   output alpha
   name Fill1
   xpos -590
   ypos 297
  }
  Dot {
   name Dot3
   label " GRID"
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -556
   ypos 378
  }
push $N6d782000
push $N6d784e00
  Expression {
   expr0 r
   expr1 "4*g / ( -2*g + 12*b + 3)"
   expr2 "9*b / ( -2*g + 12*b + 3)"
   name Expression4
   label "CIE Yxy to CIELuv"
   xpos -40
   ypos -280
   disable {{!parent.distribution}}
  }
  Expression {
   expr0 r
   expr1 rint(g*Colors)/Colors
   expr2 rint(b*Colors)/Colors
   expr3 a
   name Expression1
   label rint
   xpos -40
   ypos -232
   addUserKnob {20 User}
   addUserKnob {7 Colors R 1 256}
   Colors {{parent.density}}
  }
  Expression {
   expr0 r
   expr1 "9*g / ( 6*g - 16*b + 12)"
   expr2 "4*b/ ( 6*g - 16*b + 12)"
   name Expression6
   label "CIELuv to CIE Yxy"
   xpos -40
   ypos -184
   disable {{!parent.distribution}}
  }
  Colorspace {
   colorspace_in CIE-Yxy
   colorspace_out CIE-XYZ
   name Colorspace3
   label "\[value colorspace_in] -> \[value colorspace_out]"
   xpos -40
   ypos -112
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   invert true
   name ColorMatrix3
   label "XYZ to RGB"
   xpos -40
   ypos -57
  }
  Clamp {
   channels alpha
   minimum 1
   MinClampTo_enable true
   MaxClampTo_enable true
   name Clamp4
   xpos -40
  }
  Premult {
   name Premult2
   xpos -40
   ypos 55
  }
  Merge2 {
   inputs 2
   operation under
   bbox B
   name Merge1
   xpos -40
   ypos 110
  }
  Clamp {
   channels rgba
   maximum_enable false
   name ClampMin1
   xpos -40
   ypos 273
  }
  Dot {
   name Dot4
   label " DOTS"
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -6
   ypos 378
  }
  Switch {
   inputs 2
   which {{parent.style}}
   name Switch1
   xpos -257
   ypos 483
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   name ColorMatrix2
   label "RGB to XYZ"
   xpos -257
   ypos 560
  }
  Output {
   name Output
   xpos -257
   ypos 740
  }
  ColorWheel {
   inputs 0
   format "256 256 0 0 256 256 1 square_256"
   area {40 40 472 472}
   name ColorWheel2
   xpos -37
   ypos -705
   postage_stamp false
  }
 end_group
set N6d781a00 [stack 0]
 Group {
  name RGBToXYZ_GamutGrid
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -1030
  ypos -184
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut ACEScg
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 ColorWheel {
  inputs 0
  format "512 512 0 0 512 512 1 square_512"
  centerSaturation 1
  fillFormat false
  area {-196 -184 708 696}
  name ColorWheel1
  xpos -920
  ypos 5
 }
 Crop {
  box {0 0 {width} {height}}
  name Crop1
  xpos -920
  ypos 87
 }
 BlackOutside {
  name BlackOutside3
  xpos -920
  ypos 134
 }
set N6d74ce00 [stack 0]
 Group {
  name RGBToXYZ_GamutC
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -1140
  ypos 176
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" "DaVinci WG" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut Rec709
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.7006223798 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.1487748176 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.101058729 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2741185129 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.8736318946 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 -0.1477504075 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 -0.09896291792 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 -0.1378953159 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 1.325916052 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.313 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.1682 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.9877 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.079 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 -0.1155 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Position {
  translate {{parent.Reformat1.box_width+Rectangle1.area.r+input.width} {parent.ReformatBox4.box_width-input.height}}
  name Position6
  xpos -1140
  ypos 254
 }
push $N6d74ce00
 Group {
  name RGBToXYZ_GamutB
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -1030
  ypos 176
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" "DaVinci WG" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut P3D65
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.7006223798 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.1487748176 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.101058729 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2741185129 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.8736318946 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 -0.1477504075 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 -0.09896291792 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 -0.1378953159 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 1.325916052 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.313 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.1682 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.9877 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.079 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 -0.1155 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Position {
  translate {{parent.Reformat1.box_width+Rectangle1.area.r} {parent.ReformatBox4.box_width-input.height*2}}
  name Position5
  xpos -1030
  ypos 254
 }
push $N6d74ce00
 Group {
  name RGBToXYZ_GamutA
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -920
  ypos 176
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" "DaVinci WG" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut Rec2020
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.7006223798 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.1487748176 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.101058729 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2741185129 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.8736318946 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 -0.1477504075 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 -0.09896291792 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 -0.1378953159 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 1.325916052 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.313 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.1682 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.9877 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.079 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 -0.1155 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Position {
  translate {{parent.Reformat1.box_width+Rectangle1.area.r} {parent.ReformatBox4.box_width-input.height}}
  name Position4
  xpos -920
  ypos 254
 }
push $N6d781a00
 Reformat {
  type scale
  scale 0.8
  turn true
  filter impulse
  black_outside true
  name Reformat2
  xpos -920
  ypos -129
 }
 BlackOutside {
  name BlackOutside2
  xpos -920
  ypos -106
 }
 Position {
  translate {{Rectangle1.area.r} {parent.Position3.translate.y-input.height}}
  name Position2
  xpos -920
  ypos -81
 }
 Group {
  inputs 0
  name ColorChecker24_After_November_2014
  label "CIE XYZ D50"
  xpos -920
  ypos -352
  addUserKnob {20 colorchecker_tab l "ColorChecker24 - After November 2014"}
  addUserKnob {3 patch_resolution}
  patch_resolution 48
 }
  Group {
   inputs 0
   name bluish_green
   selected true
   xpos 622
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.30451114 0.4143554688 0.344352688 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "bluish green"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 6
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 125
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name blue_flower
   xpos 512
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.2419823988 0.2287175998 0.3282104382 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "blue flower"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 5
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name foliage
   xpos 402
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1114392339 0.1346792679 0.05239320311 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob foliage
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 4
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name blue_sky
   xpos 292
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1652470004 0.1785519348 0.2546024121 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "blue sky"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 3
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name light_skin
   xpos 180
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.3811104477 0.336202304 0.1852590702 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "light skin"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 2
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 63
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 135
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name dark_skin
   xpos 70
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1136398927 0.09832436105 0.047793811 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "dark skin"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 1
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 290
    ypos 63
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 290
    ypos 158
   }
   Output {
    name Output
    xpos 290
    ypos 230
   }
  end_group
  Group {
   inputs 0
   name orange_yellow
   xpos 622
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.4769723742 0.4293377578 0.06005041429 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "orange yellow"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 12
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name yellow_green
   xpos 512
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.3427379502 0.4331759409 0.08330791241 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "yellow green"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 11
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name purple
   xpos 401
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.08353888545 0.06276662955 0.1042075686 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob purple
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 10
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name moderate_red
   xpos 290
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.2915036416 0.188999956 0.09736350318 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "moderate red"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 9
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name purplish_blue
   xpos 180
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1200518326 0.1091090233 0.2874447494 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "purplish blue"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 8
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name orange
   xpos 74
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.4073691399 0.3126416159 0.05130591012 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob orange
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 7
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name cyan
   xpos 622
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1247966941 0.180609913 0.2913392383 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob cyan
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 18
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name magenta
   xpos 512
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.299122798 0.1895114577 0.2213469194 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob magenta
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 17
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name yellow
   xpos 399
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.5888922356 0.5992976803 0.07077420003 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob yellow
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 16
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 125
   }
   Output {
    name Output
    xpos 262
    ypos 182
   }
  end_group
  Group {
   inputs 0
   name red
   xpos 292
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.2143728424 0.127800835 0.03868150726 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob red
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 15
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name green
   xpos 182
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1413517689 0.2233437582 0.07287461742 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob green
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 14
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name blue
   xpos 72
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.06809095613 0.05596214063 0.2077405936 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob blue
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 13
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name black_2
   xpos 623
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.03042544265 0.03151319431 0.02656724434 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "black 2 (1.5 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 24
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 125
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_3
   xpos 512
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.08448968042 0.08817234828 0.07391630753 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 3.5 (1.05 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 23
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_5
   xpos 403
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1835495863 0.1906228754 0.1566717383 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 5 (.70 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 22
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_6
   xpos 292
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.3495921991 0.3648652066 0.3013565492 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 6.5 (.44 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 21
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_8
   xpos 179
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.5665335579 0.5899709702 0.4828473821 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 8 (.23 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 20
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name white_9
   xpos 70
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.8436985288 0.8806903203 0.6936778752 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "white 9.5 (.05 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 19
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 134
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  ContactSheet {
   inputs 24
   width {{"rint(parent.patch_resolution * 6 + gap * 7)"}}
   height {{"rint(parent.patch_resolution * 4 + gap * 5)"}}
   rows 4
   columns 6
   startframe 1
   endframe 1
   name ContactSheet
   xpos 620
   ypos 206
  }
  Unpremult {
   name Unpremult1
   xpos 620
   ypos 278
  }
  Output {
   name Output
   xpos 620
   ypos 446
  }
 end_group
 BlackOutside {
  name BlackOutside4
  xpos -920
  ypos -298
 }
 Position {
  translate {{parent.Reformat1.box_width*3+Rectangle1.area.r} {parent.ReformatBox4.box_width-input.height}}
  name Position7
  xpos -920
  ypos -273
 }
 Constant {
  inputs 0
  format "256 256 0 0 256 256 1 square_256"
  name Constant5
  xpos -700
  ypos -1354
  postage_stamp false
 }
 Dot {
  name Dot25
  xpos -666
  ypos -1302
 }
set N7cd54c00 [stack 0]
 Dot {
  name Dot27
  xpos -1546
  ypos -1302
 }
 Reformat {
  type "to box"
  box_width {{parent.Reformat1.box_width}}
  box_height 100
  box_fixed true
  name ReformatBox1
  xpos -1580
  ypos -994
 }
 Ramp {
  p0 {0 0}
  p1 {{input.width} 0}
  color {{p1}}
  name Ramp3
  xpos -1580
  ypos -898
 }
 ColorLookup {
  lut {master {}
    red {curve 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914}
    green {curve 0.433 0.464 0.513 0.611 0.576 0.46 0.426 0.412 0.404 0.397 0.384 0.374 0.346 0.333 0.311 0.287 0.257 0.23 0.21 0.219 0.208 0.211 0.208 0.187 0.191 0.187 0.18 0.164 0.17 0.177 0.175 0.188 0.252 0.325 0.385 0.416 0.433 0.487 0.532 0.588 0.637 0.634 0.549 0.506 0.49 0.458 0.426 0.412 0.397 0.365 0.337 0.301 0.262 0.221 0.192 0.164 0.167 0.162 0.176 0.179 0.148 0.156 0.142 0.148 0.138 0.145 0.145 0.161 0.197 0.256 0.324 0.393 0.451 0.487 0.508 0.538 0.587 0.634 0.659 0.611 0.552 0.526 0.484 0.452 0.428 0.406 0.371 0.334 0.293 0.243 0.204 0.177 0.151 0.151 0.162 0.158 0.161 0.142 0.141 0.129 0.134 0.14 0.156 0.166 0.192 0.221 0.265 0.325 0.392 0.451 0.508 0.48 0.513 0.554 0.597 0.63 0.634 0.58 0.546 0.499 0.466 0.434 0.408 0.372 0.332 0.288 0.242 0.202 0.179 0.16 0.157 0.162 0.157 0.159 0.149 0.153 0.147 0.154 0.164 0.18 0.199 0.226 0.25 0.279 0.325 0.38 0.439 0.48 0.436 0.468 0.502 0.541 0.57 0.605 0.594 0.555 0.511 0.473 0.439 0.409 0.371 0.332 0.288 0.252 0.217 0.196 0.181 0.178 0.185 0.176 0.173 0.168 0.176 0.178 0.19 0.202 0.214 0.235 0.254 0.27 0.291 0.323 0.366 0.41 0.436 0.396 0.414 0.438 0.465 0.485 0.527 0.566 0.557 0.523 0.478 0.442 0.409 0.371 0.334 0.294 0.265 0.244 0.223 0.225 0.212 0.218 0.211 0.211 0.207 0.214 0.217 0.229 0.237 0.244 0.264 0.275 0.285 0.3 0.321 0.348 0.376 0.396 0.357 0.368 0.377 0.391 0.402 0.431 0.481 0.503 0.521 0.482 0.444 0.409 0.372 0.337 0.307 0.286 0.27 0.257 0.247 0.251 0.257 0.255 0.254 0.25 0.258 0.259 0.265 0.269 0.278 0.284 0.292 0.297 0.305 0.317 0.33 0.344 0.357 0.321 0.322 0.328 0.332 0.333 0.346 0.365 0.389 0.411 0.459 0.443 0.399 0.352 0.327 0.313 0.304 0.3 0.294 0.295 0.294 0.293 0.292 0.291 0.295 0.3 0.301 0.302 0.304 0.304 0.304 0.305 0.307 0.309 0.312 0.313 0.316 0.321}
    blue {curve 0.26 0.281 0.298 0.306 0.342 0.365 0.39 0.381 0.392 0.416 0.413 0.43 0.448 0.446 0.433 0.425 0.419 0.394 0.362 0.328 0.305 0.298 0.286 0.247 0.26 0.219 0.199 0.168 0.178 0.14 0.11 0.084 0.104 0.158 0.18 0.225 0.26 0.235 0.26 0.28 0.298 0.327 0.372 0.395 0.417 0.43 0.435 0.455 0.488 0.479 0.521 0.522 0.515 0.49 0.436 0.383 0.331 0.295 0.282 0.258 0.219 0.208 0.179 0.168 0.141 0.129 0.106 0.094 0.095 0.112 0.127 0.165 0.199 0.235 0.226 0.258 0.28 0.298 0.316 0.361 0.399 0.427 0.446 0.461 0.482 0.52 0.521 0.553 0.563 0.573 0.524 0.454 0.389 0.33 0.295 0.266 0.247 0.214 0.195 0.168 0.178 0.142 0.14 0.128 0.129 0.126 0.131 0.144 0.167 0.199 0.226 0.238 0.266 0.289 0.31 0.329 0.351 0.395 0.428 0.453 0.475 0.494 0.533 0.542 0.568 0.584 0.576 0.53 0.451 0.385 0.331 0.299 0.266 0.245 0.22 0.206 0.184 0.174 0.167 0.166 0.166 0.173 0.172 0.165 0.172 0.187 0.208 0.238 0.258 0.28 0.3 0.321 0.343 0.362 0.391 0.427 0.458 0.482 0.503 0.546 0.554 0.573 0.582 0.546 0.499 0.431 0.375 0.33 0.304 0.275 0.254 0.234 0.225 0.212 0.209 0.206 0.203 0.21 0.215 0.212 0.204 0.208 0.214 0.231 0.258 0.277 0.294 0.31 0.328 0.348 0.372 0.397 0.427 0.462 0.487 0.51 0.544 0.558 0.559 0.556 0.503 0.444 0.402 0.355 0.329 0.309 0.289 0.275 0.26 0.254 0.245 0.245 0.241 0.238 0.249 0.249 0.245 0.241 0.242 0.246 0.258 0.277 0.295 0.305 0.315 0.327 0.339 0.359 0.39 0.421 0.461 0.491 0.515 0.54 0.546 0.522 0.478 0.429 0.393 0.368 0.345 0.325 0.313 0.303 0.295 0.286 0.284 0.279 0.277 0.274 0.277 0.277 0.28 0.276 0.273 0.274 0.279 0.285 0.295 0.311 0.314 0.316 0.32 0.323 0.331 0.346 0.367 0.397 0.468 0.513 0.494 0.425 0.388 0.372 0.348 0.336 0.331 0.326 0.32 0.316 0.314 0.312 0.309 0.321 0.32 0.319 0.305 0.317 0.316 0.316 0.315 0.316 0.317 0.319 0.321 0.311}
    alpha {}}
  name ColorLookup7
  label "Pointers Samples Yxy\nSource: https://www.rit.edu/cos/colorscience/rc_useful_data.php"
  xpos -1580
  ypos -790
 }
 Colorspace {
  colorspace_in CIE-Yxy
  primary_in "Adobe (1998)"
  colorspace_out CIE-XYZ
  name Colorspace12
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -1580
  ypos -688
 }
 Fill {
  output alpha
  name Fill5
  xpos -1580
  ypos -639
 }
 BlackOutside {
  name BlackOutside7
  xpos -1580
  ypos -562
 }
 Position {
  translate {6 {parent.Position1.translate.y-input.height}}
  name Position3
  xpos -1580
  ypos -538
 }
 Dot {
  name Dot15
  xpos -1546
  ypos -414
 }
push $N7cd54c00
 Reformat {
  type "to box"
  box_width 2048
  box_height 2048
  box_fixed true
  name ReformatBox4
  xpos -700
  ypos -1258
 }
 Expression {
  temp_name0 n
  temp_expr0 input.width/8
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 x/width*(1-y/height)
  channel3 alpha
  expr3 1
  name Expression7
  xpos -700
  ypos -1209
 }
 Dot {
  name Dot10
  xpos -666
  ypos -1158
 }
set N6d7ba400 [stack 0]
 Dot {
  name Dot26
  xpos -886
  ypos -1158
 }
set N9ed53400 [stack 0]
 Dot {
  name Dot23
  xpos -1106
  ypos -1158
 }
set Nd1245800 [stack 0]
 Dot {
  name Dot12
  xpos -1326
  ypos -1158
 }
 Mirror2 {
  flip true
  flop true
  name Mirror2_1
  xpos -1360
  ypos -1042
 }
 Reformat {
  type "to box"
  box_width 512
  box_height {{box_width}}
  box_fixed true
  name Reformat1
  xpos -1360
  ypos -994
 }
 Gamma {
  channels rgb
  value 2
  name Gamma1
  xpos -1360
  ypos -898
 }
 Multiply {
  channels rgb
  value 8000
  name Multiply1
  label "\[value value]"
  xpos -1360
  ypos -811
 }
 ColorLookup {
  lut {master {}
    red {curve R 0.4830000103 x50 0.5045000315 0.5260000229 0.5475000143 0.5690000057 0.5904999971 0.6119999886 0.63349998 0.6549999714 0.6805312037 0.7087500095 0.7315937281 0.7409999967 0.7409999967 0.7409999967 0.7409999967 0.7409999967 0.75459373 0.7845000029 0.8144062757 0.8280000091 0.8280000091 0.8280000091 0.8280000091 0.8280000091 0.8009687662 0.74150002 0.6820312142 0.6549999714 0.6684374809 0.6980000138 0.7275624871 0.7409999967 0.7315937281 0.7087500095 0.6805312037 0.6549999714 0.629468739 0.6012499928 0.5784062743 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5555624962 0.5260000229 0.4964375198 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4964375198 0.5260000229 0.5555624962 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5653046966 0.5555624962 0.5417890549 0.5260000229 0.5102109313 0.4964375198 0.4866953194 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4695625007 0.4400000274 0.4104375243 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.4104375243 0.4400000274 0.4695625007 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103}
    green {curve R 0.6589999795 x50 0.6542205811 0.6484853029 0.6414804459 0.6340000033 0.6249843836 0.6147499681 0.6041406393 0.5939999819 0.5844687223 0.575124979 0.5659687519 0.5569999814 0.5484530926 0.5402500033 0.5319218636 0.5230000019 0.5131718516 0.5027499795 0.4922031164 0.4819999933 0.4722187519 0.4626249969 0.4532187581 0.4440000057 0.4351093769 0.4265000224 0.4178906381 0.4090000093 0.3997343779 0.3902499974 0.380640626 0.3709999919 0.3614374995 0.3518749774 0.3421249986 0.3319999874 0.321398437 0.3104375005 0.2992577851 0.2879999876 0.2764999866 0.2647500038 0.2531249821 0.2419999987 0.2312265635 0.2206875086 0.2108047009 0.202000007 0.1947187632 0.1886250079 0.1829687506 0.1770000011 0.1693515629 0.1608124971 0.1538671851 0.1509999931 0.1509999931 0.1509999931 0.1509999931 0.1509999931 0.1527187377 0.1564999968 0.1602812558 0.1620000005 0.1620000005 0.1620000005 0.1620000005 0.1620000005 0.1612187475 0.1595000029 0.1577812582 0.1570000052 0.1573124975 0.1579999924 0.1586875021 0.1589999944 0.1575781256 0.1543750018 0.1509843767 0.1490000039 0.1485625058 0.1484999955 0.1484375 0.1480000019 0.1467812508 0.1449999958 0.1432187557 0.1420000046 0.1415625066 0.1414999962 0.1414375007 0.1410000026 0.1397656202 0.1378750056 0.1357968748 0.1340000033 0.1323750019 0.1307500005 0.1295000017 0.1289999932 0.130031243 0.1324999928 0.1354687512 0.1379999965 0.1402187496 0.1424999982 0.1442812532 0.1449999958 0.1449999958 0.1449999958 0.1449999958 0.1449999958 0.1464921832 0.1503124982 0.1554765552 0.1609999985 0.1673984379 0.1749375015 0.1822578013 0.1879999936 0.1906718612 0.1913749874 0.1926406175 0.1969999969 0.2064140588 0.2199375033 0.2357421964 0.2520000041 0.2688750029 0.2871249914 0.3058125079 0.324000001 0.3417187631 0.359375 0.3765937686 0.3930000067 0.4082968831 0.4227499962 0.4368281364 0.451000005 0.4659531415 0.4812500179 0.4956718981 0.5080000162 0.5169296861 0.5234375 0.5297265649 0.5379999876 0.5491171479 0.5618124604 0.5751015544 0.5879999995 0.6009531021 0.6142500043 0.6266719103 0.6370000243 0.6457066536 0.6532088518 0.6575522423 0.6589999795}
    blue {curve R 0.3160000145 x50 0.324739933 0.3330312669 0.3418398499 0.351000011 0.3607422113 0.3709374964 0.3811640739 0.3910000026 0.4003046751 0.4093124866 0.4181640446 0.4269999862 0.4359609187 0.4449374974 0.453695327 0.4620000124 0.4697890878 0.4771875143 0.4842422009 0.4909999967 0.4971874952 0.5028749704 0.5086249709 0.5149999857 0.5227031112 0.53125 0.5394218564 0.5460000038 0.5502656102 0.5530000329 0.5552343726 0.5580000281 0.561632812 0.5655625463 0.5694609284 0.5730000138 0.5765469074 0.5801249743 0.5828906298 0.5839999914 0.5838750005 0.5830000043 0.5806249976 0.5759999752 0.5682968497 0.5576249957 0.5446406007 0.5299999714 0.5128515363 0.4931874871 0.4729296863 0.4539999962 0.4368359447 0.420437485 0.4045703113 0.3889999986 0.3731718659 0.3573749959 0.3426406384 0.3300000131 0.3193906248 0.310375005 0.3034218848 0.298999995 0.2972500026 0.2969999909 0.2967499793 0.2949999869 0.2899531126 0.2821249962 0.2734843791 0.2660000026 0.2602812648 0.2552500069 0.2503437698 0.2450000048 0.2380000055 0.2300000042 0.2232500017 0.2199999988 0.2195625007 0.2194999903 0.2194374949 0.2189999968 0.2183593661 0.2176249921 0.2163281292 0.2140000015 0.2101874948 0.205249995 0.1999374926 0.1949999928 0.1904453039 0.185937494 0.1817109436 0.1780000031 0.1754062474 0.1736250073 0.1715312451 0.1679999977 0.1620937437 0.1546249986 0.147093758 0.1410000026 0.1372031271 0.1347499937 0.1324218661 0.1289999932 0.1237656176 0.1174999923 0.1112343743 0.1059999987 0.1021796837 0.09918750077 0.09660156071 0.09399999678 0.09089062363 0.0876249969 0.0850468725 0.08399999887 0.08524999768 0.0882499963 0.09187500179 0.09499999881 0.09706249833 0.09875000268 0.1008125022 0.1040000021 0.1084140688 0.1136875004 0.1198671907 0.1270000041 0.1355390698 0.145312503 0.1554296911 0.1650000066 0.1739453226 0.1826875061 0.1910859346 0.199000001 0.2061250061 0.2126249969 0.2190624923 0.2259999961 0.2338827997 0.2423124909 0.2505859137 0.2579999864 0.2642968595 0.26987499 0.2750156224 0.2800000012 0.2847812474 0.2892500162 0.2935937643 0.2980000079 0.3025000095 0.3070000112 0.3115000129 0.3160000145}
    alpha {}}
  name ColorLookup5
  label "Pointer's Gamut Boundary Yxy\ninterpolated: incr 50 - 0 to 8000"
  xpos -1360
  ypos -775
 }
 Multiply {
  channels rgb
  value {0.31 1 1 1}
  name Multiply2
  label "dim boundary"
  xpos -1360
  ypos -725
 }
 Colorspace {
  colorspace_in CIE-Yxy
  primary_in "Adobe (1998)"
  colorspace_out CIE-XYZ
  name Colorspace5
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -1360
  ypos -688
 }
 Fill {
  output alpha
  name Fill4
  xpos -1360
  ypos -639
 }
 BlackOutside {
  name BlackOutside1
  xpos -1360
  ypos -562
 }
 Position {
  translate {6 {ReformatBox4.box_width-input.width}}
  name Position1
  xpos -1360
  ypos -538
 }
 Dot {
  name Dot24
  xpos -1326
  ypos -486
 }
push $Nd1245800
 Reformat {
  type "to box"
  box_width {{parent.Reformat1.box_width}}
  box_height 100
  box_fixed true
  name ReformatBox2
  xpos -1140
  ypos -994
 }
 Expression {
  temp_name0 n
  temp_expr0 input.width/8
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 x/width*(1-y/height)
  channel3 alpha
  expr3 1
  name Expression1
  xpos -1140
  ypos -898
 }
set N6ffd8400 [stack 0]
 Dot {
  name Dot8
  xpos -996
  ypos -894
 }
 ColorLookup {
  lut {master {curve L 0 s0 t0.9499999881 C k x0.308139503 1 s0}
    red {}
    green {}
    blue {}
    alpha {}}
  name ColorLookup1
  xpos -1030
  ypos -849
 }
 Dot {
  name Dot14
  xpos -996
  ypos -750
 }
push $N6ffd8400
 Multiply {
  channels rgb
  value 269
  name Multiply5
  label "\[value value]"
  xpos -1140
  ypos -856
 }
 ColorLookup {
  lut {master {}
    red {curve C 1.8783474 1.85965741 1.8410753 1.82260251 1.80424976 1.78602886 1.76794314 1.75000143 1.73221421 1.71458244 1.69711792 1.67982578 1.66271067 1.6457777 1.62903571 1.6124835 1.59613538 1.57998943 1.56404996 1.54832447 1.5328095 1.51751649 1.50244594 1.48759735 1.47297573 1.45858264 1.44442391 1.43049574 1.41680288 1.40334678 1.39012623 1.37714779 1.36440396 1.35190022 1.33963728 1.32761216 1.31582856 1.30428183 1.29297352 1.28190565 1.27107596 1.2604804 1.25012183 1.23999798 1.23010659 1.22044563 1.21101499 1.20181489 1.19284034 1.18408906 1.17556167 1.16725397 1.15916491 1.15129638 1.14363372 1.13618886 1.12895167 1.12192106 1.11509454 1.10846853 1.10204577 1.09580922 1.08977199 1.08392429 1.07826447 1.07278681 1.06749392 1.06237841 1.05743873 1.05267084 1.04807138 1.04364109 1.03937256 1.03526449 1.03131545 1.02751946 1.02387333 1.02037668 1.01702523 1.01381445 1.01074362 1.00780725 1.00500631 1.00233305 0.99978602 0.99736285 0.9950608 0.99287677 0.99080539 0.98884678 0.98699367 0.9852494 0.98361033 0.98206747 0.98062134 0.97926998 0.97800934 0.97683728 0.97575116 0.97474778 0.97382426 0.97297859 0.97220623 0.97150886 0.97087657 0.97031689 0.96981871 0.96938527 0.96900952 0.96869147 0.96842706 0.96821606 0.96805781 0.96794283 0.96787858 0.96785843 0.96787864 0.96793604 0.96803701 0.96817231 0.96833968 0.96854311 0.96877253 0.96903455 0.96932232 0.96963543 0.96997368 0.97033387 0.97071254 0.9711163 0.97153723 0.97197378 0.97242606 0.97289121 0.97337079 0.97386622 0.97437072 0.97488332 0.97540969 0.97594237 0.97647977 0.97702706 0.97757769 0.97813445 0.97869468 0.97925854 0.97982538 0.98039114 0.98096472 0.98153675 0.98210776 0.98267955 0.98325121 0.98382008 0.98438704 0.9849571 0.98552132 0.98608243 0.98664182 0.98719966 0.98775077 0.98829895 0.98884273 0.98938417 0.98991877 0.9904511 0.99097681 0.99149919 0.99201453 0.99252397 0.99303031 0.99353105 0.99402624 0.99451613 0.99499857 0.99547589 0.99594522 0.99641174 0.99687338 0.99732745 0.99777603 0.9982177 0.99865389 0.999084 0.99950838 0.99992663 1.00033772 1.00074494 1.00114489 1.00153947 1.00192833 1.00231075 1.00268865 1.00305855 1.00342607 1.00378489 1.00413895 1.00448751 1.00483036 1.00517035 1.00550389 1.00583148 1.00615203 1.00646758 1.00678015 1.00708604 1.00738645 1.00768471 1.00797844 1.0082655 1.00854778 1.00882483 1.00909901 1.00936711 1.00963116 1.00989032 1.0101465 1.01039672 1.01064491 1.01088691 1.0111258 1.01135957 1.01158977 1.01181614 1.01203847 1.01225793 1.01247287 1.01268291 1.01289058 1.01309609 1.01329684 1.01349473 1.0136888 1.0138787 1.01406395 1.01424909 1.01442885 1.01460576 1.01478052 1.01495218 1.01512218 1.01528883 1.01545072 1.01561022 1.01576698 1.01592219 1.01607502 1.01622343 1.01636875 1.0165143 1.01665616 1.01679492 1.0169313 1.01706588 1.01719737 1.01732695 1.01745498 1.01757956 1.01770294 1.01782393 1.01794255 1.0180583 1.01817465 1.01828551 1.01839495 1.01850486 1.01861191 1.01871693 1.01882088 1.01891339}
    green {curve C 1}
    blue {curve C 0.00879261 0.00962762 0.010532 0.01151017 0.01256675 0.01370643 0.01493413 0.01625487 0.01767381 0.01919618 0.02082733 0.02257277 0.02443803 0.02642871 0.02855051 0.03080913 0.0332104 0.0357601 0.03846392 0.04132775 0.04435719 0.04755813 0.05093599 0.05449668 0.0582453 0.0621875 0.06632853 0.07067341 0.07522713 0.07999477 0.08498063 0.09018957 0.09562518 0.10129225 0.10719412 0.11333443 0.11971687 0.12634411 0.133219 0.14034435 0.14772213 0.15535444 0.16324303 0.17138906 0.179794 0.18845794 0.197382 0.20656651 0.21601067 0.22571453 0.23567709 0.24589771 0.25637382 0.26710594 0.2780903 0.28932518 0.30080822 0.3125369 0.32450783 0.33671761 0.34916404 0.36183971 0.37474373 0.38787127 0.40121818 0.41477671 0.42854655 0.44251823 0.45668846 0.47105014 0.48559928 0.50033116 0.5152359 0.5303098 0.5455451 0.56093836 0.5764783 0.59215891 0.60797763 0.62392306 0.63999057 0.65616876 0.6724565 0.68884456 0.70532417 0.72188419 0.73852479 0.7552371 0.77200818 0.78883314 0.80570388 0.82261622 0.83956301 0.8565321 0.87351894 0.89051074 0.90751225 0.92450547 0.94148719 0.95845115 0.97538745 0.99229181 1.00915313 1.02597356 1.04273522 1.05944169 1.07608175 1.09265125 1.10914159 1.12555146 1.14187002 1.15809321 1.1742171 1.190238 1.20614767 1.22194457 1.23762202 1.2531724 1.26859927 1.28389311 1.29905295 1.31407428 1.32895291 1.34368753 1.35827363 1.3727088 1.38699389 1.40111876 1.41508293 1.42889357 1.44254065 1.45602405 1.46934104 1.48249614 1.49548101 1.50830269 1.5209527 1.53343177 1.54574537 1.5578897 1.56985986 1.5816654 1.59329891 1.60476208 1.61605716 1.62718153 1.63813758 1.64892519 1.65955138 1.67000985 1.68030369 1.69043732 1.70040607 1.71021223 1.71985734 1.72934508 1.73867714 1.74785423 1.75688136 1.76575518 1.77447391 1.78304338 1.79146802 1.79975164 1.80788386 1.81587982 1.82373333 1.83144975 1.83902776 1.84647095 1.85378456 1.86096811 1.86802399 1.87495112 1.88175035 1.88842535 1.89497983 1.90141833 1.90774179 1.91394711 1.92004013 1.92602086 1.93188739 1.93765306 1.94330883 1.94886208 1.95430994 1.95965815 1.96490622 1.97005856 1.97511387 1.98007631 1.98494554 1.98972344 1.99441445 1.99901712 2.00353193 2.00796437 2.01231384 2.01658392 2.02076721 2.02487659 2.02890825 2.03286695 2.03675175 2.04056406 2.04430199 2.04797506 2.05157685 2.05511236 2.0585804 2.06198287 2.06532407 2.06860161 2.07181907 2.07497644 2.07807779 2.0811162 2.08409977 2.08702946 2.08990335 2.09272337 2.09549189 2.0982089 2.10087585 2.10349345 2.10606146 2.1085825 2.11105394 2.11348104 2.11586332 2.11820364 2.12050176 2.12275648 2.12496805 2.127141 2.12927723 2.13136625 2.13341999 2.13543844 2.13741732 2.13936305 2.1412704 2.1431427 2.14498401 2.14678812 2.14856291 2.1503005 2.15200949 2.15368938 2.15533352 2.15695238 2.15853977 2.16009951 2.16162968 2.16313291 2.16460824 2.16605687 2.16747928 2.16887903 2.17024994 2.1715951 2.17291784 2.17421341 2.17548871 2.17674041 2.17797112 2.17918396 2.18036819 2.18143296}
    alpha {}}
  name ColorLookup3
  label "Planckian Locus 0-269"
  xpos -1140
  ypos -808
 }
 Multiply {
  inputs 1+1
  channels rgb
  value 0
  maskChannelMask rgba.red
  invert_mask true
  name Multiply3
  label dim
  xpos -1140
  ypos -760
 }
 BlackOutside {
  name BlackOutside6
  xpos -1140
  ypos -706
 }
 Position {
  translate {6 {parent.Position2.translate.y-input.height}}
  name Position8
  xpos -1140
  ypos -682
 }
 Dot {
  name Dot28
  xpos -1106
  ypos -654
 }
push $N9ed53400
 Dot {
  name Dot4
  xpos -886
  ypos -1086
 }
set N7cd55c00 [stack 0]
 Rectangle {
  replace true
  area {0 0 6 {height}}
  name Rectangle1
  xpos -810
  ypos -1089
 }
 BlackOutside {
  name BlackOutside5
  xpos -810
  ypos -1041
 }
push $N7cd55c00
 Radial {
  inputs 1+1
  replace true
  area {-5422 -3542 7470 5590}
  softness 0
  ramp linear
  color {0.0719 0.02604 0.0001 1}
  p1 {0 0}
  color0 {0.039378 0.001097 0.188331 1}
  p0 {0 2048}
  name Radial1
  xpos -920
  ypos -1041
 }
 Dot {
  name Dot9
  xpos -886
  ypos -894
 }
push $N6d7ba400
 Gamma {
  channels rgba
  value 0.5
  name Gamma2
  xpos -700
  ypos -1120
 }
 Expression {
  temp_name0 start
  temp_expr0 360
  temp_name1 end
  temp_expr1 830
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 r*(end-start)+start
  channel1 none
  channel2 none
  expr3 1
  name Expression2
  label "360nm to 830nm"
  xpos -700
  ypos -1096
 }
 ColorLookup {
  lut {master {}
    red {curve x360 0.0001299 C 0.00014585 0.0001638 0.000184 0.00020669 0.0002321 0.00026073 0.00029307 0.00032939 0.00036991 0.0004149 0.00046416 0.00051899 0.00058185 0.00065523 0.0007416 0.00084503 0.00096453 0.00109495 0.00123115 0.001368 0.00150205 0.00164233 0.00180238 0.00199576 0.002236 0.00253539 0.0028926 0.00330083 0.00375324 0.004243 0.00476239 0.00533005 0.00597871 0.00674112 0.00765 0.00875137 0.01002888 0.0114217 0.01286901 0.01431 0.01570443 0.01714744 0.01878122 0.02074801 0.02319 0.02620736 0.02978248 0.03388092 0.03846824 0.04351 0.0489956 0.0550226 0.0617188 0.069212 0.07763 0.08695811 0.09717672 0.1084063 0.1207672 0.13438 0.1493582 0.16539571 0.1819831 0.19861101 0.21477 0.23018681 0.24487969 0.25877729 0.27180791 0.28389999 0.29494381 0.3048965 0.31378731 0.32164541 0.3285 0.3343513 0.33921009 0.34312129 0.3461296 0.34828001 0.3495999 0.3501474 0.35001299 0.349287 0.34806001 0.34637329 0.34426239 0.3418088 0.3390941 0.3362 0.33319771 0.33004111 0.32663569 0.32288679 0.31869999 0.3140251 0.30888399 0.3032904 0.2972579 0.29080001 0.28397009 0.27672139 0.2689178 0.26042271 0.2511 0.2408475 0.2298512 0.2184072 0.2068115 0.19536 0.18421359 0.1733273 0.16268811 0.1522833 0.14210001 0.1321786 0.1225696 0.1132752 0.1042979 0.09564 0.08729955 0.07930804 0.07171776 0.06458099 0.05795001 0.05186211 0.04628152 0.04115088 0.03641283 0.03201 0.0279172 0.0241444 0.020687 0.0175404 0.0147 0.01216179 0.00991996 0.00796724 0.00629635 0.0049 0.00377717 0.00294532 0.00242488 0.00223629 0.0024 0.00292552 0.00383656 0.00517484 0.00698208 0.0093 0.01214949 0.01553588 0.01947752 0.02399277 0.0291 0.03481485 0.04112016 0.04798504 0.05537861 0.06327 0.07163501 0.08046224 0.08973996 0.09945645 0.1096 0.1201674 0.1311145 0.1423679 0.15385421 0.1655 0.17725711 0.18914001 0.2011694 0.21336579 0.2257499 0.2383209 0.2510668 0.26399219 0.2771017 0.2904 0.30389121 0.31757259 0.33143839 0.3454828 0.35969999 0.37408391 0.3886396 0.4033784 0.41831151 0.43344989 0.44879529 0.46433601 0.480064 0.49597129 0.51205009 0.52829587 0.54469162 0.56120938 0.57782149 0.59450001 0.6112209 0.62797582 0.64476019 0.66156971 0.67839998 0.69523919 0.7120586 0.72882837 0.7455188 0.76209998 0.77854317 0.79482561 0.81092638 0.82682478 0.84249997 0.85793251 0.87308162 0.88789439 0.90231812 0.9163 0.9297995 0.94279838 0.95527762 0.96721792 0.97860003 0.9893856 0.99954879 1.00908923 1.01800644 1.02629995 1.03398275 1.04098594 1.04718804 1.05246675 1.05669999 1.05979443 1.06179917 1.06280684 1.0629096 1.06219995 1.06073523 1.05844355 1.05522442 1.05097675 1.04560006 1.03903687 1.03136074 1.02266622 1.0130477 1.00259995 0.99136752 0.97933137 0.96649158 0.9528479 0.93839997 0.92319399 0.90724403 0.89050198 0.87291998 0.85444993 0.83508402 0.814946 0.794186 0.77295399 0.75139999 0.72958362 0.70758879 0.68560219 0.66381037 0.64240003 0.62151492 0.6011138 0.58110517 0.56139767 0.54189998 0.52259952 0.50354642 0.4847436 0.46619391 0.4479 0.42986131 0.41209799 0.39464399 0.37753329 0.3608 0.34445629 0.32851681 0.31301919 0.29800111 0.28349999 0.26954481 0.25611839 0.2431896 0.2307272 0.21870001 0.2070971 0.19592319 0.1851708 0.1748323 0.1649 0.1553667 0.14623 0.13749 0.1291467 0.1212 0.1136397 0.106465 0.09969044 0.09333061 0.0874 0.08190096 0.07680428 0.07207712 0.06768664 0.0636 0.05980685 0.05628216 0.05297104 0.04981861 0.04677 0.04378405 0.04087536 0.03807264 0.03540461 0.0329 0.03056419 0.02838056 0.02634484 0.02445275 0.0227 0.02108429 0.01959988 0.01823732 0.01698717 0.01584 0.01479064 0.01383132 0.01294868 0.0121292 0.01135916 0.01062935 0.00993885 0.00928842 0.00867885 0.00811092 0.00758239 0.00708875 0.00662731 0.00619541 0.00579035 0.00540983 0.00505258 0.00471751 0.00440351 0.00410946 0.00383391 0.00357575 0.00333434 0.00310907 0.00289933 0.00270435 0.00252302 0.00235417 0.00219662 0.00204919 0.00191096 0.00178144 0.00166011 0.00154646 0.00143997 0.00134004 0.00124628 0.00115847 0.00107643 0.00099995 0.00092874 0.00086243 0.00080075 0.0007434 0.00069008 0.00064052 0.0005945 0.00055186 0.00051243 0.00047602 0.00044245 0.00041151 0.00038298 0.00035665 0.0003323 0.00030976 0.00028889 0.00026954 0.00025157 0.00023483 0.00021917 0.00020453 0.00019084 0.00017807 0.00016615 0.00015502 0.00014462 0.00013491 0.00012585 0.00011741 0.00010955 0.00010222 9.539e-05 8.902e-05 8.308e-05 7.751e-05 7.231e-05 6.746e-05 6.293e-05 5.871e-05 5.477e-05 5.11e-05 4.768e-05 4.449e-05 4.151e-05 3.873e-05 3.614e-05 3.372e-05 3.146e-05 2.935e-05 2.738e-05 2.552e-05 2.379e-05 2.218e-05 2.067e-05 1.927e-05 1.797e-05 1.675e-05 1.562e-05 1.456e-05 1.357e-05 1.265e-05 1.18e-05 1.1e-05 1.025e-05 9.56e-06 8.91e-06 8.31e-06 7.75e-06 7.22e-06 6.73e-06 6.28e-06 5.85e-06 5.46e-06 5.09e-06 4.74e-06 4.42e-06 4.12e-06 3.84e-06 3.58e-06 3.34e-06 3.11e-06 2.9e-06 2.71e-06 2.52e-06 2.35e-06 2.19e-06 2.04e-06 1.91e-06 1.78e-06 1.66e-06 1.54e-06 1.44e-06 1.34e-06 S 1.25e-06}
    green {curve x360 3.92e-06 C 4.39e-06 4.93e-06 5.53e-06 6.21e-06 6.97e-06 7.81e-06 8.77e-06 9.84e-06 1.104e-05 1.239e-05 1.389e-05 1.556e-05 1.744e-05 1.958e-05 2.202e-05 2.484e-05 2.804e-05 3.153e-05 3.522e-05 3.9e-05 4.283e-05 4.691e-05 5.159e-05 5.718e-05 6.4e-05 7.234e-05 8.221e-05 9.351e-05 0.00010614 0.00012 0.00013498 0.00015149 0.00017021 0.00019182 0.000217 0.00024691 0.00028124 0.00031852 0.00035727 0.000396 0.00043371 0.00047302 0.00051788 0.00057222 0.00064 0.00072456 0.0008255 0.00094116 0.00106988 0.00121 0.00136209 0.00153075 0.00172037 0.00193532 0.00218 0.0024548 0.002764 0.0031178 0.0035264 0.004 0.00454624 0.00515932 0.00582928 0.00654616 0.0073 0.00808651 0.00890872 0.00976768 0.01066443 0.0116 0.01257317 0.01358272 0.01462968 0.01571509 0.01684 0.01800736 0.01921448 0.02045392 0.02171824 0.023 0.02429461 0.02561024 0.02695857 0.02835125 0.0298 0.03131083 0.03288368 0.03452112 0.03622571 0.038 0.03984667 0.041768 0.043766 0.04584267 0.048 0.05024368 0.05257304 0.05498056 0.05745872 0.06 0.06260197 0.06527752 0.06804208 0.07091109 0.0739 0.077016 0.0802664 0.0836668 0.0872328 0.09098 0.09491755 0.09904584 0.1033674 0.1078846 0.1126 0.117532 0.1226744 0.12799279 0.1334528 0.13902 0.1446764 0.1504693 0.15646189 0.1627177 0.1693 0.1762431 0.18355811 0.1912735 0.19941799 0.20802 0.2171199 0.2267345 0.2368571 0.2474812 0.2586 0.2701849 0.28229389 0.2950505 0.30857801 0.32300001 0.33840209 0.35468581 0.37169859 0.3892875 0.4073 0.42562991 0.44430959 0.4633944 0.48293951 0.50300002 0.52356929 0.54451197 0.56568998 0.58696532 0.60820001 0.6293456 0.65030682 0.67087519 0.69084239 0.70999998 0.72818518 0.74546361 0.76196939 0.7778368 0.79320002 0.80811042 0.82249618 0.83630681 0.8494916 0.86199999 0.87381083 0.88496238 0.89549363 0.90544319 0.91485012 0.92373478 0.93209243 0.93992257 0.94722521 0.954 0.9602561 0.96600741 0.97126061 0.97602248 0.98030001 0.98409241 0.98741817 0.99031281 0.99281162 0.99495012 0.99671078 0.99809831 0.99911201 0.99974817 1 0.99985671 0.99930459 0.99832553 0.99689871 0.995 0.9926005 0.98974258 0.98644441 0.98272407 0.97860003 0.97408372 0.96917123 0.96385682 0.95813489 0.95200002 0.94545043 0.93849921 0.93116277 0.92345762 0.91540003 0.90700638 0.89827722 0.8892048 0.8797816 0.87 0.85986131 0.849392 0.83862197 0.82758129 0.81629997 0.80479473 0.793082 0.781192 0.76915473 0.75700003 0.74475408 0.73242241 0.7200036 0.70749652 0.69489998 0.68221921 0.66947162 0.65667439 0.64384478 0.63099998 0.61815548 0.60531437 0.59247559 0.57963789 0.5668 0.5539611 0.54113722 0.5283528 0.51563227 0.50300002 0.4904688 0.47803041 0.46567759 0.4534032 0.44119999 0.42908001 0.417036 0.40503201 0.39303201 0.38100001 0.36891839 0.3568272 0.34477681 0.33281761 0.32100001 0.30933809 0.2978504 0.28659359 0.27562451 0.26499999 0.25476319 0.2448896 0.2353344 0.22605281 0.21699999 0.20816161 0.1995488 0.1911552 0.1829744 0.175 0.1672235 0.15964641 0.1522776 0.1451259 0.1382 0.1315003 0.1250248 0.1187792 0.1127691 0.107 0.1014762 0.09618864 0.09112296 0.08626485 0.0816 0.07712064 0.07282552 0.06871008 0.06476976 0.061 0.05739621 0.05395504 0.05067376 0.04754965 0.04458 0.04175872 0.03908496 0.03656384 0.03420048 0.032 0.02996261 0.02807664 0.02632936 0.02470805 0.0232 0.02180077 0.02050112 0.01928108 0.01812069 0.017 0.01590379 0.01483718 0.01381068 0.01283478 0.01192 0.01106831 0.01027339 0.00953331 0.00884616 0.00821 0.00762378 0.00708542 0.00659148 0.00613848 0.005723 0.00534306 0.0049958 0.0046764 0.00438007 0.004102 0.00383845 0.0035891 0.00335422 0.00313409 0.002929 0.00273814 0.00255988 0.00239324 0.00223728 0.002091 0.00195359 0.00182458 0.00170358 0.00159019 0.001484 0.0013845 0.00129127 0.00120409 0.00112274 0.001047 0.00097659 0.00091111 0.00085013 0.00079324 0.00074 0.00069008 0.00064331 0.0005995 0.00055845 0.00052 0.00048391 0.00045005 0.00041835 0.00038872 0.0003611 0.00033538 0.00031144 0.00028917 0.00026845 0.0002492 0.0002313 0.00021469 0.00019929 0.00018505 0.0001719 0.00015978 0.0001486 0.0001383 0.00012879 0.00012 0.00011186 0.00010432 9.734e-05 9.085e-05 8.48e-05 7.915e-05 7.386e-05 6.892e-05 6.43e-05 6e-05 5.598e-05 5.223e-05 4.872e-05 4.545e-05 4.24e-05 3.956e-05 3.692e-05 3.445e-05 3.215e-05 3e-05 2.799e-05 2.611e-05 2.436e-05 2.272e-05 2.12e-05 1.978e-05 1.845e-05 1.722e-05 1.606e-05 1.499e-05 1.399e-05 1.305e-05 1.218e-05 1.136e-05 1.06e-05 9.89e-06 9.22e-06 8.59e-06 8.01e-06 7.47e-06 6.96e-06 6.49e-06 6.05e-06 5.64e-06 5.26e-06 4.9e-06 4.57e-06 4.26e-06 3.97e-06 3.7e-06 3.45e-06 3.22e-06 3e-06 2.8e-06 2.61e-06 2.43e-06 2.27e-06 2.11e-06 1.97e-06 1.84e-06 1.71e-06 1.6e-06 1.49e-06 1.39e-06 1.29e-06 1.21e-06 1.12e-06 1.05e-06 9.8e-07 9.1e-07 8.5e-07 7.9e-07 7.4e-07 6.9e-07 6.4e-07 6e-07 5.6e-07 5.2e-07 4.8e-07 S 4.5e-07}
    blue {curve x360 0.0006061 C 0.00068088 0.00076515 0.00086001 0.00096659 0.001086 0.00122059 0.00137273 0.00154358 0.00173429 0.001946 0.00217778 0.00243581 0.00273195 0.00307806 0.003486 0.00397523 0.00454088 0.00515832 0.00580291 0.00645 0.00708322 0.00774549 0.00850115 0.00941454 0.01054999 0.0119658 0.01365587 0.01558805 0.01773015 0.02005001 0.02251136 0.02520288 0.02827972 0.03189704 0.03621 0.04143771 0.04750372 0.05411988 0.06099803 0.06785001 0.07448632 0.08136156 0.08915364 0.09854048 0.1102 0.1246133 0.1417017 0.16130351 0.1832568 0.20739999 0.23369209 0.26261139 0.29477459 0.33079851 0.37130001 0.4162091 0.4654642 0.51969481 0.5795303 0.64560002 0.71848381 0.79671329 0.87784588 0.95943898 1.0390501 1.11536729 1.18849707 1.25812328 1.32392955 1.38559997 1.44263518 1.49480355 1.54219031 1.58488071 1.62295997 1.65640485 1.68529594 1.70987451 1.73038209 1.74705994 1.76004458 1.76962328 1.77626371 1.78043342 1.78260004 1.78296816 1.78169978 1.77919817 1.7758671 1.77210998 1.76825893 1.76403904 1.7589438 1.75246632 1.74409997 1.73355949 1.7208581 1.70593691 1.68873715 1.66919994 1.64752865 1.62341273 1.59602225 1.56452799 1.52810001 1.4861114 1.43952155 1.38987994 1.33873618 1.28763998 1.23742235 1.18782425 1.13876104 1.09014797 1.04190004 0.99419761 0.94734728 0.90145308 0.8566193 0.81295007 0.77051729 0.7294448 0.68991357 0.65210491 0.61619997 0.58232862 0.55041617 0.52033758 0.49196729 0.46518001 0.4399246 0.41618359 0.39388219 0.3729459 0.35330001 0.33485779 0.31755209 0.30133751 0.28616861 0.27200001 0.25881711 0.2464838 0.2347718 0.2234533 0.2123 0.20116919 0.19011959 0.1792254 0.1685608 0.1582 0.1481383 0.1383758 0.1289942 0.1200751 0.1117 0.1039048 0.09666748 0.08998272 0.08384531 0.07824999 0.07320899 0.06867816 0.06456784 0.06078835 0.05725001 0.05390435 0.05074664 0.04775276 0.04489859 0.04216 0.03950728 0.03693564 0.03445836 0.03208872 0.02984 0.02771181 0.02569444 0.02378716 0.02198925 0.0203 0.01871805 0.01724036 0.01586364 0.01458461 0.0134 0.01230723 0.01130188 0.01037792 0.00952931 0.00875 0.0080352 0.0073816 0.0067854 0.0062428 0.00575 0.0053036 0.0048998 0.0045342 0.0042024 0.0039 0.0036232 0.0033706 0.0031414 0.0029348 0.00275 0.0025852 0.0024386 0.0023094 0.0021968 0.0021 0.00201773 0.0019482 0.0018898 0.00184093 0.0018 0.00176627 0.0017378 0.0017112 0.00168307 0.00165 0.00161013 0.0015644 0.0015136 0.00145853 0.0014 0.00133667 0.00127 0.001205 0.00114667 0.0011 0.0010688 0.0010494 0.0010356 0.0010212 0.001 0.00096864 0.00092992 0.00088688 0.00084256 0.0008 0.00076096 0.00072368 0.00068592 0.00064544 0.0006 0.00054787 0.0004916 0.0004354 0.00038347 0.00034 0.00030725 0.00028316 0.00026544 0.00025181 0.00024 0.00022955 0.00022064 0.00021196 0.00020219 0.00019 0.00017421 0.00015564 0.00013596 0.00011685 0.0001 8.613e-05 7.46e-05 6.5e-05 5.693e-05 5e-05 4.416e-05 3.948e-05 3.572e-05 3.264e-05 3e-05 2.765e-05 2.556e-05 2.364e-05 2.181e-05 2e-05 1.813e-05 1.62e-05 1.42e-05 1.213e-05 1e-05 7.73e-06 5.4e-06 3.2e-06 1.33e-06 0 0 0 0 0 0 0 0 S 0}
    alpha {}}
  name ColorLookup4
  label "CIE 1931 2 Degree Standard Observer\n360nm to 830nm"
  xpos -700
  ypos -1030
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeLineOfPurples
  xpos -700
  ypos -897
  disable {{!parent.draw_line_of_purples}}
 }
 Fill {
  color {0 0 0 1}
  name Disable_SpectralLocus
  xpos -700
  ypos -826
  disable {{parent.draw_spectral_locus}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergePlanckianLocus
  xpos -700
  ypos -658
  disable {{!parent.draw_planckian_locus}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergePointerGamut
  xpos -700
  ypos -489
  disable {{!parent.draw_pointers_gamut}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergePointerGamut_Samples
  xpos -700
  ypos -417
  disable {{!draw_pointers_samples}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeMacbeth
  xpos -700
  ypos -273
  disable {{!parent.draw_macbeth_chart}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutGrid
  xpos -700
  ypos -81
  disable {{!parent.gamut_grid}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutA
  xpos -700
  ypos 255
  disable {{!parent.gamut_a}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutB
  xpos -700
  ypos 279
  disable {{!parent.gamut_b}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutC
  xpos -700
  ypos 303
  disable {{!parent.gamut_c}}
 }
 Dot {
  name Dot2
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -666
  ypos 450
 }
set N7cfad800 [stack 0]
 Dot {
  name Dot5
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -556
  ypos 450
 }
 Colorspace {
  colorspace_in CIE-XYZ
  primary_in "Adobe (1998)"
  colorspace_out CIE-Yxy
  name Colorspace6
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -590
  ypos 488
 }
 Expression {
  expr0 r
  expr1 "4*g / ( -2*g + 12*b + 3)"
  expr2 "9*b / ( -2*g + 12*b + 3)"
  name Expression5
  label "CIE Yxy to CIELuv"
  xpos -590
  ypos 536
  disable {{!parent.diagram}}
 }
 Dot {
  name Dot11
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -556
  ypos 618
 }
push $N7cfad800
 ColorMatrix {
  matrix {
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
    }
  invert true
  name ColorMatrix1
  label "XYZ to working"
  xpos -700
  ypos 488
  disable {{!map_overlays_to_input_gamut}}
 }
 BlinkScript {
  inputs 2
  KernelDescription "2 \"PlotChromaticity_grid\" iterate pixelWise b2e7b5f8a89bdb0629aa8cc2eae387ef3436f24cb0af642eeba41235874506c4 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 6 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"tolerance\" Float 1 AAAAAA== \"antialias\" Bool 1 AA== \"draw_axes\" Bool 1 AA== \"grid_color\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== 6 \"padding\" 1 1 \"left_margin\" 1 1 \"tolerance\" 1 1 \"antialias\" 1 1 \"draw_axes\" 1 1 \"grid_color\" 4 1 2 \"outsize\" Float 1 1 AAAAAA== \"offset\" Float 1 1 AAAAAA=="
  kernelSource "kernel PlotChromaticity_grid : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float tolerance;\n  bool antialias;\n  bool draw_axes;\n  float4 grid_color;\n\nlocal:\n  float outsize;\n  float offset;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = float(dst.bounds.height()/padding);\n    // xy offset for margin on lower left corner\n    offset = dst.bounds.height()*left_margin;\n  \}\n\n  float gaussian(float d, float a, float expv) \{\n    return max(0.0f, exp(-a*d*d)-expv);\n  \}\n\n  float gaussian_filter(float x, float y, float r) \{\n    // return gaussian weighted distance from origin (0, 0)\n    // given coordinate (x, y) and radius r\n    float a = 1.5f; // rate falloff\n    float expv = exp(-a*r*r);\n    return gaussian(x, a, expv) * gaussian(y, a, expv);\n  \}\n\n  void write_aa(float x, float y, float4 rgb) \{\n    // skip black pixels\n    if (rgb.x == 0.0f && rgb.y == 0.0f && rgb.z == 0.0f) return;\n    \n    // size of pixel neighborhood = n*2+1 by n*2+1\n    int n = 2;\n\n    // center of neighborhood\n    int u0 = round(x);\n    int v0 = round(y);\n\n    // skip if center pixel weight is greater than tolerance\n    if ( dst.bounds.inside(u0, v0)) \{\n      if (dst(u0, v0, 3) >= tolerance) return;\n    \}\n\n    // loop over neighborhood\n    for (int j = -n; j <= n; j++) \{\n      int v = v0 + j;\n      for (int i = -n; i <= n; i++) \{\n        int u = u0 + i;\n        if ( dst.bounds.inside(u, v)) \{\n          // get filter weight for coord (u,v)\n          float w = gaussian_filter(u-x, v-y, float(n));\n          float4 c0 = dst(u, v); // existing color\n\n          // merge current color sample over existing color sample\n          for (int k=0; k<3; k++) \{\n            dst(u, v, k) = rgb\[k]*w+c0\[k]*(1-w); \n          \}\n\n          // merge current weight over existing weight\n          float w0 = dst(u, v, 3);\n          dst(u, v, 3) = w+w0*(1-w);\n        \}\n      \}\n    \}\n  \}\n\n  void draw_grid() \{\n    // grid width in pixels. expresses a 0 to 1 range in CIE xy\n    float grid_width = 1.0f * outsize + offset;\n    // draw grid lines\n    float i = offset;\n    while (i <= grid_width && i > 0.0f) \{\n      write_aa(offset, i, grid_color);\n      write_aa(i, offset, grid_color);\n      i += 1.0;\n    \}\n    // cross-hatching interval in pixels\n    float hatch_interval = (grid_width - offset) * 0.1f;\n    // cross-hatch length in pixels\n    float hatch_width = outsize * 0.01f;\n    i = offset;\n    while (i <= grid_width) \{\n      i += hatch_interval;\n      float j = 0.0;\n      while (j <= hatch_width/2) \{\n        write_aa(offset+j, i, grid_color);\n        write_aa(offset-j, i, grid_color);\n        write_aa(i, offset+j, grid_color);\n        write_aa(i, offset-j, grid_color);\n        j += 1.0;\n      \}\n    \}\n  \}\n\n  void process(int2 pos) \{\n    float4 rgba = col(pos.x, pos.y);\n    \n    // Get CIE xy position from Yxy input for current pixel\n    float2 xy = float2(Yxy(pos.x, pos.y, 1), Yxy(pos.x, pos.y, 2));\n    \n    // Find output pixel coordinate for this CIE xy pixel value\n    float2 out_coord = float2(xy.x * outsize + offset, xy.y * outsize + offset);\n\n    // For each RGB component, write value from color input to output coordinate\n    if (antialias) \{\n      write_aa(out_coord.x, out_coord.y, rgba);\n    \} else \{\n      // For each RGB component, write value from color input to output coordinate\n      int2 p = int2(round(out_coord.x), round(out_coord.y));\n      if (dst.bounds.inside(p.x, p.y)) \{\n        for (int k=0; k<3; k++) \{\n          dst(p.x, p.y, k) = col(pos.x, pos.y, k);\n        \}\n        dst(p.x, p.y, 3) = 1.0f;\n      \}\n    \}\n\n    // draw CIExy coordinate system axes\n    if (draw_axes && pos.x == 0 && pos.y == 0) \{\n      draw_grid();\n    \}\n  \}\n\};"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  PlotChromaticity_grid_padding {{parent.PlotChromaticities.PlotChromaticity_padding}}
  PlotChromaticity_grid_left_margin {{parent.PlotChromaticities.PlotChromaticity_left_margin}}
  PlotChromaticity_grid_tolerance 0.8
  PlotChromaticity_grid_antialias true
  PlotChromaticity_grid_draw_axes {{parent.coordinate_system}}
  PlotChromaticity_grid_grid_color {0.15 0 0.005 1}
  format "2048 2048 0 0 2048 2048 1 square_2K"
  rebuild_finalise ""
  name PlotInput2
  xpos -700
  ypos 608
 }
 FrameHold {
  firstFrame 1
  name FrameHold1
  xpos -700
  ypos 680
  cached true
 }
 Dot {
  name Dot3
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -666
  ypos 762
 }
 Input {
  inputs 0
  name Input
  xpos 620
  ypos -1426
 }
 AddChannels {
  name AddChannels1
  xpos 620
  ypos -1360
 }
 Reformat {
  type "to box"
  box_width {{parent.resolution}}
  box_height {{box_width}}
  box_fixed true
  box_pixel_aspect {{input.pixel_aspect}}
  resize distort
  filter impulse
  name OutputFormat
  xpos 620
  ypos -1282
  disable {{!parent.resample_input}}
 }
 Crop {
  box {0 0 {width} {height}}
  crop false
  name CropBBox
  xpos 620
  ypos -1257
 }
 Dot {
  name Dot7
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 654
  ypos 162
 }
set N7cfbca00 [stack 0]
 Constant {
  inputs 0
  channels rgb
  color {0 0 0 1}
  format "256 256 0 0 256 256 1 square_256"
  name Constant2
  xpos 400
  ypos 38
  postage_stamp false
 }
 Reformat {
  type "to box"
  box_width {{parent.resolution}}
  box_height {{box_width}}
  box_fixed true
  box_pixel_aspect {{input.pixel_aspect}}
  resize distort
  filter impulse
  name OutputFormat1
  xpos 400
  ypos 64
  disable {{!parent.resample_input}}
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input0]"}}
  name Switch1
  xpos 400
  ypos 158
 }
 Fill {
  output rgb
  color 0.18
  name SampleColor
  xpos 290
  ypos 158
 }
 Crop {
  box {0 0 {width} {height}}
  crop false
  name Crop2
  xpos 290
  ypos 184
 }
 Fill {
  output alpha
  name Fill3
  xpos 290
  ypos 224
 }
 Dot {
  name Dot6
  xpos 324
  ypos 282
 }
set N2f5a3e00 [stack 0]
 ColorMatrix {
  matrix {
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
    }
  name ColorMatrix4
  label "working to XYZ"
  xpos 180
  ypos 272
 }
 Colorspace {
  colorspace_in CIE-XYZ
  primary_in "Adobe (1998)"
  colorspace_out CIE-Yxy
  name Colorspace1
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos 180
  ypos 320
 }
 Expression {
  expr0 r
  expr1 "4*g / ( -2*g + 12*b + 3)"
  expr2 "9*b / ( -2*g + 12*b + 3)"
  name Expression6
  label "CIE Yxy to CIELuv"
  xpos 180
  ypos 368
  disable {{!parent.diagram}}
 }
push $N2f5a3e00
 BlinkScript {
  inputs 2
  KernelDescription "2 \"PlotChromaticity_sample\" iterate pixelWise 20e14b615a937bac78c1a771cbdfd10cc7c5fb6c487f65d0bb2d6633e404b958 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 3 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"tolerance\" Float 1 AAAAAA== 3 \"padding\" 1 1 \"left_margin\" 1 1 \"tolerance\" 1 1 2 \"outsize\" Float 1 1 AAAAAA== \"offset\" Float 1 1 AAAAAA=="
  kernelSource "kernel PlotChromaticity_sample : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float tolerance;\n\nlocal:\n  float outsize;\n  float offset;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = float(dst.bounds.height()/padding);\n    // xy offset for margin on lower left corner\n    offset = dst.bounds.height()*left_margin;\n  \}\n\n  void process(int2 pos) \{\n    // only process the first pixel\n    if (pos.x > 0 && pos.y > 0) return;\n\n    // Get CIE xy position from Yxy input for current pixel\n    float2 xy = float2(Yxy(pos.x, pos.y, 1), Yxy(pos.x, pos.y, 2));\n    \n    // Find output pixel coordinate for this CIE xy pixel value\n    float2 out_coord = float2(xy.x * outsize + offset, xy.y * outsize + offset);\n\n    // For each RGB component, write value from color input to output coordinate\n    int2 p = int2(round(out_coord.x), round(out_coord.y));\n    if (dst.bounds.inside(p.x, p.y)) \{\n      for (int k=0; k<3; k++) \{\n        dst(p.x, p.y, k) = col(pos.x, pos.y, k);\n      \}\n      dst(p.x, p.y, 3) = 1.0f;\n    \}\n  \}\n\};"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  PlotChromaticity_sample_padding {{"parent.diagram ? parent.right_margin*0.8 : parent.right_margin"}}
  PlotChromaticity_sample_left_margin {{parent.left_margin}}
  PlotChromaticity_sample_tolerance 1
  format "2048 2048 0 0 2048 2048 1 square_2K"
  rebuild_finalise ""
  name PlotChromaticities1
  xpos 290
  ypos 368
 }
 Dot {
  name Dot22
  xpos 324
  ypos 450
 }
set N7cfbe400 [stack 0]
 Dilate {
  channels rgba
  size {{Output.width/2048}}
  name Dilate1
  label "\[value size]"
  xpos 290
  ypos 488
 }
set N7cfbf000 [stack 0]
 Dilate {
  channels rgba
  size {{Output.width/2048*2}}
  name Dilate2
  label "\[value size]"
  xpos 180
  ypos 488
 }
push $N7cfbe400
 Dot {
  name Dot21
  xpos -6
  ypos 450
 }
 FilterErode {
  channels rgba
  size {{-Output.width/2048/5}}
  filter triangle
  name FilterErode1
  label "\[value size]"
  xpos -40
  ypos 489
 }
set N7cfb9e00 [stack 0]
 Dilate {
  channels rgba
  size {0 {parent.Dilate3.size.w}}
  name Dilate4
  label "\[value size]"
  xpos -40
  ypos 584
 }
push $N7cfb9e00
 Dilate {
  channels rgba
  size {{Output.width*plus_size/100} 0}
  name Dilate3
  label "\[value size]"
  xpos 70
  ypos 488
  addUserKnob {20 User}
  addUserKnob {7 plus_size R 0 4}
  plus_size 0.8
 }
 Merge2 {
  inputs 2
  operation screen
  bbox B
  name Merge9
  xpos 70
  ypos 591
 }
 Merge2 {
  inputs 2
  operation stencil
  bbox B
  name Merge10
  xpos 180
  ypos 591
 }
 Group {
  name HueRotate
  xpos 180
  ypos 639
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -24
  }
  Unpremult {
   name Unpremult1
   xpos -40
   ypos 15
  }
  Colorspace {
   colorspace_out HSV
   name Colorspace1
   xpos -40
   ypos 72
  }
  Add {
   channels {rgba.red -rgba.green -rgba.blue none}
   value 0.5
   name Add1
   xpos -40
   ypos 111
  }
  Fill {
   output {-rgba.red -rgba.green rgba.blue none}
   name Fill1
   xpos -40
   ypos 147
  }
  Colorspace {
   colorspace_in HSV
   name Colorspace2
   xpos -40
   ypos 183
  }
  Premult {
   name Premult1
   xpos -40
   ypos 231
  }
  Output {
   name Output1
   xpos -40
   ypos 302
  }
 end_group
push $N7cfbf000
 Merge2 {
  inputs 2
  bbox B
  name Merge8
  xpos 290
  ypos 638
 }
 Dot {
  name Dot20
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 324
  ypos 690
 }
push $N7cfbca00
 Dot {
  name Dot1
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 764
  ypos 162
 }
 Group {
  name GamutToXYZ
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos 730
  ypos 247
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut P3D65
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Colorspace {
  colorspace_in CIE-XYZ
  primary_in "Adobe (1998)"
  colorspace_out CIE-Yxy
  name Colorspace2
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos 730
  ypos 296
 }
 Expression {
  expr0 r
  expr1 "4*g / ( -2*g + 12*b + 3)"
  expr2 "9*b / ( -2*g + 12*b + 3)"
  name Expression4
  label "CIE Yxy to CIELuv"
  xpos 730
  ypos 344
  disable {{!parent.diagram}}
 }
 Dot {
  name Dot13
  label " Pos"
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 764
  ypos 546
 }
push $N7cfbca00
 Dot {
  name Dot16
  label " Col"
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 654
  ypos 450
 }
 BlinkScript {
  inputs 2
  KernelDescription "2 \"PlotChromaticity\" iterate pixelWise 3e86399c7642fe5c35c23528a644f88a8bf13f967de084ae6842f8be55098c6b 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 4 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"tolerance\" Float 1 AAAAAA== \"antialias\" Bool 1 AA== 4 \"padding\" 1 1 \"left_margin\" 1 1 \"tolerance\" 1 1 \"antialias\" 1 1 2 \"outsize\" Float 1 1 AAAAAA== \"offset\" Float 1 1 AAAAAA=="
  kernelSource "kernel PlotChromaticity : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float tolerance;\n  bool antialias;\n\nlocal:\n  float outsize;\n  float offset;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = float(dst.bounds.height()/padding);\n    // xy offset for margin on lower left corner\n    offset = dst.bounds.height()*left_margin;\n  \}\n\n  float gaussian(float d, float a, float expv) \{\n    return max(0.0f, exp(-a*d*d)-expv);\n  \}\n\n  float gaussian_filter(float x, float y, float r) \{\n    // return gaussian weighted distance from origin (0, 0)\n    // given coordinate (x, y) and radius r\n    float a = 1.5f; // rate falloff\n    float expv = exp(-a*r*r);\n    return gaussian(x, a, expv) * gaussian(y, a, expv);\n  \}\n\n  void write_aa(float x, float y, float4 rgb) \{\n    // skip black pixels\n    if (rgb.x == 0.0f && rgb.y == 0.0f && rgb.z == 0.0f) return;\n    \n    // size of pixel neighborhood = n*2+1 by n*2+1\n    int n = 2;\n\n    // center of neighborhood\n    int u0 = round(x);\n    int v0 = round(y);\n\n    // skip if center pixel weight is greater than tolerance\n    if ( dst.bounds.inside(u0, v0)) \{\n      if (dst(u0, v0, 3) >= tolerance) return;\n    \}\n\n    // loop over neighborhood\n    for (int j = -n; j <= n; j++) \{\n      int v = v0 + j;\n      for (int i = -n; i <= n; i++) \{\n        int u = u0 + i;\n        if ( dst.bounds.inside(u, v)) \{\n          // get filter weight for coord (u,v)\n          float w = gaussian_filter(u-x, v-y, float(n));\n          float4 c0 = dst(u, v); // existing color\n\n          // merge current color sample over existing color sample\n          for (int k=0; k<3; k++) \{\n            dst(u, v, k) = rgb\[k]*w+c0\[k]*(1-w); \n          \}\n\n          // merge current weight over existing weight\n          float w0 = dst(u, v, 3);\n          dst(u, v, 3) = w+w0*(1-w);\n        \}\n      \}\n    \}\n  \}\n\n\n  void process(int2 pos) \{\n    float4 rgba = col(pos.x, pos.y);\n    \n    // Get CIE xy position from Yxy input for current pixel\n    float2 xy = float2(Yxy(pos.x, pos.y, 1), Yxy(pos.x, pos.y, 2));\n    \n    // Find output pixel coordinate for this CIE xy pixel value\n    float2 out_coord = float2(xy.x * outsize + offset, xy.y * outsize + offset);\n\n    // For each RGB component, write value from color input to output coordinate\n    if (antialias) \{\n      write_aa(out_coord.x, out_coord.y, rgba);\n    \} else \{\n      // For each RGB component, write value from color input to output coordinate\n      int2 p = int2(round(out_coord.x), round(out_coord.y));\n      if (dst.bounds.inside(p.x, p.y)) \{\n        for (int k=0; k<3; k++) \{\n          dst(p.x, p.y, k) = col(pos.x, pos.y, k);\n        \}\n        dst(p.x, p.y, 3) = 1.0f;\n      \}\n    \}\n  \}\n\};"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  PlotChromaticity_padding {{"parent.diagram ? parent.right_margin*0.8 : parent.right_margin"}}
  PlotChromaticity_left_margin {{parent.left_margin}}
  PlotChromaticity_tolerance 2
  PlotChromaticity_antialias true
  format "2048 2048 0 0 2048 2048 1 square_2K"
  rebuild_finalise ""
  name PlotChromaticities
  xpos 620
  ypos 536
  disable {{!parent.plot_input}}
 }
 Fill {
  color 0
  name BLACK
  tile_color 0x111111ff
  xpos 620
  ypos 591
  disable {{parent.plot_input}}
 }
 Merge2 {
  inputs 2
  bbox B
  name Merge7
  xpos 620
  ypos 686
  disable {{!parent.enable_sample_color}}
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 620
  ypos 758
 }
 Output {
  name Output
  xpos 620
  ypos 1046
 }
end_group
Text {
 message sRGB
 font /Library/Fonts/SF-Compact-Display-Bold.otf
 size 100
 yjustify bottom
 box {15 1.5 877 469}
 center {585 313}
 name Text9
 xpos -1160
 ypos 189
}
PositionToPoints2 {
 inputs 0
 name PositionToPoints6
 xpos 1518
 ypos 405
}
push $N9ecd9000
Group {
 name DRT_CAM12
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 1895
 ypos 30
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 12
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Reformat {
 type "to box"
 box_width 1
 box_height 10
 box_fixed true
 resize distort
 name Reformat6
 xpos 1873
 ypos 119
}
set C6d7bc200 [stack 0]
Crop {
 box {0 0 1 10}
 name Crop7
 xpos 1873
 ypos 143
}
set N6d7bca00 [stack 0]
Transform {
 translate {{width} 0}
 center {0.5 5}
 name Transform2
 xpos 1914
 ypos 179
}
push $N9ecd9000
Group {
 name DRT_CAM13
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 1695
 ypos 39
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 2
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
clone $C6d7bc200 {
 xpos 1695
 ypos 123
 selected false
}
Crop {
 box {0 0 1 10}
 name Crop8
 xpos 1695
 ypos 147
}
set N6ff88400 [stack 0]
Merge2 {
 inputs 2
 operation plus
 name Plus1
 xpos 1904
 ypos 220
}
Crop {
 box {0 0 2 10}
 reformat true
 crop false
 name Crop9
 xpos 1904
 ypos 244
}
Read {
 inputs 0
 file_type exr
 file /Users/afry/Working/Tungsten_3200K.exr
 format "4096 2160 0 0 4096 2160 1 4K_DCP"
 origset true
 name Read1
 xpos 41
 ypos -452
}
Read {
 inputs 0
 file_type exr
 file /Users/afry/GitHub/ACES_ODT_SampleFrames/ACES_OT_VWG_SampleFrames/ACES_OT_VWG_SampleFrames.####.exr
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 last 78
 origlast 78
 origset true
 name Read3
 xpos -104
 ypos -458
}
push $N2d589e00
Group {
 name DRT_CAM14
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -740
 ypos 66
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps {{parent.DRT_CAM3.smooth_cusps}}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out P3-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
push $N491c5200
push $N2f372e00
ContactSheet {
 inputs 2
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows 1
 columns 2
 roworder TopBottom
 name ContactSheet5
 xpos 1258
 ypos 173
}
set N2d320c00 [stack 0]
Shuffle {
 name Shuffle16
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 1192
 ypos 220
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply5
 note_font "Bitstream Vera Sans"
 xpos 1192
 ypos 244
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression6
 note_font "Bitstream Vera Sans"
 xpos 1192
 ypos 268
}
set N2d33ca00 [stack 0]
Card2 {
 inputs 0
 display wireframe
 rows 18
 columns 1
 control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
 name Card1
 xpos 1075
 ypos 250
}
DisplaceGeo {
 inputs 2
 source "rgb absolute"
 scale 1
 filter_size 0
 name DisplaceGeo1
 xpos 1141
 ypos 365
}
push $N6d7bca00
push $N6ff88400
ContactSheet {
 inputs 2
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows 1
 columns 2
 roworder TopBottom
 name ContactSheet6
 xpos 1761
 ypos 176
}
Shuffle {
 name Shuffle17
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 1695
 ypos 223
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply6
 note_font "Bitstream Vera Sans"
 xpos 1695
 ypos 247
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression7
 note_font "Bitstream Vera Sans"
 xpos 1695
 ypos 271
}
Card2 {
 inputs 0
 display wireframe
 rows 18
 columns 1
 control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
 name Card2
 xpos 1578
 ypos 254
}
DisplaceGeo {
 inputs 2
 source "rgb absolute"
 scale 1
 filter_size 0
 name DisplaceGeo2
 xpos 1649
 ypos 389
}
push $N9ecd9000
Group {
 name DRT_CAM3
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -600
 ypos -13
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 3
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Shuffle {
 name Shuffle3
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos -600
 ypos 113
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply2
 note_font "Bitstream Vera Sans"
 xpos -600
 ypos 149
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression2
 note_font "Bitstream Vera Sans"
 xpos -600
 ypos 185
}
push $N9ecd9000
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints3
 xpos -465
 ypos 278
}
push $N2d33ca00
push $N2d320c00
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 5.1
 name PositionToPoints8
 xpos 1332
 ypos 388
}
Card2 {
 inputs 0
 control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
 name Card7
 xpos 3078
 ypos 401
}
push $N9a7fb000
Dot {
 name Dot7
 xpos -878
 ypos -172
}
Group {
 name DRT_CAM15
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -1239
 ypos -56
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {{parent.DRT_CAM4.chromaCompress} {parent.DRT_CAM4.chromaCompress} {parent.DRT_CAM4.chromaCompress}}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit {{DRT_CAM3.primaries_limit x2 3}}
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend {{parent.DRT_CAM4.cusp_mid_blend}}
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps {{parent.DRT_CAM3.smooth_cusps}}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out sRGB
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Text2 {
 font_size_toolbar 100
 font_width_toolbar 100
 font_height_toolbar 100
 message "focus distance: \[value input.focus_distance]"
 old_message {{102 111 99 117 115 32 100 105 115 116 97 110 99 101 58 32 51}
   }
 old_expression_markers {{16 16}
   }
 box {22.5 21.66666603 621.666626 207.4999847}
 yjustify bottom
 transforms {{0 2}
   }
 font {{ SF Mono : Regular : SF-Mono-Regular.otf : 0 }}
 global_font_scale 0.47
 center {1024 512}
 cursor_initialised true
 autofit_bbox false
 initial_cursor_position {{22.5 206.666687}
   }
 group_animations {{0} imported: 0 selected: items: "root transform/"}
 animation_layers {{1 11 1024 512 0 0 1 1 0 0 0 0}
   }
 name Text12
 xpos -1503
 ypos 164
}
Write {
 file /Users/afry/Working/ACESCentral/P3_Troubleshooting/ACESSample_sRGB_focus3.%04d.png
 raw true
 file_type png
 checkHashOnRead false
 version 2
 in_colorspace scene_linear
 out_colorspace scene_linear
 name Write1
 xpos -1523
 ypos 243
}
push $N6d6f9a00
Text2 {
 font_size_toolbar 100
 font_width_toolbar 100
 font_height_toolbar 100
 message "focus distance: \[value input.focus_distance]"
 old_message {{102 111 99 117 115 32 100 105 115 116 97 110 99 101 58 32 49 48 48 48}
   }
 old_expression_markers {{16 19}
   }
 box {22.5 21.66666603 621.666626 207.4999847}
 yjustify bottom
 transforms {{0 2}
   }
 cursor_position 23
 font {{ SF Mono : Regular : SF-Mono-Regular.otf : 0 }}
 global_font_scale 0.47
 center {1024 512}
 cursor_initialised true
 autofit_bbox false
 initial_cursor_position {{22.5 206.666687}
   }
 group_animations {{0} imported: 0 selected: items: "root transform/"}
 animation_layers {{1 11 1024 512 0 0 1 1 0 0 0 0}
   }
 name Text13
 xpos -1355
 ypos 163
}
Write {
 file /Users/afry/Working/ACESCentral/P3_Troubleshooting/ACESSample_sRGB_focus1000.%04d.png
 raw true
 file_type png
 checkHashOnRead false
 version 2
 in_colorspace scene_linear
 out_colorspace scene_linear
 name Write2
 xpos -1376
 ypos 236
}
Constant {
 inputs 0
 channels rgb
 color {0 0 1 0}
 name Constant5
 xpos 1023
 ypos 154
}
ColorCorrect {
 gain 0.1
 name ColorCorrect1
 xpos 1023
 ypos 226
}
set C2a208c00 [stack 0]
Constant {
 inputs 0
 channels rgb
 color {0 1 0 0}
 name Constant4
 xpos 870
 ypos 166
}
clone $C2a208c00 {
 xpos 870
 ypos 238
 selected false
}
Constant {
 inputs 0
 channels rgb
 color {1 0 0 0}
 name Constant3
 xpos 256
 ypos 138
}
clone $C2a208c00 {
 xpos 256
 ypos 210
 selected false
}
Axis3 {
 inputs 0
 rotate {0 {parent.ExpressionJMh.h-90} 0}
 name Axis1
 xpos 682
 ypos 738
}
Camera3 {
 translate {0 0.5 5}
 name Camera1
 xpos 665
 ypos 810
}
Wireframe {
 inputs 0
 operation "see through"
 line_color {1 1 1 0.02}
 line_color_panelDropped true
 name Wireframe4
 xpos 2995
 ypos 348
}
Card2 {
 display wireframe
 image_aspect false
 rows {{parent.Card3.rows}}
 columns 1
 translate {0 0.5 0}
 rotate {0 {parent.ExpressionJMh.h-90} 0}
 scaling {3 1 1}
 control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
 name Card6
 xpos 2991
 ypos 396
}
push $N2d588800
Dot {
 name Dot6
 xpos 1076
 ypos 21
}
set N6fdf9200 [stack 0]
Group {
 name DRT_CAM20
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 940
 ypos 71
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 primaries_in Rec.2020-D65
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit Rec.2020-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps {{parent.DRT_CAM3.smooth_cusps}}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 1
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Shuffle {
 name Shuffle21
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 940
 ypos 155
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply11
 note_font "Bitstream Vera Sans"
 xpos 940
 ypos 191
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression15
 note_font "Bitstream Vera Sans"
 xpos 940
 ypos 237
}
push $N6fdf9200
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints9
 xpos 1023
 ypos 348
}
Constant {
 inputs 0
 channels rgb
 format "256 256 0 0 256 256 1 square_256"
 name Constant2
 xpos 2298
 ypos -147
}
Reformat {
 type "to box"
 box_width 10
 box_height 1000
 box_fixed true
 name Reformat8
 xpos 2298
 ypos -66
}
Expression {
 expr0 y/(height-1)*100
 expr1 M
 expr2 h
 name ExpressionJMh
 xpos 2298
 ypos -42
 addUserKnob {20 User}
 addUserKnob {7 h R 0 360}
 h 139.3
 addUserKnob {7 M R 0 100}
 M 100
}
set Nbf822800 [stack 0]
Group {
 name DRT_CAM19
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 2826
 ypos -5
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit Rec.2020-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance {{parent.DRT_CAM16.focus_distance}}
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2417
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise 26e3fa9140dba069293d16b1ff00f8c2601e24030bb204cd83d564f8f5351214 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 12
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
push $Nbf822800
Group {
 name DRT_CAM17
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 2223
 ypos 36
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 12
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
set N2f5ee000 [stack 0]
ContactSheet {
 inputs 2
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows 1
 columns 2
 roworder TopBottom
 name ContactSheet9
 xpos 2826
 ypos 145
}
Shuffle {
 name Shuffle20
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 2826
 ypos 203
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply10
 note_font "Bitstream Vera Sans"
 xpos 2826
 ypos 240
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression14
 note_font "Bitstream Vera Sans"
 xpos 2826
 ypos 276
}
Wireframe {
 inputs 0
 operation "see through"
 line_width 0.1
 line_color {0 0 1 1}
 name Wireframe3
 xpos 2735
 ypos 234
}
Card2 {
 display wireframe
 rows {{parent.Card3.rows}}
 columns 1
 control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
 name Card5
 xpos 2731
 ypos 258
}
DisplaceGeo {
 inputs 2
 source "rgb absolute"
 scale 1
 filter_size 0
 name DisplaceGeo5
 xpos 2826
 ypos 339
}
push $Nbf822800
Group {
 name DRT_CAM18
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 2595
 ypos 12
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance {{parent.DRT_CAM16.focus_distance}}
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2417
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise 26e3fa9140dba069293d16b1ff00f8c2601e24030bb204cd83d564f8f5351214 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 12
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
push $N2f5ee000
ContactSheet {
 inputs 2
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows 1
 columns 2
 roworder TopBottom
 name ContactSheet8
 xpos 2595
 ypos 162
}
Shuffle {
 name Shuffle19
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 2595
 ypos 220
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply9
 note_font "Bitstream Vera Sans"
 xpos 2595
 ypos 257
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression13
 note_font "Bitstream Vera Sans"
 xpos 2595
 ypos 293
}
Wireframe {
 inputs 0
 operation "see through"
 line_width 0.1
 line_color {0 1 0 1}
 name Wireframe2
 xpos 2500
 ypos 251
}
Card2 {
 display wireframe
 rows {{parent.Card3.rows}}
 columns 1
 control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
 name Card4
 xpos 2500
 ypos 275
}
DisplaceGeo {
 inputs 2
 source "rgb absolute"
 scale 1
 filter_size 0
 name DisplaceGeo4
 xpos 2595
 ypos 356
}
push $Nbf822800
Group {
 name DRT_CAM16
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 2381
 ypos 32
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2430
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise 476961b8cea534d36c4f89bb3e086293a677b4c8cd1d73eccfdcc13f2bd95d0d 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    \n    \n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 13
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
push $N2f5ee000
ContactSheet {
 inputs 2
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows 1
 columns 2
 roworder TopBottom
 name ContactSheet7
 xpos 2381
 ypos 166
}
Shuffle {
 name Shuffle18
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 2381
 ypos 224
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply8
 note_font "Bitstream Vera Sans"
 xpos 2381
 ypos 261
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression10
 note_font "Bitstream Vera Sans"
 xpos 2381
 ypos 297
}
Wireframe {
 inputs 0
 operation "see through"
 line_width 0.1
 line_color {1 0 0 1}
 name Wireframe1
 xpos 2290
 ypos 255
}
Card2 {
 display wireframe
 rows 10
 columns 1
 control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
 name Card3
 xpos 2281
 ypos 295
}
DisplaceGeo {
 inputs 2
 source "rgb absolute"
 scale 1
 filter_size 0
 name DisplaceGeo3
 xpos 2381
 ypos 360
}
push 0
push $N2d588800
Dot {
 name Dot5
 xpos 923
 ypos 15
}
set N6d4ff400 [stack 0]
Group {
 name DRT_CAM8
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 787
 ypos 65
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 primaries_in P3-D65
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps {{parent.DRT_CAM3.smooth_cusps}}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 1
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Shuffle {
 name Shuffle15
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 787
 ypos 149
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply4
 note_font "Bitstream Vera Sans"
 xpos 787
 ypos 185
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression5
 note_font "Bitstream Vera Sans"
 xpos 787
 ypos 231
}
push $N6d4ff400
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints5
 xpos 870
 ypos 342
}
Reformat {
 inputs 0
 type "to box"
 box_width 544
 box_height 50
 box_fixed true
 name Reformat4
 xpos 644
 ypos -8
}
Expression {
 expr0 (y/(height-1))*100
 expr1 10
 expr2 (x/(width-1))*360
 name Expression3
 xpos 644
 ypos 23
}
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
 name Shuffle10
 xpos 644
 ypos 69
}
set N6d507600 [stack 0]
Group {
 name DRT_CAM6
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 529
 ypos 64
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 primaries_in AP1-ACES
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps {{parent.DRT_CAM3.smooth_cusps}}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 12
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Shuffle {
 name Shuffle11
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 529
 ypos 183
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply3
 note_font "Bitstream Vera Sans"
 xpos 529
 ypos 219
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression4
 note_font "Bitstream Vera Sans"
 xpos 529
 ypos 281
}
push $N6d507600
Grade {
 name Grade13
 xpos 681
 ypos 222
}
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.red 0 0 rgba.red 0 0 black -1 -1 rgba.green 0 1 black -1 -1 rgba.blue 0 2 rgba.alpha 0 3 rgba.alpha 0 3"
 name Shuffle13
 xpos 681
 ypos 246
}
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 0.001
 name PositionToPoints4
 xpos 672
 ypos 340
}
push 0
push $N2d588800
Dot {
 name Dot1
 xpos 238
 ypos -71
}
set N6fc9ac00 [stack 0]
Group {
 name DRT_CAM1
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 147
 ypos -34
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 primaries_in {{DRT_CAM3.primaries_limit}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit {{DRT_CAM3.primaries_limit}}
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 1
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Shuffle {
 name Shuffle1
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 102
 ypos 63
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply1
 note_font "Bitstream Vera Sans"
 xpos 102
 ypos 99
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression1
 note_font "Bitstream Vera Sans"
 xpos 102
 ypos 161
}
push $N6fc9ac00
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints1
 xpos 204
 ypos 284
}
Reformat {
 inputs 0
 type "to box"
 box_width 544
 box_height 50
 box_fixed true
 name Reformat1
 xpos -91
 ypos -112
}
Expression {
 expr0 (y/(height-1))*100
 expr1 10
 expr2 (x/(width-1))*360
 name Expression11
 xpos -91
 ypos -81
}
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
 name Shuffle14
 xpos -91
 ypos -35
}
set N9eade000 [stack 0]
Group {
 name DRT_CAM2
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos -215
 ypos -15
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 primaries_in AP1-ACES
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit {{DRT_CAM3.primaries_limit}}
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps {{parent.DRT_CAM3.smooth_cusps}}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 encoding_out BT.1886
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_out sRGB/Rec.709-D65
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 12
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Shuffle {
 name Shuffle12
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos -206
 ypos 79
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply16
 note_font "Bitstream Vera Sans"
 xpos -206
 ypos 115
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression12
 note_font "Bitstream Vera Sans"
 xpos -206
 ypos 177
}
push $N9eade000
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 0.001
 name PositionToPoints7
 xpos -78
 ypos 272
}
Scene {
 inputs 11
 name Scene1
 xpos 494
 ypos 720
}
Reformat {
 inputs 0
 type "to box"
 box_width 2048
 box_height 1024
 box_fixed true
 name Reformat7
 xpos 412
 ypos 835
}
ScanlineRender {
 inputs 3
 conservative_shader_sampling false
 antialiasing medium
 motion_vectors_type distance
 name ScanlineRender1
 xpos 484
 ypos 910
}
Text2 {
 font_size_toolbar 100
 font_width_toolbar 100
 font_height_toolbar 100
 message "J: 0 -> 100\nM: \[value ExpressionJMh.M]\nh: \[value ExpressionJMh.h]\n\nfocus distance: \[value DRT_CAM16.focus_distance]\n"
 old_message {{74 58 32 48 32 45 62 32 49 48 48 10 77 58 32 49 49 56 10 104 58 32 49 51 57 46 51 10 10 102 111 99 117 115 32 100 105 115 116 97 110 99 101 58 32 49 48 48 48 10}
   }
 old_expression_markers {{15 17 22 26 45 48}
   }
 box {22.5 21.66666603 621.666626 207.4999847}
 yjustify bottom
 transforms {{0 2}
   }
 cursor_position 99
 font {{ SF Mono : Regular : SF-Mono-Regular.otf : 0 }}
 global_font_scale 0.47
 center {1024 512}
 cursor_initialised true
 autofit_bbox false
 initial_cursor_position {{22.5 206.666687}
   }
 group_animations {{0} imported: 0 selected: items: "root transform/"}
 animation_layers {{1 11 1024 512 0 0 1 1 0 0 0 0}
   }
 name Text11
 xpos 489
 ypos 958
}
set N6d517600 [stack 0]
Reformat {
 type "to box"
 box_width 690
 scale 0.25
 name Reformat9
 xpos 602
 ypos 977
}
Write {
 file /Users/afry/Working/ACESCentral/P3_Troubleshooting/JMh_SideSliceDiagram_distance1000.%04d.png
 file_type png
 checkHashOnRead false
 version 7
 in_colorspace scene_linear
 out_colorspace scene_linear
 name Write4
 xpos 602
 ypos 1001
}
push $N6d700a00
Group {
 name PlotChromaticity
 xpos -877
 ypos 164
 addUserKnob {20 PlotChromaticity_tab l PlotChromaticity}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {6 plot_input l "plot input" t "Enable plotting of the input pixels" +STARTLINE}
 plot_input true
 addUserKnob {41 input_gamut l gamut t "Set the gamut that the input colors are encoded in" -STARTLINE T GamutToXYZ.gamut}
 addUserKnob {4 diagram l in t "Choose the type of chromaticity diagram: \nCIE 1931 xy Chromaticity Diagram\nCIE 1976 u' v' Uniform Chromaticity Scale Diagram" -STARTLINE M {"CIE 1931 xy" "CIE 1976 u' v'" "" ""}}
 addUserKnob {6 enable_sample_color l "sample color" t "Enable plotting of the sampled color" +STARTLINE}
 enable_sample_color true
 addUserKnob {41 sample_color l color t "sample and plot selected color" T SampleColor.color}
 addUserKnob {22 follow_viewer l "follow viewer" t "Follow the selected viewer node. This causes this node to automatically connect to whatever the followed viewer is connected to.\n\nThis is useful if you want to have a 2nd viewer showing a chromaticity plot for whever you're looking at in your main viewer." T "n = nuke.thisNode()\nnuke.root().begin()\nv = nuke.selectedNode()\nif not v or v.Class() != 'Viewer':\n    nuke.message('Please select a viewer node to follow.')\nelse:\n    v\['knobChanged'].setValue('v = nuke.activeViewer().node()\\nif v and v.name() == nuke.thisNode().name():\\n    con = v.input(nuke.activeViewer().activeInput())\\n    plt = nuke.toNode(\"\{0\}\")\\n    plt.setInput(0, con)'.format(n.name()))" +STARTLINE}
 addUserKnob {22 unfollow_viewer l "unfollow viewer" -STARTLINE T "n = nuke.thisNode()\nnuke.root().begin()\nv = nuke.selectedNode()\nif not v or v.Class() != 'Viewer':\n    nuke.message('Please select a viewer node to unfollow.')\nelse:\n    v\['knobChanged'].setValue('')"}
 addUserKnob {26 plot_dimensions_label l " " T "<b>Chromaticity Diagram"}
 addUserKnob {3 resolution l " resolution" t "resolution to output"}
 resolution 2048
 addUserKnob {7 right_margin l "right margin" R 1 1.5}
 right_margin 1.1
 addUserKnob {7 left_margin l "left margin" R 0 0.2}
 left_margin 0.1
 addUserKnob {6 draw_spectral_locus l "spectrum locus" t "draw the spectrum locus: the boundary of color the human eye can see." +STARTLINE}
 draw_spectral_locus true
 addUserKnob {6 draw_line_of_purples l "line of purples" t "draw the \"line of purples\"" -STARTLINE}
 draw_line_of_purples true
 addUserKnob {6 draw_planckian_locus l "planckian locus" t "Display the planckian locus or the blackbody locus." +STARTLINE}
 draw_planckian_locus true
 addUserKnob {6 gamut_grid l "gamut grid" t "Display a gamut boundary with a grid or dot pattern" +STARTLINE}
 addUserKnob {41 gamut_gamutgrid l "" t "gamut for gamutgrid" -STARTLINE T RGBToXYZ_GamutGrid.gamut}
 addUserKnob {4 gamut_grid_style l style t "Choose the style to display the gamut plot" -STARTLINE M {grid dots "" "" "" ""}}
 addUserKnob {4 distribution l dist t "Which chromaticity space should the overlays be constructed in? \n\nYxy is familiar, but not very perceptually uniform.\n\nu'v' is designed to be more perceptually uniform." -STARTLINE M {"1931 Yxy" "1976 u'v'" "" ""}}
 addUserKnob {7 density t "Density of the grid or points" R 10 100}
 density 50
 addUserKnob {6 gamut_a l "gamut a" t "Display a gamut outline" +STARTLINE}
 addUserKnob {41 gamut_a_1 l "" -STARTLINE T RGBToXYZ_GamutA.gamut}
 addUserKnob {6 gamut_b l "gamut b" t "Display a gamut outline" +STARTLINE}
 gamut_b true
 addUserKnob {41 gamut_b_1 l "" -STARTLINE T RGBToXYZ_GamutB.gamut}
 addUserKnob {6 gamut_c l "gamut c" t "Display a gamut outline" +STARTLINE}
 gamut_c true
 addUserKnob {41 gamut_c_1 l "" -STARTLINE T RGBToXYZ_GamutC.gamut}
 addUserKnob {6 draw_pointers_gamut l "pointer's gamut" t "DrawPointer's gamut boundary" +STARTLINE}
 addUserKnob {6 draw_pointers_samples l "pointers sample colors" t "show the individual pointer gamut samples" -STARTLINE}
 addUserKnob {6 draw_macbeth_chart l "macbeth chart" t "draw a ColorChecker24 aka Macbeth Chart" +STARTLINE}
 addUserKnob {6 coordinate_system l "coordinate system" t "Draw CIE xy coordinate grid x and y axes" +STARTLINE}
 coordinate_system true
 addUserKnob {6 map_overlays_to_input_gamut l "map overlays to input gamut" t "This maps the overlays like the spectral locus, pointer's gamut, and the gamut overlay to the working gamut instead of keeping them as XYZ.\n\nFor example if the input gamut is ACEScg, these overlays will be mapped to that. Note that this can cause most of the overlays to be negative or highly saturated which might harm the visual appearance." +STARTLINE}
 map_overlays_to_input_gamut true
}
 Group {
  inputs 0
  name GamutGrid1
  xpos -920
  ypos -201
  postage_stamp true
  addUserKnob {20 GamutGrid}
  addUserKnob {3 style}
  style {{!parent.gamut_grid_style}}
  addUserKnob {3 distribution -STARTLINE}
  distribution {{parent.distribution}}
  addUserKnob {7 density R 10 150}
  density {{parent.density}}
  addUserKnob {26 ""}
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {12 wxy}
  wxy {{parent.RGBToXYZ_GamutGrid.wxy} {parent.RGBToXYZ_GamutGrid.wxy}}
 }
  ColorWheel {
   inputs 0
   format "512 512 0 0 512 512 1 square_512"
   centerSaturation 1
   fillFormat false
   area {-170 -158 682 670}
   name ColorWheel4
   xpos -260
   ypos -15
   postage_stamp false
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop2
   xpos -260
   ypos 27
  }
  Reformat {
   type scale
   scale {{max(parent.density/50,0.25)}}
   resize distort
   filter impulse
   pbb true
   name Reformat3
   xpos -260
   ypos 110
  }
set N9eaea600 [stack 0]
push $N9eaea600
  ContactSheet {
   inputs 2
   width {{width*columns}}
   height {{height/pixel_aspect*rows}}
   rows 1
   columns 2
   roworder TopBottom
   name ContactSheet2
   xpos -260
   ypos 169
  }
  Dot {
   name Dot1
   label " "
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -226
   ypos 246
  }
  ColorWheel {
   inputs 0
   format "512 512 0 0 512 512 1 square_512"
   fillFormat false
   area {40 40 472 472}
   name ColorWheel1
   xpos -40
   ypos -664
   postage_stamp false
  }
  Reformat {
   type scale
   scale {{max(parent.density/50,0.25)}}
   resize distort
   filter impulse
   pbb true
   name Reformat1
   xpos -40
   ypos -628
  }
  Crop {
   box {0 0 {width} {height}}
   reformat true
   name Crop1
   xpos -40
   ypos -602
  }
  Unpremult {
   name Unpremult1
   xpos -40
   ypos -526
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos -415
  }
  Colorspace {
   colorspace_in CIE-XYZ
   colorspace_out CIE-Yxy
   name Colorspace1
   label "\[value colorspace_in] -> \[value colorspace_out]"
   xpos -40
   ypos -341
  }
set N9eeb7000 [stack 0]
  Dot {
   name Dot2
   label " "
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -556
   ypos -331
  }
  Expression {
   expr0 r
   expr1 "4*g / ( -2*g + 12*b + 3)"
   expr2 "9*b / ( -2*g + 12*b + 3)"
   name Expression5
   label "CIE Yxy to CIELuv"
   xpos -590
   ypos -304
   disable {{!parent.distribution}}
  }
  Expression {
   expr0 r
   expr1 "(-(degrees(atan2(g-white.x, b-white.y))-180)+270)%360/360"
   expr2 "hypot(g-white.x, b-white.y)"
   expr3 a
   name Expression3
   xpos -590
   ypos -261
   cached true
   addUserKnob {20 User}
   addUserKnob {12 white}
   white {{"parent.distribution ? 4*parent.wxy.x / ( -2 * parent.wxy.x + 12 * parent.wxy.y + 3) : parent.wxy"} {"parent.distribution ? 9*parent.wxy.y / ( -2*parent.wxy.x + 12*parent.wxy.y + 3) : parent.wxy"}}
  }
set N2f5f9400 [stack 0]
  Posterize {
   channels rgb
   Colors {{rint(parent.density/3*2)}}
   name Posterize1
   xpos -590
   ypos -191
  }
set N2f5f9800 [stack 0]
push $N2f5f9400
  Dot {
   name Dot15
   xpos -446
   ypos -257
  }
  Copy {
   inputs 2
   from0 rgba.blue
   to0 rgba.blue
   name Copy1
   xpos -480
   ypos -154
  }
push $N2f5f9800
push $N2f5f9400
  Dot {
   name Dot16
   xpos -666
   ypos -257
  }
  Copy {
   inputs 2
   from0 rgba.green
   to0 rgba.green
   name Copy2
   xpos -700
   ypos -153
  }
  ContactSheet {
   inputs 2
   width {{width*columns}}
   height {{height/pixel_aspect*rows}}
   rows 1
   columns 2
   center true
   roworder TopBottom
   name ContactSheet3
   xpos -590
   ypos -106
  }
  Expression {
   expr0 r
   expr1 cos(radians(g*360))*b+white.x
   expr2 sin(radians(g*360))*b+white.y
   expr3 a
   name Expression19
   xpos -590
   ypos -58
   cached true
   addUserKnob {20 User}
   addUserKnob {12 white}
   white {{parent.Expression3.white} {parent.Expression3.white}}
  }
  Expression {
   expr0 r
   expr1 "9*g / ( 6*g - 16*b + 12)"
   expr2 "4*b/ ( 6*g - 16*b + 12)"
   name Expression2
   label "CIELuv to CIE Yxy"
   xpos -590
   ypos -16
   disable {{!parent.distribution}}
  }
  Colorspace {
   colorspace_in CIE-Yxy
   colorspace_out CIE-XYZ
   name Colorspace2
   label "\[value colorspace_in] -> \[value colorspace_out]"
   xpos -590
   ypos 32
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   invert true
   name ColorMatrix1
   label "XYZ to RGB"
   xpos -590
   ypos 81
  }
  Clamp {
   channels rgba
   maximum_enable false
   name ClampMin2
   xpos -590
   ypos 119
  }
  Clamp {
   channels alpha
   minimum 1
   MinClampTo_enable true
   MaxClampTo_enable true
   name Clamp1
   xpos -590
   ypos 152
  }
  Premult {
   name Premult1
   xpos -590
   ypos 194
  }
  Merge2 {
   inputs 2
   operation under
   bbox B
   name Merge2
   xpos -590
   ypos 242
  }
  Fill {
   output alpha
   name Fill1
   xpos -590
   ypos 297
  }
  Dot {
   name Dot3
   label " GRID"
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -556
   ypos 378
  }
push $N9eaea600
push $N9eeb7000
  Expression {
   expr0 r
   expr1 "4*g / ( -2*g + 12*b + 3)"
   expr2 "9*b / ( -2*g + 12*b + 3)"
   name Expression4
   label "CIE Yxy to CIELuv"
   xpos -40
   ypos -280
   disable {{!parent.distribution}}
  }
  Expression {
   expr0 r
   expr1 rint(g*Colors)/Colors
   expr2 rint(b*Colors)/Colors
   expr3 a
   name Expression1
   label rint
   xpos -40
   ypos -232
   addUserKnob {20 User}
   addUserKnob {7 Colors R 1 256}
   Colors {{parent.density}}
  }
  Expression {
   expr0 r
   expr1 "9*g / ( 6*g - 16*b + 12)"
   expr2 "4*b/ ( 6*g - 16*b + 12)"
   name Expression6
   label "CIELuv to CIE Yxy"
   xpos -40
   ypos -184
   disable {{!parent.distribution}}
  }
  Colorspace {
   colorspace_in CIE-Yxy
   colorspace_out CIE-XYZ
   name Colorspace3
   label "\[value colorspace_in] -> \[value colorspace_out]"
   xpos -40
   ypos -112
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   invert true
   name ColorMatrix3
   label "XYZ to RGB"
   xpos -40
   ypos -57
  }
  Clamp {
   channels alpha
   minimum 1
   MinClampTo_enable true
   MaxClampTo_enable true
   name Clamp4
   xpos -40
  }
  Premult {
   name Premult2
   xpos -40
   ypos 55
  }
  Merge2 {
   inputs 2
   operation under
   bbox B
   name Merge1
   xpos -40
   ypos 110
  }
  Clamp {
   channels rgba
   maximum_enable false
   name ClampMin1
   xpos -40
   ypos 273
  }
  Dot {
   name Dot4
   label " DOTS"
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -6
   ypos 378
  }
  Switch {
   inputs 2
   which {{parent.style}}
   name Switch1
   xpos -257
   ypos 483
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   name ColorMatrix2
   label "RGB to XYZ"
   xpos -257
   ypos 560
  }
  Output {
   name Output
   xpos -257
   ypos 740
  }
  ColorWheel {
   inputs 0
   format "256 256 0 0 256 256 1 square_256"
   area {40 40 472 472}
   name ColorWheel2
   xpos -37
   ypos -705
   postage_stamp false
  }
 end_group
set N6d51aa00 [stack 0]
 Group {
  name RGBToXYZ_GamutGrid
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -1030
  ypos -184
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut ACEScg
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 ColorWheel {
  inputs 0
  format "512 512 0 0 512 512 1 square_512"
  centerSaturation 1
  fillFormat false
  area {-196 -184 708 696}
  name ColorWheel1
  xpos -920
  ypos 5
 }
 Crop {
  box {0 0 {width} {height}}
  name Crop1
  xpos -920
  ypos 87
 }
 BlackOutside {
  name BlackOutside3
  xpos -920
  ypos 134
 }
set N6fc89800 [stack 0]
 Group {
  name RGBToXYZ_GamutC
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -1140
  ypos 176
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" "DaVinci WG" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut Rec709
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.7006223798 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.1487748176 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.101058729 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2741185129 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.8736318946 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 -0.1477504075 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 -0.09896291792 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 -0.1378953159 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 1.325916052 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.313 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.1682 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.9877 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.079 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 -0.1155 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Position {
  translate {{parent.Reformat1.box_width+Rectangle1.area.r+input.width} {parent.ReformatBox4.box_width-input.height}}
  name Position6
  xpos -1140
  ypos 254
 }
push $N6fc89800
 Group {
  name RGBToXYZ_GamutB
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -1030
  ypos 176
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" "DaVinci WG" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut P3D65
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.7006223798 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.1487748176 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.101058729 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2741185129 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.8736318946 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 -0.1477504075 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 -0.09896291792 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 -0.1378953159 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 1.325916052 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.313 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.1682 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.9877 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.079 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 -0.1155 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Position {
  translate {{parent.Reformat1.box_width+Rectangle1.area.r} {parent.ReformatBox4.box_width-input.height*2}}
  name Position5
  xpos -1030
  ypos 254
 }
push $N6fc89800
 Group {
  name RGBToXYZ_GamutA
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -920
  ypos 176
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" "DaVinci WG" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut Rec2020
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.7006223798 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.1487748176 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.101058729 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2741185129 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.8736318946 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 -0.1477504075 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 -0.09896291792 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 -0.1378953159 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 1.325916052 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.313 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.1682 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.9877 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.079 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 -0.1155 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Position {
  translate {{parent.Reformat1.box_width+Rectangle1.area.r} {parent.ReformatBox4.box_width-input.height}}
  name Position4
  xpos -920
  ypos 254
 }
push $N6d51aa00
 Reformat {
  type scale
  scale 0.8
  turn true
  filter impulse
  black_outside true
  name Reformat2
  xpos -920
  ypos -129
 }
 BlackOutside {
  name BlackOutside2
  xpos -920
  ypos -106
 }
 Position {
  translate {{Rectangle1.area.r} {parent.Position3.translate.y-input.height}}
  name Position2
  xpos -920
  ypos -81
 }
 Group {
  inputs 0
  name ColorChecker24_After_November_2014
  label "CIE XYZ D50"
  xpos -920
  ypos -352
  addUserKnob {20 colorchecker_tab l "ColorChecker24 - After November 2014"}
  addUserKnob {3 patch_resolution}
  patch_resolution 48
 }
  Group {
   inputs 0
   name bluish_green
   selected true
   xpos 622
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.30451114 0.4143554688 0.344352688 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "bluish green"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 6
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 125
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name blue_flower
   xpos 512
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.2419823988 0.2287175998 0.3282104382 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "blue flower"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 5
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name foliage
   xpos 402
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1114392339 0.1346792679 0.05239320311 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob foliage
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 4
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name blue_sky
   xpos 292
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1652470004 0.1785519348 0.2546024121 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "blue sky"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 3
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name light_skin
   xpos 180
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.3811104477 0.336202304 0.1852590702 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "light skin"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 2
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 63
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 135
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name dark_skin
   xpos 70
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1136398927 0.09832436105 0.047793811 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "dark skin"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 1
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 290
    ypos 63
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 290
    ypos 158
   }
   Output {
    name Output
    xpos 290
    ypos 230
   }
  end_group
  Group {
   inputs 0
   name orange_yellow
   xpos 622
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.4769723742 0.4293377578 0.06005041429 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "orange yellow"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 12
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name yellow_green
   xpos 512
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.3427379502 0.4331759409 0.08330791241 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "yellow green"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 11
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name purple
   xpos 401
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.08353888545 0.06276662955 0.1042075686 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob purple
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 10
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name moderate_red
   xpos 290
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.2915036416 0.188999956 0.09736350318 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "moderate red"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 9
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name purplish_blue
   xpos 180
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1200518326 0.1091090233 0.2874447494 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "purplish blue"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 8
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name orange
   xpos 74
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.4073691399 0.3126416159 0.05130591012 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob orange
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 7
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name cyan
   xpos 622
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1247966941 0.180609913 0.2913392383 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob cyan
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 18
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name magenta
   xpos 512
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.299122798 0.1895114577 0.2213469194 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob magenta
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 17
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name yellow
   xpos 399
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.5888922356 0.5992976803 0.07077420003 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob yellow
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 16
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 125
   }
   Output {
    name Output
    xpos 262
    ypos 182
   }
  end_group
  Group {
   inputs 0
   name red
   xpos 292
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.2143728424 0.127800835 0.03868150726 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob red
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 15
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name green
   xpos 182
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1413517689 0.2233437582 0.07287461742 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob green
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 14
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name blue
   xpos 72
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.06809095613 0.05596214063 0.2077405936 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob blue
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 13
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name black_2
   xpos 623
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.03042544265 0.03151319431 0.02656724434 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "black 2 (1.5 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 24
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 125
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_3
   xpos 512
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.08448968042 0.08817234828 0.07391630753 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 3.5 (1.05 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 23
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_5
   xpos 403
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1835495863 0.1906228754 0.1566717383 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 5 (.70 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 22
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_6
   xpos 292
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.3495921991 0.3648652066 0.3013565492 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 6.5 (.44 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 21
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_8
   xpos 179
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.5665335579 0.5899709702 0.4828473821 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 8 (.23 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 20
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name white_9
   xpos 70
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.8436985288 0.8806903203 0.6936778752 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "white 9.5 (.05 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 19
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 134
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  ContactSheet {
   inputs 24
   width {{"rint(parent.patch_resolution * 6 + gap * 7)"}}
   height {{"rint(parent.patch_resolution * 4 + gap * 5)"}}
   rows 4
   columns 6
   startframe 1
   endframe 1
   name ContactSheet
   xpos 620
   ypos 206
  }
  Unpremult {
   name Unpremult1
   xpos 620
   ypos 278
  }
  Output {
   name Output
   xpos 620
   ypos 446
  }
 end_group
 BlackOutside {
  name BlackOutside4
  xpos -920
  ypos -298
 }
 Position {
  translate {{parent.Reformat1.box_width*3+Rectangle1.area.r} {parent.ReformatBox4.box_width-input.height}}
  name Position7
  xpos -920
  ypos -273
 }
 Constant {
  inputs 0
  format "256 256 0 0 256 256 1 square_256"
  name Constant5
  xpos -700
  ypos -1354
  postage_stamp false
 }
 Dot {
  name Dot25
  xpos -666
  ypos -1302
 }
set N6fda0e00 [stack 0]
 Dot {
  name Dot27
  xpos -1546
  ypos -1302
 }
 Reformat {
  type "to box"
  box_width {{parent.Reformat1.box_width}}
  box_height 100
  box_fixed true
  name ReformatBox1
  xpos -1580
  ypos -994
 }
 Ramp {
  p0 {0 0}
  p1 {{input.width} 0}
  color {{p1}}
  name Ramp3
  xpos -1580
  ypos -898
 }
 ColorLookup {
  lut {master {}
    red {curve 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914}
    green {curve 0.433 0.464 0.513 0.611 0.576 0.46 0.426 0.412 0.404 0.397 0.384 0.374 0.346 0.333 0.311 0.287 0.257 0.23 0.21 0.219 0.208 0.211 0.208 0.187 0.191 0.187 0.18 0.164 0.17 0.177 0.175 0.188 0.252 0.325 0.385 0.416 0.433 0.487 0.532 0.588 0.637 0.634 0.549 0.506 0.49 0.458 0.426 0.412 0.397 0.365 0.337 0.301 0.262 0.221 0.192 0.164 0.167 0.162 0.176 0.179 0.148 0.156 0.142 0.148 0.138 0.145 0.145 0.161 0.197 0.256 0.324 0.393 0.451 0.487 0.508 0.538 0.587 0.634 0.659 0.611 0.552 0.526 0.484 0.452 0.428 0.406 0.371 0.334 0.293 0.243 0.204 0.177 0.151 0.151 0.162 0.158 0.161 0.142 0.141 0.129 0.134 0.14 0.156 0.166 0.192 0.221 0.265 0.325 0.392 0.451 0.508 0.48 0.513 0.554 0.597 0.63 0.634 0.58 0.546 0.499 0.466 0.434 0.408 0.372 0.332 0.288 0.242 0.202 0.179 0.16 0.157 0.162 0.157 0.159 0.149 0.153 0.147 0.154 0.164 0.18 0.199 0.226 0.25 0.279 0.325 0.38 0.439 0.48 0.436 0.468 0.502 0.541 0.57 0.605 0.594 0.555 0.511 0.473 0.439 0.409 0.371 0.332 0.288 0.252 0.217 0.196 0.181 0.178 0.185 0.176 0.173 0.168 0.176 0.178 0.19 0.202 0.214 0.235 0.254 0.27 0.291 0.323 0.366 0.41 0.436 0.396 0.414 0.438 0.465 0.485 0.527 0.566 0.557 0.523 0.478 0.442 0.409 0.371 0.334 0.294 0.265 0.244 0.223 0.225 0.212 0.218 0.211 0.211 0.207 0.214 0.217 0.229 0.237 0.244 0.264 0.275 0.285 0.3 0.321 0.348 0.376 0.396 0.357 0.368 0.377 0.391 0.402 0.431 0.481 0.503 0.521 0.482 0.444 0.409 0.372 0.337 0.307 0.286 0.27 0.257 0.247 0.251 0.257 0.255 0.254 0.25 0.258 0.259 0.265 0.269 0.278 0.284 0.292 0.297 0.305 0.317 0.33 0.344 0.357 0.321 0.322 0.328 0.332 0.333 0.346 0.365 0.389 0.411 0.459 0.443 0.399 0.352 0.327 0.313 0.304 0.3 0.294 0.295 0.294 0.293 0.292 0.291 0.295 0.3 0.301 0.302 0.304 0.304 0.304 0.305 0.307 0.309 0.312 0.313 0.316 0.321}
    blue {curve 0.26 0.281 0.298 0.306 0.342 0.365 0.39 0.381 0.392 0.416 0.413 0.43 0.448 0.446 0.433 0.425 0.419 0.394 0.362 0.328 0.305 0.298 0.286 0.247 0.26 0.219 0.199 0.168 0.178 0.14 0.11 0.084 0.104 0.158 0.18 0.225 0.26 0.235 0.26 0.28 0.298 0.327 0.372 0.395 0.417 0.43 0.435 0.455 0.488 0.479 0.521 0.522 0.515 0.49 0.436 0.383 0.331 0.295 0.282 0.258 0.219 0.208 0.179 0.168 0.141 0.129 0.106 0.094 0.095 0.112 0.127 0.165 0.199 0.235 0.226 0.258 0.28 0.298 0.316 0.361 0.399 0.427 0.446 0.461 0.482 0.52 0.521 0.553 0.563 0.573 0.524 0.454 0.389 0.33 0.295 0.266 0.247 0.214 0.195 0.168 0.178 0.142 0.14 0.128 0.129 0.126 0.131 0.144 0.167 0.199 0.226 0.238 0.266 0.289 0.31 0.329 0.351 0.395 0.428 0.453 0.475 0.494 0.533 0.542 0.568 0.584 0.576 0.53 0.451 0.385 0.331 0.299 0.266 0.245 0.22 0.206 0.184 0.174 0.167 0.166 0.166 0.173 0.172 0.165 0.172 0.187 0.208 0.238 0.258 0.28 0.3 0.321 0.343 0.362 0.391 0.427 0.458 0.482 0.503 0.546 0.554 0.573 0.582 0.546 0.499 0.431 0.375 0.33 0.304 0.275 0.254 0.234 0.225 0.212 0.209 0.206 0.203 0.21 0.215 0.212 0.204 0.208 0.214 0.231 0.258 0.277 0.294 0.31 0.328 0.348 0.372 0.397 0.427 0.462 0.487 0.51 0.544 0.558 0.559 0.556 0.503 0.444 0.402 0.355 0.329 0.309 0.289 0.275 0.26 0.254 0.245 0.245 0.241 0.238 0.249 0.249 0.245 0.241 0.242 0.246 0.258 0.277 0.295 0.305 0.315 0.327 0.339 0.359 0.39 0.421 0.461 0.491 0.515 0.54 0.546 0.522 0.478 0.429 0.393 0.368 0.345 0.325 0.313 0.303 0.295 0.286 0.284 0.279 0.277 0.274 0.277 0.277 0.28 0.276 0.273 0.274 0.279 0.285 0.295 0.311 0.314 0.316 0.32 0.323 0.331 0.346 0.367 0.397 0.468 0.513 0.494 0.425 0.388 0.372 0.348 0.336 0.331 0.326 0.32 0.316 0.314 0.312 0.309 0.321 0.32 0.319 0.305 0.317 0.316 0.316 0.315 0.316 0.317 0.319 0.321 0.311}
    alpha {}}
  name ColorLookup7
  label "Pointers Samples Yxy\nSource: https://www.rit.edu/cos/colorscience/rc_useful_data.php"
  xpos -1580
  ypos -790
 }
 Colorspace {
  colorspace_in CIE-Yxy
  primary_in "Adobe (1998)"
  colorspace_out CIE-XYZ
  name Colorspace12
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -1580
  ypos -688
 }
 Fill {
  output alpha
  name Fill5
  xpos -1580
  ypos -639
 }
 BlackOutside {
  name BlackOutside7
  xpos -1580
  ypos -562
 }
 Position {
  translate {6 {parent.Position1.translate.y-input.height}}
  name Position3
  xpos -1580
  ypos -538
 }
 Dot {
  name Dot15
  xpos -1546
  ypos -414
 }
push $N6fda0e00
 Reformat {
  type "to box"
  box_width 2048
  box_height 2048
  box_fixed true
  name ReformatBox4
  xpos -700
  ypos -1258
 }
 Expression {
  temp_name0 n
  temp_expr0 input.width/8
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 x/width*(1-y/height)
  channel3 alpha
  expr3 1
  name Expression7
  xpos -700
  ypos -1209
 }
 Dot {
  name Dot10
  xpos -666
  ypos -1158
 }
set N7cf37200 [stack 0]
 Dot {
  name Dot26
  xpos -886
  ypos -1158
 }
set N7cf37600 [stack 0]
 Dot {
  name Dot23
  xpos -1106
  ypos -1158
 }
set N7cf37a00 [stack 0]
 Dot {
  name Dot12
  xpos -1326
  ypos -1158
 }
 Mirror2 {
  flip true
  flop true
  name Mirror2_1
  xpos -1360
  ypos -1042
 }
 Reformat {
  type "to box"
  box_width 512
  box_height {{box_width}}
  box_fixed true
  name Reformat1
  xpos -1360
  ypos -994
 }
 Gamma {
  channels rgb
  value 2
  name Gamma1
  xpos -1360
  ypos -898
 }
 Multiply {
  channels rgb
  value 8000
  name Multiply1
  label "\[value value]"
  xpos -1360
  ypos -811
 }
 ColorLookup {
  lut {master {}
    red {curve R 0.4830000103 x50 0.5045000315 0.5260000229 0.5475000143 0.5690000057 0.5904999971 0.6119999886 0.63349998 0.6549999714 0.6805312037 0.7087500095 0.7315937281 0.7409999967 0.7409999967 0.7409999967 0.7409999967 0.7409999967 0.75459373 0.7845000029 0.8144062757 0.8280000091 0.8280000091 0.8280000091 0.8280000091 0.8280000091 0.8009687662 0.74150002 0.6820312142 0.6549999714 0.6684374809 0.6980000138 0.7275624871 0.7409999967 0.7315937281 0.7087500095 0.6805312037 0.6549999714 0.629468739 0.6012499928 0.5784062743 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5555624962 0.5260000229 0.4964375198 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4964375198 0.5260000229 0.5555624962 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5653046966 0.5555624962 0.5417890549 0.5260000229 0.5102109313 0.4964375198 0.4866953194 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4695625007 0.4400000274 0.4104375243 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.4104375243 0.4400000274 0.4695625007 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103}
    green {curve R 0.6589999795 x50 0.6542205811 0.6484853029 0.6414804459 0.6340000033 0.6249843836 0.6147499681 0.6041406393 0.5939999819 0.5844687223 0.575124979 0.5659687519 0.5569999814 0.5484530926 0.5402500033 0.5319218636 0.5230000019 0.5131718516 0.5027499795 0.4922031164 0.4819999933 0.4722187519 0.4626249969 0.4532187581 0.4440000057 0.4351093769 0.4265000224 0.4178906381 0.4090000093 0.3997343779 0.3902499974 0.380640626 0.3709999919 0.3614374995 0.3518749774 0.3421249986 0.3319999874 0.321398437 0.3104375005 0.2992577851 0.2879999876 0.2764999866 0.2647500038 0.2531249821 0.2419999987 0.2312265635 0.2206875086 0.2108047009 0.202000007 0.1947187632 0.1886250079 0.1829687506 0.1770000011 0.1693515629 0.1608124971 0.1538671851 0.1509999931 0.1509999931 0.1509999931 0.1509999931 0.1509999931 0.1527187377 0.1564999968 0.1602812558 0.1620000005 0.1620000005 0.1620000005 0.1620000005 0.1620000005 0.1612187475 0.1595000029 0.1577812582 0.1570000052 0.1573124975 0.1579999924 0.1586875021 0.1589999944 0.1575781256 0.1543750018 0.1509843767 0.1490000039 0.1485625058 0.1484999955 0.1484375 0.1480000019 0.1467812508 0.1449999958 0.1432187557 0.1420000046 0.1415625066 0.1414999962 0.1414375007 0.1410000026 0.1397656202 0.1378750056 0.1357968748 0.1340000033 0.1323750019 0.1307500005 0.1295000017 0.1289999932 0.130031243 0.1324999928 0.1354687512 0.1379999965 0.1402187496 0.1424999982 0.1442812532 0.1449999958 0.1449999958 0.1449999958 0.1449999958 0.1449999958 0.1464921832 0.1503124982 0.1554765552 0.1609999985 0.1673984379 0.1749375015 0.1822578013 0.1879999936 0.1906718612 0.1913749874 0.1926406175 0.1969999969 0.2064140588 0.2199375033 0.2357421964 0.2520000041 0.2688750029 0.2871249914 0.3058125079 0.324000001 0.3417187631 0.359375 0.3765937686 0.3930000067 0.4082968831 0.4227499962 0.4368281364 0.451000005 0.4659531415 0.4812500179 0.4956718981 0.5080000162 0.5169296861 0.5234375 0.5297265649 0.5379999876 0.5491171479 0.5618124604 0.5751015544 0.5879999995 0.6009531021 0.6142500043 0.6266719103 0.6370000243 0.6457066536 0.6532088518 0.6575522423 0.6589999795}
    blue {curve R 0.3160000145 x50 0.324739933 0.3330312669 0.3418398499 0.351000011 0.3607422113 0.3709374964 0.3811640739 0.3910000026 0.4003046751 0.4093124866 0.4181640446 0.4269999862 0.4359609187 0.4449374974 0.453695327 0.4620000124 0.4697890878 0.4771875143 0.4842422009 0.4909999967 0.4971874952 0.5028749704 0.5086249709 0.5149999857 0.5227031112 0.53125 0.5394218564 0.5460000038 0.5502656102 0.5530000329 0.5552343726 0.5580000281 0.561632812 0.5655625463 0.5694609284 0.5730000138 0.5765469074 0.5801249743 0.5828906298 0.5839999914 0.5838750005 0.5830000043 0.5806249976 0.5759999752 0.5682968497 0.5576249957 0.5446406007 0.5299999714 0.5128515363 0.4931874871 0.4729296863 0.4539999962 0.4368359447 0.420437485 0.4045703113 0.3889999986 0.3731718659 0.3573749959 0.3426406384 0.3300000131 0.3193906248 0.310375005 0.3034218848 0.298999995 0.2972500026 0.2969999909 0.2967499793 0.2949999869 0.2899531126 0.2821249962 0.2734843791 0.2660000026 0.2602812648 0.2552500069 0.2503437698 0.2450000048 0.2380000055 0.2300000042 0.2232500017 0.2199999988 0.2195625007 0.2194999903 0.2194374949 0.2189999968 0.2183593661 0.2176249921 0.2163281292 0.2140000015 0.2101874948 0.205249995 0.1999374926 0.1949999928 0.1904453039 0.185937494 0.1817109436 0.1780000031 0.1754062474 0.1736250073 0.1715312451 0.1679999977 0.1620937437 0.1546249986 0.147093758 0.1410000026 0.1372031271 0.1347499937 0.1324218661 0.1289999932 0.1237656176 0.1174999923 0.1112343743 0.1059999987 0.1021796837 0.09918750077 0.09660156071 0.09399999678 0.09089062363 0.0876249969 0.0850468725 0.08399999887 0.08524999768 0.0882499963 0.09187500179 0.09499999881 0.09706249833 0.09875000268 0.1008125022 0.1040000021 0.1084140688 0.1136875004 0.1198671907 0.1270000041 0.1355390698 0.145312503 0.1554296911 0.1650000066 0.1739453226 0.1826875061 0.1910859346 0.199000001 0.2061250061 0.2126249969 0.2190624923 0.2259999961 0.2338827997 0.2423124909 0.2505859137 0.2579999864 0.2642968595 0.26987499 0.2750156224 0.2800000012 0.2847812474 0.2892500162 0.2935937643 0.2980000079 0.3025000095 0.3070000112 0.3115000129 0.3160000145}
    alpha {}}
  name ColorLookup5
  label "Pointer's Gamut Boundary Yxy\ninterpolated: incr 50 - 0 to 8000"
  xpos -1360
  ypos -775
 }
 Multiply {
  channels rgb
  value {0.31 1 1 1}
  name Multiply2
  label "dim boundary"
  xpos -1360
  ypos -725
 }
 Colorspace {
  colorspace_in CIE-Yxy
  primary_in "Adobe (1998)"
  colorspace_out CIE-XYZ
  name Colorspace5
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -1360
  ypos -688
 }
 Fill {
  output alpha
  name Fill4
  xpos -1360
  ypos -639
 }
 BlackOutside {
  name BlackOutside1
  xpos -1360
  ypos -562
 }
 Position {
  translate {6 {ReformatBox4.box_width-input.width}}
  name Position1
  xpos -1360
  ypos -538
 }
 Dot {
  name Dot24
  xpos -1326
  ypos -486
 }
push $N7cf37a00
 Reformat {
  type "to box"
  box_width {{parent.Reformat1.box_width}}
  box_height 100
  box_fixed true
  name ReformatBox2
  xpos -1140
  ypos -994
 }
 Expression {
  temp_name0 n
  temp_expr0 input.width/8
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 x/width*(1-y/height)
  channel3 alpha
  expr3 1
  name Expression1
  xpos -1140
  ypos -898
 }
set N6fda2e00 [stack 0]
 Dot {
  name Dot8
  xpos -996
  ypos -894
 }
 ColorLookup {
  lut {master {curve L 0 s0 t0.9499999881 C k x0.308139503 1 s0}
    red {}
    green {}
    blue {}
    alpha {}}
  name ColorLookup1
  xpos -1030
  ypos -849
 }
 Dot {
  name Dot14
  xpos -996
  ypos -750
 }
push $N6fda2e00
 Multiply {
  channels rgb
  value 269
  name Multiply5
  label "\[value value]"
  xpos -1140
  ypos -856
 }
 ColorLookup {
  lut {master {}
    red {curve C 1.8783474 1.85965741 1.8410753 1.82260251 1.80424976 1.78602886 1.76794314 1.75000143 1.73221421 1.71458244 1.69711792 1.67982578 1.66271067 1.6457777 1.62903571 1.6124835 1.59613538 1.57998943 1.56404996 1.54832447 1.5328095 1.51751649 1.50244594 1.48759735 1.47297573 1.45858264 1.44442391 1.43049574 1.41680288 1.40334678 1.39012623 1.37714779 1.36440396 1.35190022 1.33963728 1.32761216 1.31582856 1.30428183 1.29297352 1.28190565 1.27107596 1.2604804 1.25012183 1.23999798 1.23010659 1.22044563 1.21101499 1.20181489 1.19284034 1.18408906 1.17556167 1.16725397 1.15916491 1.15129638 1.14363372 1.13618886 1.12895167 1.12192106 1.11509454 1.10846853 1.10204577 1.09580922 1.08977199 1.08392429 1.07826447 1.07278681 1.06749392 1.06237841 1.05743873 1.05267084 1.04807138 1.04364109 1.03937256 1.03526449 1.03131545 1.02751946 1.02387333 1.02037668 1.01702523 1.01381445 1.01074362 1.00780725 1.00500631 1.00233305 0.99978602 0.99736285 0.9950608 0.99287677 0.99080539 0.98884678 0.98699367 0.9852494 0.98361033 0.98206747 0.98062134 0.97926998 0.97800934 0.97683728 0.97575116 0.97474778 0.97382426 0.97297859 0.97220623 0.97150886 0.97087657 0.97031689 0.96981871 0.96938527 0.96900952 0.96869147 0.96842706 0.96821606 0.96805781 0.96794283 0.96787858 0.96785843 0.96787864 0.96793604 0.96803701 0.96817231 0.96833968 0.96854311 0.96877253 0.96903455 0.96932232 0.96963543 0.96997368 0.97033387 0.97071254 0.9711163 0.97153723 0.97197378 0.97242606 0.97289121 0.97337079 0.97386622 0.97437072 0.97488332 0.97540969 0.97594237 0.97647977 0.97702706 0.97757769 0.97813445 0.97869468 0.97925854 0.97982538 0.98039114 0.98096472 0.98153675 0.98210776 0.98267955 0.98325121 0.98382008 0.98438704 0.9849571 0.98552132 0.98608243 0.98664182 0.98719966 0.98775077 0.98829895 0.98884273 0.98938417 0.98991877 0.9904511 0.99097681 0.99149919 0.99201453 0.99252397 0.99303031 0.99353105 0.99402624 0.99451613 0.99499857 0.99547589 0.99594522 0.99641174 0.99687338 0.99732745 0.99777603 0.9982177 0.99865389 0.999084 0.99950838 0.99992663 1.00033772 1.00074494 1.00114489 1.00153947 1.00192833 1.00231075 1.00268865 1.00305855 1.00342607 1.00378489 1.00413895 1.00448751 1.00483036 1.00517035 1.00550389 1.00583148 1.00615203 1.00646758 1.00678015 1.00708604 1.00738645 1.00768471 1.00797844 1.0082655 1.00854778 1.00882483 1.00909901 1.00936711 1.00963116 1.00989032 1.0101465 1.01039672 1.01064491 1.01088691 1.0111258 1.01135957 1.01158977 1.01181614 1.01203847 1.01225793 1.01247287 1.01268291 1.01289058 1.01309609 1.01329684 1.01349473 1.0136888 1.0138787 1.01406395 1.01424909 1.01442885 1.01460576 1.01478052 1.01495218 1.01512218 1.01528883 1.01545072 1.01561022 1.01576698 1.01592219 1.01607502 1.01622343 1.01636875 1.0165143 1.01665616 1.01679492 1.0169313 1.01706588 1.01719737 1.01732695 1.01745498 1.01757956 1.01770294 1.01782393 1.01794255 1.0180583 1.01817465 1.01828551 1.01839495 1.01850486 1.01861191 1.01871693 1.01882088 1.01891339}
    green {curve C 1}
    blue {curve C 0.00879261 0.00962762 0.010532 0.01151017 0.01256675 0.01370643 0.01493413 0.01625487 0.01767381 0.01919618 0.02082733 0.02257277 0.02443803 0.02642871 0.02855051 0.03080913 0.0332104 0.0357601 0.03846392 0.04132775 0.04435719 0.04755813 0.05093599 0.05449668 0.0582453 0.0621875 0.06632853 0.07067341 0.07522713 0.07999477 0.08498063 0.09018957 0.09562518 0.10129225 0.10719412 0.11333443 0.11971687 0.12634411 0.133219 0.14034435 0.14772213 0.15535444 0.16324303 0.17138906 0.179794 0.18845794 0.197382 0.20656651 0.21601067 0.22571453 0.23567709 0.24589771 0.25637382 0.26710594 0.2780903 0.28932518 0.30080822 0.3125369 0.32450783 0.33671761 0.34916404 0.36183971 0.37474373 0.38787127 0.40121818 0.41477671 0.42854655 0.44251823 0.45668846 0.47105014 0.48559928 0.50033116 0.5152359 0.5303098 0.5455451 0.56093836 0.5764783 0.59215891 0.60797763 0.62392306 0.63999057 0.65616876 0.6724565 0.68884456 0.70532417 0.72188419 0.73852479 0.7552371 0.77200818 0.78883314 0.80570388 0.82261622 0.83956301 0.8565321 0.87351894 0.89051074 0.90751225 0.92450547 0.94148719 0.95845115 0.97538745 0.99229181 1.00915313 1.02597356 1.04273522 1.05944169 1.07608175 1.09265125 1.10914159 1.12555146 1.14187002 1.15809321 1.1742171 1.190238 1.20614767 1.22194457 1.23762202 1.2531724 1.26859927 1.28389311 1.29905295 1.31407428 1.32895291 1.34368753 1.35827363 1.3727088 1.38699389 1.40111876 1.41508293 1.42889357 1.44254065 1.45602405 1.46934104 1.48249614 1.49548101 1.50830269 1.5209527 1.53343177 1.54574537 1.5578897 1.56985986 1.5816654 1.59329891 1.60476208 1.61605716 1.62718153 1.63813758 1.64892519 1.65955138 1.67000985 1.68030369 1.69043732 1.70040607 1.71021223 1.71985734 1.72934508 1.73867714 1.74785423 1.75688136 1.76575518 1.77447391 1.78304338 1.79146802 1.79975164 1.80788386 1.81587982 1.82373333 1.83144975 1.83902776 1.84647095 1.85378456 1.86096811 1.86802399 1.87495112 1.88175035 1.88842535 1.89497983 1.90141833 1.90774179 1.91394711 1.92004013 1.92602086 1.93188739 1.93765306 1.94330883 1.94886208 1.95430994 1.95965815 1.96490622 1.97005856 1.97511387 1.98007631 1.98494554 1.98972344 1.99441445 1.99901712 2.00353193 2.00796437 2.01231384 2.01658392 2.02076721 2.02487659 2.02890825 2.03286695 2.03675175 2.04056406 2.04430199 2.04797506 2.05157685 2.05511236 2.0585804 2.06198287 2.06532407 2.06860161 2.07181907 2.07497644 2.07807779 2.0811162 2.08409977 2.08702946 2.08990335 2.09272337 2.09549189 2.0982089 2.10087585 2.10349345 2.10606146 2.1085825 2.11105394 2.11348104 2.11586332 2.11820364 2.12050176 2.12275648 2.12496805 2.127141 2.12927723 2.13136625 2.13341999 2.13543844 2.13741732 2.13936305 2.1412704 2.1431427 2.14498401 2.14678812 2.14856291 2.1503005 2.15200949 2.15368938 2.15533352 2.15695238 2.15853977 2.16009951 2.16162968 2.16313291 2.16460824 2.16605687 2.16747928 2.16887903 2.17024994 2.1715951 2.17291784 2.17421341 2.17548871 2.17674041 2.17797112 2.17918396 2.18036819 2.18143296}
    alpha {}}
  name ColorLookup3
  label "Planckian Locus 0-269"
  xpos -1140
  ypos -808
 }
 Multiply {
  inputs 1+1
  channels rgb
  value 0
  maskChannelMask rgba.red
  invert_mask true
  name Multiply3
  label dim
  xpos -1140
  ypos -760
 }
 BlackOutside {
  name BlackOutside6
  xpos -1140
  ypos -706
 }
 Position {
  translate {6 {parent.Position2.translate.y-input.height}}
  name Position8
  xpos -1140
  ypos -682
 }
 Dot {
  name Dot28
  xpos -1106
  ypos -654
 }
push $N7cf37600
 Dot {
  name Dot4
  xpos -886
  ypos -1086
 }
set N6d67cc00 [stack 0]
 Rectangle {
  replace true
  area {0 0 6 {height}}
  name Rectangle1
  xpos -810
  ypos -1089
 }
 BlackOutside {
  name BlackOutside5
  xpos -810
  ypos -1041
 }
push $N6d67cc00
 Radial {
  inputs 1+1
  replace true
  area {-5422 -3542 7470 5590}
  softness 0
  ramp linear
  color {0.0719 0.02604 0.0001 1}
  p1 {0 0}
  color0 {0.039378 0.001097 0.188331 1}
  p0 {0 2048}
  name Radial1
  xpos -920
  ypos -1041
 }
 Dot {
  name Dot9
  xpos -886
  ypos -894
 }
push $N7cf37200
 Gamma {
  channels rgba
  value 0.5
  name Gamma2
  xpos -700
  ypos -1120
 }
 Expression {
  temp_name0 start
  temp_expr0 360
  temp_name1 end
  temp_expr1 830
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 r*(end-start)+start
  channel1 none
  channel2 none
  expr3 1
  name Expression2
  label "360nm to 830nm"
  xpos -700
  ypos -1096
 }
 ColorLookup {
  lut {master {}
    red {curve x360 0.0001299 C 0.00014585 0.0001638 0.000184 0.00020669 0.0002321 0.00026073 0.00029307 0.00032939 0.00036991 0.0004149 0.00046416 0.00051899 0.00058185 0.00065523 0.0007416 0.00084503 0.00096453 0.00109495 0.00123115 0.001368 0.00150205 0.00164233 0.00180238 0.00199576 0.002236 0.00253539 0.0028926 0.00330083 0.00375324 0.004243 0.00476239 0.00533005 0.00597871 0.00674112 0.00765 0.00875137 0.01002888 0.0114217 0.01286901 0.01431 0.01570443 0.01714744 0.01878122 0.02074801 0.02319 0.02620736 0.02978248 0.03388092 0.03846824 0.04351 0.0489956 0.0550226 0.0617188 0.069212 0.07763 0.08695811 0.09717672 0.1084063 0.1207672 0.13438 0.1493582 0.16539571 0.1819831 0.19861101 0.21477 0.23018681 0.24487969 0.25877729 0.27180791 0.28389999 0.29494381 0.3048965 0.31378731 0.32164541 0.3285 0.3343513 0.33921009 0.34312129 0.3461296 0.34828001 0.3495999 0.3501474 0.35001299 0.349287 0.34806001 0.34637329 0.34426239 0.3418088 0.3390941 0.3362 0.33319771 0.33004111 0.32663569 0.32288679 0.31869999 0.3140251 0.30888399 0.3032904 0.2972579 0.29080001 0.28397009 0.27672139 0.2689178 0.26042271 0.2511 0.2408475 0.2298512 0.2184072 0.2068115 0.19536 0.18421359 0.1733273 0.16268811 0.1522833 0.14210001 0.1321786 0.1225696 0.1132752 0.1042979 0.09564 0.08729955 0.07930804 0.07171776 0.06458099 0.05795001 0.05186211 0.04628152 0.04115088 0.03641283 0.03201 0.0279172 0.0241444 0.020687 0.0175404 0.0147 0.01216179 0.00991996 0.00796724 0.00629635 0.0049 0.00377717 0.00294532 0.00242488 0.00223629 0.0024 0.00292552 0.00383656 0.00517484 0.00698208 0.0093 0.01214949 0.01553588 0.01947752 0.02399277 0.0291 0.03481485 0.04112016 0.04798504 0.05537861 0.06327 0.07163501 0.08046224 0.08973996 0.09945645 0.1096 0.1201674 0.1311145 0.1423679 0.15385421 0.1655 0.17725711 0.18914001 0.2011694 0.21336579 0.2257499 0.2383209 0.2510668 0.26399219 0.2771017 0.2904 0.30389121 0.31757259 0.33143839 0.3454828 0.35969999 0.37408391 0.3886396 0.4033784 0.41831151 0.43344989 0.44879529 0.46433601 0.480064 0.49597129 0.51205009 0.52829587 0.54469162 0.56120938 0.57782149 0.59450001 0.6112209 0.62797582 0.64476019 0.66156971 0.67839998 0.69523919 0.7120586 0.72882837 0.7455188 0.76209998 0.77854317 0.79482561 0.81092638 0.82682478 0.84249997 0.85793251 0.87308162 0.88789439 0.90231812 0.9163 0.9297995 0.94279838 0.95527762 0.96721792 0.97860003 0.9893856 0.99954879 1.00908923 1.01800644 1.02629995 1.03398275 1.04098594 1.04718804 1.05246675 1.05669999 1.05979443 1.06179917 1.06280684 1.0629096 1.06219995 1.06073523 1.05844355 1.05522442 1.05097675 1.04560006 1.03903687 1.03136074 1.02266622 1.0130477 1.00259995 0.99136752 0.97933137 0.96649158 0.9528479 0.93839997 0.92319399 0.90724403 0.89050198 0.87291998 0.85444993 0.83508402 0.814946 0.794186 0.77295399 0.75139999 0.72958362 0.70758879 0.68560219 0.66381037 0.64240003 0.62151492 0.6011138 0.58110517 0.56139767 0.54189998 0.52259952 0.50354642 0.4847436 0.46619391 0.4479 0.42986131 0.41209799 0.39464399 0.37753329 0.3608 0.34445629 0.32851681 0.31301919 0.29800111 0.28349999 0.26954481 0.25611839 0.2431896 0.2307272 0.21870001 0.2070971 0.19592319 0.1851708 0.1748323 0.1649 0.1553667 0.14623 0.13749 0.1291467 0.1212 0.1136397 0.106465 0.09969044 0.09333061 0.0874 0.08190096 0.07680428 0.07207712 0.06768664 0.0636 0.05980685 0.05628216 0.05297104 0.04981861 0.04677 0.04378405 0.04087536 0.03807264 0.03540461 0.0329 0.03056419 0.02838056 0.02634484 0.02445275 0.0227 0.02108429 0.01959988 0.01823732 0.01698717 0.01584 0.01479064 0.01383132 0.01294868 0.0121292 0.01135916 0.01062935 0.00993885 0.00928842 0.00867885 0.00811092 0.00758239 0.00708875 0.00662731 0.00619541 0.00579035 0.00540983 0.00505258 0.00471751 0.00440351 0.00410946 0.00383391 0.00357575 0.00333434 0.00310907 0.00289933 0.00270435 0.00252302 0.00235417 0.00219662 0.00204919 0.00191096 0.00178144 0.00166011 0.00154646 0.00143997 0.00134004 0.00124628 0.00115847 0.00107643 0.00099995 0.00092874 0.00086243 0.00080075 0.0007434 0.00069008 0.00064052 0.0005945 0.00055186 0.00051243 0.00047602 0.00044245 0.00041151 0.00038298 0.00035665 0.0003323 0.00030976 0.00028889 0.00026954 0.00025157 0.00023483 0.00021917 0.00020453 0.00019084 0.00017807 0.00016615 0.00015502 0.00014462 0.00013491 0.00012585 0.00011741 0.00010955 0.00010222 9.539e-05 8.902e-05 8.308e-05 7.751e-05 7.231e-05 6.746e-05 6.293e-05 5.871e-05 5.477e-05 5.11e-05 4.768e-05 4.449e-05 4.151e-05 3.873e-05 3.614e-05 3.372e-05 3.146e-05 2.935e-05 2.738e-05 2.552e-05 2.379e-05 2.218e-05 2.067e-05 1.927e-05 1.797e-05 1.675e-05 1.562e-05 1.456e-05 1.357e-05 1.265e-05 1.18e-05 1.1e-05 1.025e-05 9.56e-06 8.91e-06 8.31e-06 7.75e-06 7.22e-06 6.73e-06 6.28e-06 5.85e-06 5.46e-06 5.09e-06 4.74e-06 4.42e-06 4.12e-06 3.84e-06 3.58e-06 3.34e-06 3.11e-06 2.9e-06 2.71e-06 2.52e-06 2.35e-06 2.19e-06 2.04e-06 1.91e-06 1.78e-06 1.66e-06 1.54e-06 1.44e-06 1.34e-06 S 1.25e-06}
    green {curve x360 3.92e-06 C 4.39e-06 4.93e-06 5.53e-06 6.21e-06 6.97e-06 7.81e-06 8.77e-06 9.84e-06 1.104e-05 1.239e-05 1.389e-05 1.556e-05 1.744e-05 1.958e-05 2.202e-05 2.484e-05 2.804e-05 3.153e-05 3.522e-05 3.9e-05 4.283e-05 4.691e-05 5.159e-05 5.718e-05 6.4e-05 7.234e-05 8.221e-05 9.351e-05 0.00010614 0.00012 0.00013498 0.00015149 0.00017021 0.00019182 0.000217 0.00024691 0.00028124 0.00031852 0.00035727 0.000396 0.00043371 0.00047302 0.00051788 0.00057222 0.00064 0.00072456 0.0008255 0.00094116 0.00106988 0.00121 0.00136209 0.00153075 0.00172037 0.00193532 0.00218 0.0024548 0.002764 0.0031178 0.0035264 0.004 0.00454624 0.00515932 0.00582928 0.00654616 0.0073 0.00808651 0.00890872 0.00976768 0.01066443 0.0116 0.01257317 0.01358272 0.01462968 0.01571509 0.01684 0.01800736 0.01921448 0.02045392 0.02171824 0.023 0.02429461 0.02561024 0.02695857 0.02835125 0.0298 0.03131083 0.03288368 0.03452112 0.03622571 0.038 0.03984667 0.041768 0.043766 0.04584267 0.048 0.05024368 0.05257304 0.05498056 0.05745872 0.06 0.06260197 0.06527752 0.06804208 0.07091109 0.0739 0.077016 0.0802664 0.0836668 0.0872328 0.09098 0.09491755 0.09904584 0.1033674 0.1078846 0.1126 0.117532 0.1226744 0.12799279 0.1334528 0.13902 0.1446764 0.1504693 0.15646189 0.1627177 0.1693 0.1762431 0.18355811 0.1912735 0.19941799 0.20802 0.2171199 0.2267345 0.2368571 0.2474812 0.2586 0.2701849 0.28229389 0.2950505 0.30857801 0.32300001 0.33840209 0.35468581 0.37169859 0.3892875 0.4073 0.42562991 0.44430959 0.4633944 0.48293951 0.50300002 0.52356929 0.54451197 0.56568998 0.58696532 0.60820001 0.6293456 0.65030682 0.67087519 0.69084239 0.70999998 0.72818518 0.74546361 0.76196939 0.7778368 0.79320002 0.80811042 0.82249618 0.83630681 0.8494916 0.86199999 0.87381083 0.88496238 0.89549363 0.90544319 0.91485012 0.92373478 0.93209243 0.93992257 0.94722521 0.954 0.9602561 0.96600741 0.97126061 0.97602248 0.98030001 0.98409241 0.98741817 0.99031281 0.99281162 0.99495012 0.99671078 0.99809831 0.99911201 0.99974817 1 0.99985671 0.99930459 0.99832553 0.99689871 0.995 0.9926005 0.98974258 0.98644441 0.98272407 0.97860003 0.97408372 0.96917123 0.96385682 0.95813489 0.95200002 0.94545043 0.93849921 0.93116277 0.92345762 0.91540003 0.90700638 0.89827722 0.8892048 0.8797816 0.87 0.85986131 0.849392 0.83862197 0.82758129 0.81629997 0.80479473 0.793082 0.781192 0.76915473 0.75700003 0.74475408 0.73242241 0.7200036 0.70749652 0.69489998 0.68221921 0.66947162 0.65667439 0.64384478 0.63099998 0.61815548 0.60531437 0.59247559 0.57963789 0.5668 0.5539611 0.54113722 0.5283528 0.51563227 0.50300002 0.4904688 0.47803041 0.46567759 0.4534032 0.44119999 0.42908001 0.417036 0.40503201 0.39303201 0.38100001 0.36891839 0.3568272 0.34477681 0.33281761 0.32100001 0.30933809 0.2978504 0.28659359 0.27562451 0.26499999 0.25476319 0.2448896 0.2353344 0.22605281 0.21699999 0.20816161 0.1995488 0.1911552 0.1829744 0.175 0.1672235 0.15964641 0.1522776 0.1451259 0.1382 0.1315003 0.1250248 0.1187792 0.1127691 0.107 0.1014762 0.09618864 0.09112296 0.08626485 0.0816 0.07712064 0.07282552 0.06871008 0.06476976 0.061 0.05739621 0.05395504 0.05067376 0.04754965 0.04458 0.04175872 0.03908496 0.03656384 0.03420048 0.032 0.02996261 0.02807664 0.02632936 0.02470805 0.0232 0.02180077 0.02050112 0.01928108 0.01812069 0.017 0.01590379 0.01483718 0.01381068 0.01283478 0.01192 0.01106831 0.01027339 0.00953331 0.00884616 0.00821 0.00762378 0.00708542 0.00659148 0.00613848 0.005723 0.00534306 0.0049958 0.0046764 0.00438007 0.004102 0.00383845 0.0035891 0.00335422 0.00313409 0.002929 0.00273814 0.00255988 0.00239324 0.00223728 0.002091 0.00195359 0.00182458 0.00170358 0.00159019 0.001484 0.0013845 0.00129127 0.00120409 0.00112274 0.001047 0.00097659 0.00091111 0.00085013 0.00079324 0.00074 0.00069008 0.00064331 0.0005995 0.00055845 0.00052 0.00048391 0.00045005 0.00041835 0.00038872 0.0003611 0.00033538 0.00031144 0.00028917 0.00026845 0.0002492 0.0002313 0.00021469 0.00019929 0.00018505 0.0001719 0.00015978 0.0001486 0.0001383 0.00012879 0.00012 0.00011186 0.00010432 9.734e-05 9.085e-05 8.48e-05 7.915e-05 7.386e-05 6.892e-05 6.43e-05 6e-05 5.598e-05 5.223e-05 4.872e-05 4.545e-05 4.24e-05 3.956e-05 3.692e-05 3.445e-05 3.215e-05 3e-05 2.799e-05 2.611e-05 2.436e-05 2.272e-05 2.12e-05 1.978e-05 1.845e-05 1.722e-05 1.606e-05 1.499e-05 1.399e-05 1.305e-05 1.218e-05 1.136e-05 1.06e-05 9.89e-06 9.22e-06 8.59e-06 8.01e-06 7.47e-06 6.96e-06 6.49e-06 6.05e-06 5.64e-06 5.26e-06 4.9e-06 4.57e-06 4.26e-06 3.97e-06 3.7e-06 3.45e-06 3.22e-06 3e-06 2.8e-06 2.61e-06 2.43e-06 2.27e-06 2.11e-06 1.97e-06 1.84e-06 1.71e-06 1.6e-06 1.49e-06 1.39e-06 1.29e-06 1.21e-06 1.12e-06 1.05e-06 9.8e-07 9.1e-07 8.5e-07 7.9e-07 7.4e-07 6.9e-07 6.4e-07 6e-07 5.6e-07 5.2e-07 4.8e-07 S 4.5e-07}
    blue {curve x360 0.0006061 C 0.00068088 0.00076515 0.00086001 0.00096659 0.001086 0.00122059 0.00137273 0.00154358 0.00173429 0.001946 0.00217778 0.00243581 0.00273195 0.00307806 0.003486 0.00397523 0.00454088 0.00515832 0.00580291 0.00645 0.00708322 0.00774549 0.00850115 0.00941454 0.01054999 0.0119658 0.01365587 0.01558805 0.01773015 0.02005001 0.02251136 0.02520288 0.02827972 0.03189704 0.03621 0.04143771 0.04750372 0.05411988 0.06099803 0.06785001 0.07448632 0.08136156 0.08915364 0.09854048 0.1102 0.1246133 0.1417017 0.16130351 0.1832568 0.20739999 0.23369209 0.26261139 0.29477459 0.33079851 0.37130001 0.4162091 0.4654642 0.51969481 0.5795303 0.64560002 0.71848381 0.79671329 0.87784588 0.95943898 1.0390501 1.11536729 1.18849707 1.25812328 1.32392955 1.38559997 1.44263518 1.49480355 1.54219031 1.58488071 1.62295997 1.65640485 1.68529594 1.70987451 1.73038209 1.74705994 1.76004458 1.76962328 1.77626371 1.78043342 1.78260004 1.78296816 1.78169978 1.77919817 1.7758671 1.77210998 1.76825893 1.76403904 1.7589438 1.75246632 1.74409997 1.73355949 1.7208581 1.70593691 1.68873715 1.66919994 1.64752865 1.62341273 1.59602225 1.56452799 1.52810001 1.4861114 1.43952155 1.38987994 1.33873618 1.28763998 1.23742235 1.18782425 1.13876104 1.09014797 1.04190004 0.99419761 0.94734728 0.90145308 0.8566193 0.81295007 0.77051729 0.7294448 0.68991357 0.65210491 0.61619997 0.58232862 0.55041617 0.52033758 0.49196729 0.46518001 0.4399246 0.41618359 0.39388219 0.3729459 0.35330001 0.33485779 0.31755209 0.30133751 0.28616861 0.27200001 0.25881711 0.2464838 0.2347718 0.2234533 0.2123 0.20116919 0.19011959 0.1792254 0.1685608 0.1582 0.1481383 0.1383758 0.1289942 0.1200751 0.1117 0.1039048 0.09666748 0.08998272 0.08384531 0.07824999 0.07320899 0.06867816 0.06456784 0.06078835 0.05725001 0.05390435 0.05074664 0.04775276 0.04489859 0.04216 0.03950728 0.03693564 0.03445836 0.03208872 0.02984 0.02771181 0.02569444 0.02378716 0.02198925 0.0203 0.01871805 0.01724036 0.01586364 0.01458461 0.0134 0.01230723 0.01130188 0.01037792 0.00952931 0.00875 0.0080352 0.0073816 0.0067854 0.0062428 0.00575 0.0053036 0.0048998 0.0045342 0.0042024 0.0039 0.0036232 0.0033706 0.0031414 0.0029348 0.00275 0.0025852 0.0024386 0.0023094 0.0021968 0.0021 0.00201773 0.0019482 0.0018898 0.00184093 0.0018 0.00176627 0.0017378 0.0017112 0.00168307 0.00165 0.00161013 0.0015644 0.0015136 0.00145853 0.0014 0.00133667 0.00127 0.001205 0.00114667 0.0011 0.0010688 0.0010494 0.0010356 0.0010212 0.001 0.00096864 0.00092992 0.00088688 0.00084256 0.0008 0.00076096 0.00072368 0.00068592 0.00064544 0.0006 0.00054787 0.0004916 0.0004354 0.00038347 0.00034 0.00030725 0.00028316 0.00026544 0.00025181 0.00024 0.00022955 0.00022064 0.00021196 0.00020219 0.00019 0.00017421 0.00015564 0.00013596 0.00011685 0.0001 8.613e-05 7.46e-05 6.5e-05 5.693e-05 5e-05 4.416e-05 3.948e-05 3.572e-05 3.264e-05 3e-05 2.765e-05 2.556e-05 2.364e-05 2.181e-05 2e-05 1.813e-05 1.62e-05 1.42e-05 1.213e-05 1e-05 7.73e-06 5.4e-06 3.2e-06 1.33e-06 0 0 0 0 0 0 0 0 S 0}
    alpha {}}
  name ColorLookup4
  label "CIE 1931 2 Degree Standard Observer\n360nm to 830nm"
  xpos -700
  ypos -1030
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeLineOfPurples
  xpos -700
  ypos -897
  disable {{!parent.draw_line_of_purples}}
 }
 Fill {
  color {0 0 0 1}
  name Disable_SpectralLocus
  xpos -700
  ypos -826
  disable {{parent.draw_spectral_locus}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergePlanckianLocus
  xpos -700
  ypos -658
  disable {{!parent.draw_planckian_locus}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergePointerGamut
  xpos -700
  ypos -489
  disable {{!parent.draw_pointers_gamut}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergePointerGamut_Samples
  xpos -700
  ypos -417
  disable {{!draw_pointers_samples}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeMacbeth
  xpos -700
  ypos -273
  disable {{!parent.draw_macbeth_chart}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutGrid
  xpos -700
  ypos -81
  disable {{!parent.gamut_grid}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutA
  xpos -700
  ypos 255
  disable {{!parent.gamut_a}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutB
  xpos -700
  ypos 279
  disable {{!parent.gamut_b}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutC
  xpos -700
  ypos 303
  disable {{!parent.gamut_c}}
 }
 Dot {
  name Dot2
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -666
  ypos 450
 }
set N2d14a600 [stack 0]
 Dot {
  name Dot5
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -556
  ypos 450
 }
 Colorspace {
  colorspace_in CIE-XYZ
  primary_in "Adobe (1998)"
  colorspace_out CIE-Yxy
  name Colorspace6
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -590
  ypos 488
 }
 Expression {
  expr0 r
  expr1 "4*g / ( -2*g + 12*b + 3)"
  expr2 "9*b / ( -2*g + 12*b + 3)"
  name Expression5
  label "CIE Yxy to CIELuv"
  xpos -590
  ypos 536
  disable {{!parent.diagram}}
 }
 Dot {
  name Dot11
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -556
  ypos 618
 }
push $N2d14a600
 ColorMatrix {
  matrix {
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
    }
  invert true
  name ColorMatrix1
  label "XYZ to working"
  xpos -700
  ypos 488
  disable {{!map_overlays_to_input_gamut}}
 }
 BlinkScript {
  inputs 2
  KernelDescription "2 \"PlotChromaticity_grid\" iterate pixelWise b2e7b5f8a89bdb0629aa8cc2eae387ef3436f24cb0af642eeba41235874506c4 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 6 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"tolerance\" Float 1 AAAAAA== \"antialias\" Bool 1 AA== \"draw_axes\" Bool 1 AA== \"grid_color\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== 6 \"padding\" 1 1 \"left_margin\" 1 1 \"tolerance\" 1 1 \"antialias\" 1 1 \"draw_axes\" 1 1 \"grid_color\" 4 1 2 \"outsize\" Float 1 1 AAAAAA== \"offset\" Float 1 1 AAAAAA=="
  kernelSource "kernel PlotChromaticity_grid : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float tolerance;\n  bool antialias;\n  bool draw_axes;\n  float4 grid_color;\n\nlocal:\n  float outsize;\n  float offset;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = float(dst.bounds.height()/padding);\n    // xy offset for margin on lower left corner\n    offset = dst.bounds.height()*left_margin;\n  \}\n\n  float gaussian(float d, float a, float expv) \{\n    return max(0.0f, exp(-a*d*d)-expv);\n  \}\n\n  float gaussian_filter(float x, float y, float r) \{\n    // return gaussian weighted distance from origin (0, 0)\n    // given coordinate (x, y) and radius r\n    float a = 1.5f; // rate falloff\n    float expv = exp(-a*r*r);\n    return gaussian(x, a, expv) * gaussian(y, a, expv);\n  \}\n\n  void write_aa(float x, float y, float4 rgb) \{\n    // skip black pixels\n    if (rgb.x == 0.0f && rgb.y == 0.0f && rgb.z == 0.0f) return;\n    \n    // size of pixel neighborhood = n*2+1 by n*2+1\n    int n = 2;\n\n    // center of neighborhood\n    int u0 = round(x);\n    int v0 = round(y);\n\n    // skip if center pixel weight is greater than tolerance\n    if ( dst.bounds.inside(u0, v0)) \{\n      if (dst(u0, v0, 3) >= tolerance) return;\n    \}\n\n    // loop over neighborhood\n    for (int j = -n; j <= n; j++) \{\n      int v = v0 + j;\n      for (int i = -n; i <= n; i++) \{\n        int u = u0 + i;\n        if ( dst.bounds.inside(u, v)) \{\n          // get filter weight for coord (u,v)\n          float w = gaussian_filter(u-x, v-y, float(n));\n          float4 c0 = dst(u, v); // existing color\n\n          // merge current color sample over existing color sample\n          for (int k=0; k<3; k++) \{\n            dst(u, v, k) = rgb\[k]*w+c0\[k]*(1-w); \n          \}\n\n          // merge current weight over existing weight\n          float w0 = dst(u, v, 3);\n          dst(u, v, 3) = w+w0*(1-w);\n        \}\n      \}\n    \}\n  \}\n\n  void draw_grid() \{\n    // grid width in pixels. expresses a 0 to 1 range in CIE xy\n    float grid_width = 1.0f * outsize + offset;\n    // draw grid lines\n    float i = offset;\n    while (i <= grid_width && i > 0.0f) \{\n      write_aa(offset, i, grid_color);\n      write_aa(i, offset, grid_color);\n      i += 1.0;\n    \}\n    // cross-hatching interval in pixels\n    float hatch_interval = (grid_width - offset) * 0.1f;\n    // cross-hatch length in pixels\n    float hatch_width = outsize * 0.01f;\n    i = offset;\n    while (i <= grid_width) \{\n      i += hatch_interval;\n      float j = 0.0;\n      while (j <= hatch_width/2) \{\n        write_aa(offset+j, i, grid_color);\n        write_aa(offset-j, i, grid_color);\n        write_aa(i, offset+j, grid_color);\n        write_aa(i, offset-j, grid_color);\n        j += 1.0;\n      \}\n    \}\n  \}\n\n  void process(int2 pos) \{\n    float4 rgba = col(pos.x, pos.y);\n    \n    // Get CIE xy position from Yxy input for current pixel\n    float2 xy = float2(Yxy(pos.x, pos.y, 1), Yxy(pos.x, pos.y, 2));\n    \n    // Find output pixel coordinate for this CIE xy pixel value\n    float2 out_coord = float2(xy.x * outsize + offset, xy.y * outsize + offset);\n\n    // For each RGB component, write value from color input to output coordinate\n    if (antialias) \{\n      write_aa(out_coord.x, out_coord.y, rgba);\n    \} else \{\n      // For each RGB component, write value from color input to output coordinate\n      int2 p = int2(round(out_coord.x), round(out_coord.y));\n      if (dst.bounds.inside(p.x, p.y)) \{\n        for (int k=0; k<3; k++) \{\n          dst(p.x, p.y, k) = col(pos.x, pos.y, k);\n        \}\n        dst(p.x, p.y, 3) = 1.0f;\n      \}\n    \}\n\n    // draw CIExy coordinate system axes\n    if (draw_axes && pos.x == 0 && pos.y == 0) \{\n      draw_grid();\n    \}\n  \}\n\};"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  PlotChromaticity_grid_padding {{parent.PlotChromaticities.PlotChromaticity_padding}}
  PlotChromaticity_grid_left_margin {{parent.PlotChromaticities.PlotChromaticity_left_margin}}
  PlotChromaticity_grid_tolerance 0.8
  PlotChromaticity_grid_antialias true
  PlotChromaticity_grid_draw_axes {{parent.coordinate_system}}
  PlotChromaticity_grid_grid_color {0.15 0 0.005 1}
  format "2048 2048 0 0 2048 2048 1 square_2K"
  rebuild_finalise ""
  name PlotInput2
  xpos -700
  ypos 608
 }
 FrameHold {
  firstFrame 1
  name FrameHold1
  xpos -700
  ypos 680
  cached true
 }
 Dot {
  name Dot3
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -666
  ypos 762
 }
 Input {
  inputs 0
  name Input
  xpos 620
  ypos -1426
 }
 AddChannels {
  name AddChannels1
  xpos 620
  ypos -1360
 }
 Reformat {
  type "to box"
  box_width {{parent.resolution}}
  box_height {{box_width}}
  box_fixed true
  box_pixel_aspect {{input.pixel_aspect}}
  resize distort
  filter impulse
  name OutputFormat
  xpos 620
  ypos -1282
  disable {{!parent.resample_input}}
 }
 Crop {
  box {0 0 {width} {height}}
  crop false
  name CropBBox
  xpos 620
  ypos -1257
 }
 Dot {
  name Dot7
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 654
  ypos 162
 }
set N2d157200 [stack 0]
 Constant {
  inputs 0
  channels rgb
  color {0 0 0 1}
  format "256 256 0 0 256 256 1 square_256"
  name Constant2
  xpos 400
  ypos 38
  postage_stamp false
 }
 Reformat {
  type "to box"
  box_width {{parent.resolution}}
  box_height {{box_width}}
  box_fixed true
  box_pixel_aspect {{input.pixel_aspect}}
  resize distort
  filter impulse
  name OutputFormat1
  xpos 400
  ypos 64
  disable {{!parent.resample_input}}
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input0]"}}
  name Switch1
  xpos 400
  ypos 158
 }
 Fill {
  output rgb
  color 0.18
  name SampleColor
  xpos 290
  ypos 158
 }
 Crop {
  box {0 0 {width} {height}}
  crop false
  name Crop2
  xpos 290
  ypos 184
 }
 Fill {
  output alpha
  name Fill3
  xpos 290
  ypos 224
 }
 Dot {
  name Dot6
  xpos 324
  ypos 282
 }
set N6fda4200 [stack 0]
 ColorMatrix {
  matrix {
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
    }
  name ColorMatrix4
  label "working to XYZ"
  xpos 180
  ypos 272
 }
 Colorspace {
  colorspace_in CIE-XYZ
  primary_in "Adobe (1998)"
  colorspace_out CIE-Yxy
  name Colorspace1
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos 180
  ypos 320
 }
 Expression {
  expr0 r
  expr1 "4*g / ( -2*g + 12*b + 3)"
  expr2 "9*b / ( -2*g + 12*b + 3)"
  name Expression6
  label "CIE Yxy to CIELuv"
  xpos 180
  ypos 368
  disable {{!parent.diagram}}
 }
push $N6fda4200
 BlinkScript {
  inputs 2
  KernelDescription "2 \"PlotChromaticity_sample\" iterate pixelWise 20e14b615a937bac78c1a771cbdfd10cc7c5fb6c487f65d0bb2d6633e404b958 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 3 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"tolerance\" Float 1 AAAAAA== 3 \"padding\" 1 1 \"left_margin\" 1 1 \"tolerance\" 1 1 2 \"outsize\" Float 1 1 AAAAAA== \"offset\" Float 1 1 AAAAAA=="
  kernelSource "kernel PlotChromaticity_sample : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float tolerance;\n\nlocal:\n  float outsize;\n  float offset;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = float(dst.bounds.height()/padding);\n    // xy offset for margin on lower left corner\n    offset = dst.bounds.height()*left_margin;\n  \}\n\n  void process(int2 pos) \{\n    // only process the first pixel\n    if (pos.x > 0 && pos.y > 0) return;\n\n    // Get CIE xy position from Yxy input for current pixel\n    float2 xy = float2(Yxy(pos.x, pos.y, 1), Yxy(pos.x, pos.y, 2));\n    \n    // Find output pixel coordinate for this CIE xy pixel value\n    float2 out_coord = float2(xy.x * outsize + offset, xy.y * outsize + offset);\n\n    // For each RGB component, write value from color input to output coordinate\n    int2 p = int2(round(out_coord.x), round(out_coord.y));\n    if (dst.bounds.inside(p.x, p.y)) \{\n      for (int k=0; k<3; k++) \{\n        dst(p.x, p.y, k) = col(pos.x, pos.y, k);\n      \}\n      dst(p.x, p.y, 3) = 1.0f;\n    \}\n  \}\n\};"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  PlotChromaticity_sample_padding {{"parent.diagram ? parent.right_margin*0.8 : parent.right_margin"}}
  PlotChromaticity_sample_left_margin {{parent.left_margin}}
  PlotChromaticity_sample_tolerance 1
  format "2048 2048 0 0 2048 2048 1 square_2K"
  rebuild_finalise ""
  name PlotChromaticities1
  xpos 290
  ypos 368
 }
 Dot {
  name Dot22
  xpos 324
  ypos 450
 }
set N6fda9000 [stack 0]
 Dilate {
  channels rgba
  size {{Output.width/2048}}
  name Dilate1
  label "\[value size]"
  xpos 290
  ypos 488
 }
set N6fdab000 [stack 0]
 Dilate {
  channels rgba
  size {{Output.width/2048*2}}
  name Dilate2
  label "\[value size]"
  xpos 180
  ypos 488
 }
push $N6fda9000
 Dot {
  name Dot21
  xpos -6
  ypos 450
 }
 FilterErode {
  channels rgba
  size {{-Output.width/2048/5}}
  filter triangle
  name FilterErode1
  label "\[value size]"
  xpos -40
  ypos 489
 }
set N6fdabc00 [stack 0]
 Dilate {
  channels rgba
  size {0 {parent.Dilate3.size.w}}
  name Dilate4
  label "\[value size]"
  xpos -40
  ypos 584
 }
push $N6fdabc00
 Dilate {
  channels rgba
  size {{Output.width*plus_size/100} 0}
  name Dilate3
  label "\[value size]"
  xpos 70
  ypos 488
  addUserKnob {20 User}
  addUserKnob {7 plus_size R 0 4}
  plus_size 0.8
 }
 Merge2 {
  inputs 2
  operation screen
  bbox B
  name Merge9
  xpos 70
  ypos 591
 }
 Merge2 {
  inputs 2
  operation stencil
  bbox B
  name Merge10
  xpos 180
  ypos 591
 }
 Group {
  name HueRotate
  xpos 180
  ypos 639
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -24
  }
  Unpremult {
   name Unpremult1
   xpos -40
   ypos 15
  }
  Colorspace {
   colorspace_out HSV
   name Colorspace1
   xpos -40
   ypos 72
  }
  Add {
   channels {rgba.red -rgba.green -rgba.blue none}
   value 0.5
   name Add1
   xpos -40
   ypos 111
  }
  Fill {
   output {-rgba.red -rgba.green rgba.blue none}
   name Fill1
   xpos -40
   ypos 147
  }
  Colorspace {
   colorspace_in HSV
   name Colorspace2
   xpos -40
   ypos 183
  }
  Premult {
   name Premult1
   xpos -40
   ypos 231
  }
  Output {
   name Output1
   xpos -40
   ypos 302
  }
 end_group
push $N6fdab000
 Merge2 {
  inputs 2
  bbox B
  name Merge8
  xpos 290
  ypos 638
 }
 Dot {
  name Dot20
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 324
  ypos 690
 }
push $N2d157200
 Dot {
  name Dot1
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 764
  ypos 162
 }
 Group {
  name GamutToXYZ
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos 730
  ypos 247
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut P3D65
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Colorspace {
  colorspace_in CIE-XYZ
  primary_in "Adobe (1998)"
  colorspace_out CIE-Yxy
  name Colorspace2
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos 730
  ypos 296
 }
 Expression {
  expr0 r
  expr1 "4*g / ( -2*g + 12*b + 3)"
  expr2 "9*b / ( -2*g + 12*b + 3)"
  name Expression4
  label "CIE Yxy to CIELuv"
  xpos 730
  ypos 344
  disable {{!parent.diagram}}
 }
 Dot {
  name Dot13
  label " Pos"
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 764
  ypos 546
 }
push $N2d157200
 Dot {
  name Dot16
  label " Col"
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 654
  ypos 450
 }
 BlinkScript {
  inputs 2
  KernelDescription "2 \"PlotChromaticity\" iterate pixelWise 3e86399c7642fe5c35c23528a644f88a8bf13f967de084ae6842f8be55098c6b 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 4 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"tolerance\" Float 1 AAAAAA== \"antialias\" Bool 1 AA== 4 \"padding\" 1 1 \"left_margin\" 1 1 \"tolerance\" 1 1 \"antialias\" 1 1 2 \"outsize\" Float 1 1 AAAAAA== \"offset\" Float 1 1 AAAAAA=="
  kernelSource "kernel PlotChromaticity : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float tolerance;\n  bool antialias;\n\nlocal:\n  float outsize;\n  float offset;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = float(dst.bounds.height()/padding);\n    // xy offset for margin on lower left corner\n    offset = dst.bounds.height()*left_margin;\n  \}\n\n  float gaussian(float d, float a, float expv) \{\n    return max(0.0f, exp(-a*d*d)-expv);\n  \}\n\n  float gaussian_filter(float x, float y, float r) \{\n    // return gaussian weighted distance from origin (0, 0)\n    // given coordinate (x, y) and radius r\n    float a = 1.5f; // rate falloff\n    float expv = exp(-a*r*r);\n    return gaussian(x, a, expv) * gaussian(y, a, expv);\n  \}\n\n  void write_aa(float x, float y, float4 rgb) \{\n    // skip black pixels\n    if (rgb.x == 0.0f && rgb.y == 0.0f && rgb.z == 0.0f) return;\n    \n    // size of pixel neighborhood = n*2+1 by n*2+1\n    int n = 2;\n\n    // center of neighborhood\n    int u0 = round(x);\n    int v0 = round(y);\n\n    // skip if center pixel weight is greater than tolerance\n    if ( dst.bounds.inside(u0, v0)) \{\n      if (dst(u0, v0, 3) >= tolerance) return;\n    \}\n\n    // loop over neighborhood\n    for (int j = -n; j <= n; j++) \{\n      int v = v0 + j;\n      for (int i = -n; i <= n; i++) \{\n        int u = u0 + i;\n        if ( dst.bounds.inside(u, v)) \{\n          // get filter weight for coord (u,v)\n          float w = gaussian_filter(u-x, v-y, float(n));\n          float4 c0 = dst(u, v); // existing color\n\n          // merge current color sample over existing color sample\n          for (int k=0; k<3; k++) \{\n            dst(u, v, k) = rgb\[k]*w+c0\[k]*(1-w); \n          \}\n\n          // merge current weight over existing weight\n          float w0 = dst(u, v, 3);\n          dst(u, v, 3) = w+w0*(1-w);\n        \}\n      \}\n    \}\n  \}\n\n\n  void process(int2 pos) \{\n    float4 rgba = col(pos.x, pos.y);\n    \n    // Get CIE xy position from Yxy input for current pixel\n    float2 xy = float2(Yxy(pos.x, pos.y, 1), Yxy(pos.x, pos.y, 2));\n    \n    // Find output pixel coordinate for this CIE xy pixel value\n    float2 out_coord = float2(xy.x * outsize + offset, xy.y * outsize + offset);\n\n    // For each RGB component, write value from color input to output coordinate\n    if (antialias) \{\n      write_aa(out_coord.x, out_coord.y, rgba);\n    \} else \{\n      // For each RGB component, write value from color input to output coordinate\n      int2 p = int2(round(out_coord.x), round(out_coord.y));\n      if (dst.bounds.inside(p.x, p.y)) \{\n        for (int k=0; k<3; k++) \{\n          dst(p.x, p.y, k) = col(pos.x, pos.y, k);\n        \}\n        dst(p.x, p.y, 3) = 1.0f;\n      \}\n    \}\n  \}\n\};"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  PlotChromaticity_padding {{"parent.diagram ? parent.right_margin*0.8 : parent.right_margin"}}
  PlotChromaticity_left_margin {{parent.left_margin}}
  PlotChromaticity_tolerance 2
  PlotChromaticity_antialias true
  format "2048 2048 0 0 2048 2048 1 square_2K"
  rebuild_finalise ""
  name PlotChromaticities
  xpos 620
  ypos 536
  disable {{!parent.plot_input}}
 }
 Fill {
  color 0
  name BLACK
  tile_color 0x111111ff
  xpos 620
  ypos 591
  disable {{parent.plot_input}}
 }
 Merge2 {
  inputs 2
  bbox B
  name Merge7
  xpos 620
  ypos 686
  disable {{!parent.enable_sample_color}}
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 620
  ypos 758
 }
 Output {
  name Output
  xpos 620
  ypos 1046
 }
end_group
Text {
 message P3
 font /Library/Fonts/SF-Compact-Display-Bold.otf
 size 100
 yjustify bottom
 box {15 1.5 877 469}
 center {585 313}
 name Text10
 xpos -877
 ypos 188
}
Constant {
 inputs 0
 channels rgb
 format "256 256 0 0 256 256 1 square_256"
 name Constant1
 xpos -1
 ypos -327
}
Expression {
 expr1 y/height
 name Expression8
 xpos -1
 ypos -255
}
OCIOColorSpace {
 in_colorspace "ACES - ACEScct"
 out_colorspace scene_linear
 name OCIOColorSpace2
 xpos -1
 ypos -231
}
OCIOColorSpace {
 in_colorspace scene_linear
 out_colorspace "ACES - ACES2065-1"
 name OCIOColorSpace1
 xpos -1
 ypos -204
}
Read {
 inputs 0
 file_type exr
 file /Users/afry/Downloads/arri_submission_2022/arribar_aces20651_overlay.exr
 format "4608 3164 0 0 4608 3164 1 "
 origset true
 name Read2
 xpos -581
 ypos -320
}
push $N2d589e00
Group {
 name PlotChromaticity2
 xpos -1305
 ypos -114
 addUserKnob {20 PlotChromaticity_tab l PlotChromaticity}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
 addUserKnob {6 plot_input l "plot input" t "Enable plotting of the input pixels" +STARTLINE}
 plot_input true
 addUserKnob {41 input_gamut l gamut t "Set the gamut that the input colors are encoded in" -STARTLINE T GamutToXYZ.gamut}
 addUserKnob {4 diagram l in t "Choose the type of chromaticity diagram: \nCIE 1931 xy Chromaticity Diagram\nCIE 1976 u' v' Uniform Chromaticity Scale Diagram" -STARTLINE M {"CIE 1931 xy" "CIE 1976 u' v'" "" ""}}
 addUserKnob {6 enable_sample_color l "sample color" t "Enable plotting of the sampled color" +STARTLINE}
 enable_sample_color true
 addUserKnob {41 sample_color l color t "sample and plot selected color" T SampleColor.color}
 addUserKnob {22 follow_viewer l "follow viewer" t "Follow the selected viewer node. This causes this node to automatically connect to whatever the followed viewer is connected to.\n\nThis is useful if you want to have a 2nd viewer showing a chromaticity plot for whever you're looking at in your main viewer." T "n = nuke.thisNode()\nnuke.root().begin()\nv = nuke.selectedNode()\nif not v or v.Class() != 'Viewer':\n    nuke.message('Please select a viewer node to follow.')\nelse:\n    v\['knobChanged'].setValue('v = nuke.activeViewer().node()\\nif v and v.name() == nuke.thisNode().name():\\n    con = v.input(nuke.activeViewer().activeInput())\\n    plt = nuke.toNode(\"\{0\}\")\\n    plt.setInput(0, con)'.format(n.name()))" +STARTLINE}
 addUserKnob {22 unfollow_viewer l "unfollow viewer" -STARTLINE T "n = nuke.thisNode()\nnuke.root().begin()\nv = nuke.selectedNode()\nif not v or v.Class() != 'Viewer':\n    nuke.message('Please select a viewer node to unfollow.')\nelse:\n    v\['knobChanged'].setValue('')"}
 addUserKnob {26 plot_dimensions_label l " " T "<b>Chromaticity Diagram"}
 addUserKnob {3 resolution l " resolution" t "resolution to output"}
 resolution 2048
 addUserKnob {7 right_margin l "right margin" R 1 1.5}
 right_margin 1.1
 addUserKnob {7 left_margin l "left margin" R 0 0.2}
 left_margin 0.1
 addUserKnob {6 draw_spectral_locus l "spectrum locus" t "draw the spectrum locus: the boundary of color the human eye can see." +STARTLINE}
 draw_spectral_locus true
 addUserKnob {6 draw_line_of_purples l "line of purples" t "draw the \"line of purples\"" -STARTLINE}
 draw_line_of_purples true
 addUserKnob {6 draw_planckian_locus l "planckian locus" t "Display the planckian locus or the blackbody locus." +STARTLINE}
 draw_planckian_locus true
 addUserKnob {6 gamut_grid l "gamut grid" t "Display a gamut boundary with a grid or dot pattern" +STARTLINE}
 addUserKnob {41 gamut_gamutgrid l "" t "gamut for gamutgrid" -STARTLINE T RGBToXYZ_GamutGrid.gamut}
 addUserKnob {4 gamut_grid_style l style t "Choose the style to display the gamut plot" -STARTLINE M {grid dots "" "" "" ""}}
 addUserKnob {4 distribution l dist t "Which chromaticity space should the overlays be constructed in? \n\nYxy is familiar, but not very perceptually uniform.\n\nu'v' is designed to be more perceptually uniform." -STARTLINE M {"1931 Yxy" "1976 u'v'" "" ""}}
 addUserKnob {7 density t "Density of the grid or points" R 10 100}
 density 50
 addUserKnob {6 gamut_a l "gamut a" t "Display a gamut outline" +STARTLINE}
 gamut_a true
 addUserKnob {41 gamut_a_1 l "" -STARTLINE T RGBToXYZ_GamutA.gamut}
 addUserKnob {6 gamut_b l "gamut b" t "Display a gamut outline" +STARTLINE}
 gamut_b true
 addUserKnob {41 gamut_b_1 l "" -STARTLINE T RGBToXYZ_GamutB.gamut}
 addUserKnob {6 gamut_c l "gamut c" t "Display a gamut outline" +STARTLINE}
 gamut_c true
 addUserKnob {41 gamut_c_1 l "" -STARTLINE T RGBToXYZ_GamutC.gamut}
 addUserKnob {6 draw_pointers_gamut l "pointer's gamut" t "DrawPointer's gamut boundary" +STARTLINE}
 addUserKnob {6 draw_pointers_samples l "pointers sample colors" t "show the individual pointer gamut samples" -STARTLINE}
 addUserKnob {6 draw_macbeth_chart l "macbeth chart" t "draw a ColorChecker24 aka Macbeth Chart" +STARTLINE}
 addUserKnob {6 coordinate_system l "coordinate system" t "Draw CIE xy coordinate grid x and y axes" +STARTLINE}
 coordinate_system true
 addUserKnob {6 map_overlays_to_input_gamut l "map overlays to input gamut" t "This maps the overlays like the spectral locus, pointer's gamut, and the gamut overlay to the working gamut instead of keeping them as XYZ.\n\nFor example if the input gamut is ACEScg, these overlays will be mapped to that. Note that this can cause most of the overlays to be negative or highly saturated which might harm the visual appearance." +STARTLINE}
 map_overlays_to_input_gamut true
}
 Group {
  inputs 0
  name GamutGrid1
  xpos -920
  ypos -201
  postage_stamp true
  addUserKnob {20 GamutGrid}
  addUserKnob {3 style}
  style {{!parent.gamut_grid_style}}
  addUserKnob {3 distribution -STARTLINE}
  distribution {{parent.distribution}}
  addUserKnob {7 density R 10 150}
  density {{parent.density}}
  addUserKnob {26 ""}
  addUserKnob {41 matrix T ColorMatrix.matrix}
  addUserKnob {12 wxy}
  wxy {{parent.RGBToXYZ_GamutGrid.wxy} {parent.RGBToXYZ_GamutGrid.wxy}}
 }
  ColorWheel {
   inputs 0
   format "512 512 0 0 512 512 1 square_512"
   centerSaturation 1
   fillFormat false
   area {-170 -158 682 670}
   name ColorWheel4
   xpos -260
   ypos -15
   postage_stamp false
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop2
   xpos -260
   ypos 27
  }
  Reformat {
   type scale
   scale {{max(parent.density/50,0.25)}}
   resize distort
   filter impulse
   pbb true
   name Reformat3
   xpos -260
   ypos 110
  }
set N2d5a7000 [stack 0]
push $N2d5a7000
  ContactSheet {
   inputs 2
   width {{width*columns}}
   height {{height/pixel_aspect*rows}}
   rows 1
   columns 2
   roworder TopBottom
   name ContactSheet2
   xpos -260
   ypos 169
  }
  Dot {
   name Dot1
   label " "
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -226
   ypos 246
  }
  ColorWheel {
   inputs 0
   format "512 512 0 0 512 512 1 square_512"
   fillFormat false
   area {40 40 472 472}
   name ColorWheel1
   xpos -40
   ypos -664
   postage_stamp false
  }
  Reformat {
   type scale
   scale {{max(parent.density/50,0.25)}}
   resize distort
   filter impulse
   pbb true
   name Reformat1
   xpos -40
   ypos -628
  }
  Crop {
   box {0 0 {width} {height}}
   reformat true
   name Crop1
   xpos -40
   ypos -602
  }
  Unpremult {
   name Unpremult1
   xpos -40
   ypos -526
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos -415
  }
  Colorspace {
   colorspace_in CIE-XYZ
   colorspace_out CIE-Yxy
   name Colorspace1
   label "\[value colorspace_in] -> \[value colorspace_out]"
   xpos -40
   ypos -341
  }
set N2d5c8400 [stack 0]
  Dot {
   name Dot2
   label " "
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -556
   ypos -331
  }
  Expression {
   expr0 r
   expr1 "4*g / ( -2*g + 12*b + 3)"
   expr2 "9*b / ( -2*g + 12*b + 3)"
   name Expression5
   label "CIE Yxy to CIELuv"
   xpos -590
   ypos -304
   disable {{!parent.distribution}}
  }
  Expression {
   expr0 r
   expr1 "(-(degrees(atan2(g-white.x, b-white.y))-180)+270)%360/360"
   expr2 "hypot(g-white.x, b-white.y)"
   expr3 a
   name Expression3
   xpos -590
   ypos -261
   cached true
   addUserKnob {20 User}
   addUserKnob {12 white}
   white {{"parent.distribution ? 4*parent.wxy.x / ( -2 * parent.wxy.x + 12 * parent.wxy.y + 3) : parent.wxy"} {"parent.distribution ? 9*parent.wxy.y / ( -2*parent.wxy.x + 12*parent.wxy.y + 3) : parent.wxy"}}
  }
set N2d5cca00 [stack 0]
  Posterize {
   channels rgb
   Colors {{rint(parent.density/3*2)}}
   name Posterize1
   xpos -590
   ypos -191
  }
set N2d5cce00 [stack 0]
push $N2d5cca00
  Dot {
   name Dot15
   xpos -446
   ypos -257
  }
  Copy {
   inputs 2
   from0 rgba.blue
   to0 rgba.blue
   name Copy1
   xpos -480
   ypos -154
  }
push $N2d5cce00
push $N2d5cca00
  Dot {
   name Dot16
   xpos -666
   ypos -257
  }
  Copy {
   inputs 2
   from0 rgba.green
   to0 rgba.green
   name Copy2
   xpos -700
   ypos -153
  }
  ContactSheet {
   inputs 2
   width {{width*columns}}
   height {{height/pixel_aspect*rows}}
   rows 1
   columns 2
   center true
   roworder TopBottom
   name ContactSheet3
   xpos -590
   ypos -106
  }
  Expression {
   expr0 r
   expr1 cos(radians(g*360))*b+white.x
   expr2 sin(radians(g*360))*b+white.y
   expr3 a
   name Expression19
   xpos -590
   ypos -58
   cached true
   addUserKnob {20 User}
   addUserKnob {12 white}
   white {{parent.Expression3.white} {parent.Expression3.white}}
  }
  Expression {
   expr0 r
   expr1 "9*g / ( 6*g - 16*b + 12)"
   expr2 "4*b/ ( 6*g - 16*b + 12)"
   name Expression2
   label "CIELuv to CIE Yxy"
   xpos -590
   ypos -16
   disable {{!parent.distribution}}
  }
  Colorspace {
   colorspace_in CIE-Yxy
   colorspace_out CIE-XYZ
   name Colorspace2
   label "\[value colorspace_in] -> \[value colorspace_out]"
   xpos -590
   ypos 32
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   invert true
   name ColorMatrix1
   label "XYZ to RGB"
   xpos -590
   ypos 81
  }
  Clamp {
   channels rgba
   maximum_enable false
   name ClampMin2
   xpos -590
   ypos 119
  }
  Clamp {
   channels alpha
   minimum 1
   MinClampTo_enable true
   MaxClampTo_enable true
   name Clamp1
   xpos -590
   ypos 152
  }
  Premult {
   name Premult1
   xpos -590
   ypos 194
  }
  Merge2 {
   inputs 2
   operation under
   bbox B
   name Merge2
   xpos -590
   ypos 242
  }
  Fill {
   output alpha
   name Fill1
   xpos -590
   ypos 297
  }
  Dot {
   name Dot3
   label " GRID"
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -556
   ypos 378
  }
push $N2d5a7000
push $N2d5c8400
  Expression {
   expr0 r
   expr1 "4*g / ( -2*g + 12*b + 3)"
   expr2 "9*b / ( -2*g + 12*b + 3)"
   name Expression4
   label "CIE Yxy to CIELuv"
   xpos -40
   ypos -280
   disable {{!parent.distribution}}
  }
  Expression {
   expr0 r
   expr1 rint(g*Colors)/Colors
   expr2 rint(b*Colors)/Colors
   expr3 a
   name Expression1
   label rint
   xpos -40
   ypos -232
   addUserKnob {20 User}
   addUserKnob {7 Colors R 1 256}
   Colors {{parent.density}}
  }
  Expression {
   expr0 r
   expr1 "9*g / ( 6*g - 16*b + 12)"
   expr2 "4*b/ ( 6*g - 16*b + 12)"
   name Expression6
   label "CIELuv to CIE Yxy"
   xpos -40
   ypos -184
   disable {{!parent.distribution}}
  }
  Colorspace {
   colorspace_in CIE-Yxy
   colorspace_out CIE-XYZ
   name Colorspace3
   label "\[value colorspace_in] -> \[value colorspace_out]"
   xpos -40
   ypos -112
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   invert true
   name ColorMatrix3
   label "XYZ to RGB"
   xpos -40
   ypos -57
  }
  Clamp {
   channels alpha
   minimum 1
   MinClampTo_enable true
   MaxClampTo_enable true
   name Clamp4
   xpos -40
  }
  Premult {
   name Premult2
   xpos -40
   ypos 55
  }
  Merge2 {
   inputs 2
   operation under
   bbox B
   name Merge1
   xpos -40
   ypos 110
  }
  Clamp {
   channels rgba
   maximum_enable false
   name ClampMin1
   xpos -40
   ypos 273
  }
  Dot {
   name Dot4
   label " DOTS"
   note_font "Helvetica Bold"
   note_font_size 24
   note_font_color 0xa5a5a501
   xpos -6
   ypos 378
  }
  Switch {
   inputs 2
   which {{parent.style}}
   name Switch1
   xpos -257
   ypos 483
  }
  ColorMatrix {
   matrix {
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
       {{parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix} {parent.parent.RGBToXYZ_GamutGrid.ColorMatrix.matrix}}
     }
   name ColorMatrix2
   label "RGB to XYZ"
   xpos -257
   ypos 560
  }
  Output {
   name Output
   xpos -257
   ypos 740
  }
  ColorWheel {
   inputs 0
   format "256 256 0 0 256 256 1 square_256"
   area {40 40 472 472}
   name ColorWheel2
   xpos -37
   ypos -705
   postage_stamp false
  }
 end_group
set N2d5a6200 [stack 0]
 Group {
  name RGBToXYZ_GamutGrid
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -1030
  ypos -184
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut ACEScg
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 ColorWheel {
  inputs 0
  format "512 512 0 0 512 512 1 square_512"
  centerSaturation 1
  fillFormat false
  area {-196 -184 708 696}
  name ColorWheel1
  xpos -920
  ypos 5
 }
 Crop {
  box {0 0 {width} {height}}
  name Crop1
  xpos -920
  ypos 87
 }
 BlackOutside {
  name BlackOutside3
  xpos -920
  ypos 134
 }
set Nd25d6a00 [stack 0]
 Group {
  name RGBToXYZ_GamutC
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -1140
  ypos 176
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" "DaVinci WG" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut Rec709
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.7006223798 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.1487748176 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.101058729 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2741185129 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.8736318946 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 -0.1477504075 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 -0.09896291792 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 -0.1378953159 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 1.325916052 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.313 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.1682 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.9877 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.079 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 -0.1155 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Position {
  translate {{parent.Reformat1.box_width+Rectangle1.area.r+input.width} {parent.ReformatBox4.box_width-input.height}}
  name Position6
  xpos -1140
  ypos 254
 }
push $Nd25d6a00
 Group {
  name RGBToXYZ_GamutB
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -1030
  ypos 176
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" "DaVinci WG" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut P3D65
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.7006223798 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.1487748176 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.101058729 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2741185129 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.8736318946 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 -0.1477504075 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 -0.09896291792 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 -0.1378953159 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 1.325916052 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.313 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.1682 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.9877 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.079 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 -0.1155 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Position {
  translate {{parent.Reformat1.box_width+Rectangle1.area.r} {parent.ReformatBox4.box_width-input.height*2}}
  name Position5
  xpos -1030
  ypos 254
 }
push $Nd25d6a00
 Group {
  name RGBToXYZ_GamutA
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos -920
  ypos 176
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" "DaVinci WG" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut ACEScg
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.7006223798 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.1487748176 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.101058729 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2741185129 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.8736318946 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 -0.1477504075 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 -0.09896291792 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 -0.1378953159 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 1.325916052 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.313 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.1682 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.9877 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.079 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 -0.1155 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Position {
  translate {{parent.Reformat1.box_width+Rectangle1.area.r} {parent.ReformatBox4.box_width-input.height}}
  name Position4
  xpos -920
  ypos 254
 }
push $N2d5a6200
 Reformat {
  type scale
  scale 0.8
  turn true
  filter impulse
  black_outside true
  name Reformat2
  xpos -920
  ypos -129
 }
 BlackOutside {
  name BlackOutside2
  xpos -920
  ypos -106
 }
 Position {
  translate {{Rectangle1.area.r} {parent.Position3.translate.y-input.height}}
  name Position2
  xpos -920
  ypos -81
 }
 Group {
  inputs 0
  name ColorChecker24_After_November_2014
  label "CIE XYZ D50"
  xpos -920
  ypos -352
  addUserKnob {20 colorchecker_tab l "ColorChecker24 - After November 2014"}
  addUserKnob {3 patch_resolution}
  patch_resolution 48
 }
  Group {
   inputs 0
   name bluish_green
   selected true
   xpos 622
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.30451114 0.4143554688 0.344352688 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "bluish green"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 6
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 125
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name blue_flower
   xpos 512
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.2419823988 0.2287175998 0.3282104382 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "blue flower"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 5
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name foliage
   xpos 402
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1114392339 0.1346792679 0.05239320311 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob foliage
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 4
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name blue_sky
   xpos 292
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1652470004 0.1785519348 0.2546024121 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "blue sky"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 3
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name light_skin
   xpos 180
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.3811104477 0.336202304 0.1852590702 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "light skin"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 2
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 63
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 135
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name dark_skin
   xpos 70
   ypos -321
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1136398927 0.09832436105 0.047793811 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "dark skin"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 1
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 290
    ypos 63
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 290
    ypos 158
   }
   Output {
    name Output
    xpos 290
    ypos 230
   }
  end_group
  Group {
   inputs 0
   name orange_yellow
   xpos 622
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.4769723742 0.4293377578 0.06005041429 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "orange yellow"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 12
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name yellow_green
   xpos 512
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.3427379502 0.4331759409 0.08330791241 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "yellow green"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 11
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name purple
   xpos 401
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.08353888545 0.06276662955 0.1042075686 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob purple
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 10
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name moderate_red
   xpos 290
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.2915036416 0.188999956 0.09736350318 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "moderate red"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 9
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name purplish_blue
   xpos 180
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1200518326 0.1091090233 0.2874447494 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "purplish blue"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 8
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name orange
   xpos 74
   ypos -201
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.4073691399 0.3126416159 0.05130591012 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob orange
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 7
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name cyan
   xpos 622
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1247966941 0.180609913 0.2913392383 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob cyan
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 18
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name magenta
   xpos 512
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.299122798 0.1895114577 0.2213469194 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob magenta
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 17
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name yellow
   xpos 399
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.5888922356 0.5992976803 0.07077420003 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob yellow
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 16
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 125
   }
   Output {
    name Output
    xpos 262
    ypos 182
   }
  end_group
  Group {
   inputs 0
   name red
   xpos 292
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.2143728424 0.127800835 0.03868150726 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob red
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 15
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name green
   xpos 182
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1413517689 0.2233437582 0.07287461742 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob green
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 14
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name blue
   xpos 72
   ypos -81
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.06809095613 0.05596214063 0.2077405936 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob blue
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 13
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name black_2
   xpos 623
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.03042544265 0.03151319431 0.02656724434 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "black 2 (1.5 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 24
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 125
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_3
   xpos 512
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.08448968042 0.08817234828 0.07391630753 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 3.5 (1.05 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 23
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_5
   xpos 403
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.1835495863 0.1906228754 0.1566717383 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 5 (.70 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 22
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_6
   xpos 292
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.3495921991 0.3648652066 0.3013565492 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 6.5 (.44 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 21
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name neutral_8
   xpos 179
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.5665335579 0.5899709702 0.4828473821 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "neutral 8 (.23 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 20
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  Group {
   inputs 0
   name white_9
   xpos 70
   ypos 39
   postage_stamp true
   addUserKnob {20 sample_Tab l Sample}
   addUserKnob {19 colour_RGBA_Color_Knob l Colour}
   colour_RGBA_Color_Knob {0.8436985288 0.8806903203 0.6936778752 1}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 colour_RGBA_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {1 name_Text_Knob l Name}
   name_Text_Knob "white 9.5 (.05 D)"
   addUserKnob {1 index_Text_Knob l Index}
   index_Text_Knob 19
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {6 label_colour_RGB_Color_Knob_panelDropped_1_1 l "panel dropped state" -STARTLINE +HIDDEN}
   addUserKnob {3 resolution}
   resolution {{parent.patch_resolution}}
  }
   Constant {
    inputs 0
    color {{parent.colour_RGBA_Color_Knob.r} {parent.colour_RGBA_Color_Knob.g} {parent.colour_RGBA_Color_Knob.b} {parent.colour_RGBA_Color_Knob.a}}
    format "512 512 0 0 512 512 1 square_512"
    name Constant
    xpos 262
    ypos 53
   }
   Reformat {
    type "to box"
    box_width {{parent.resolution}}
    box_height {{parent.resolution}}
    box_fixed true
    filter impulse
    black_outside true
    name Reformat1
    xpos 262
    ypos 134
   }
   Output {
    name Output
    xpos 262
    ypos 173
   }
  end_group
  ContactSheet {
   inputs 24
   width {{"rint(parent.patch_resolution * 6 + gap * 7)"}}
   height {{"rint(parent.patch_resolution * 4 + gap * 5)"}}
   rows 4
   columns 6
   startframe 1
   endframe 1
   name ContactSheet
   xpos 620
   ypos 206
  }
  Unpremult {
   name Unpremult1
   xpos 620
   ypos 278
  }
  Output {
   name Output
   xpos 620
   ypos 446
  }
 end_group
 BlackOutside {
  name BlackOutside4
  xpos -920
  ypos -298
 }
 Position {
  translate {{parent.Reformat1.box_width*3+Rectangle1.area.r} {parent.ReformatBox4.box_width-input.height}}
  name Position7
  xpos -920
  ypos -273
 }
 Constant {
  inputs 0
  format "256 256 0 0 256 256 1 square_256"
  name Constant5
  xpos -700
  ypos -1354
  postage_stamp false
 }
 Dot {
  name Dot25
  xpos -666
  ypos -1302
 }
set N2d310c00 [stack 0]
 Dot {
  name Dot27
  xpos -1546
  ypos -1302
 }
 Reformat {
  type "to box"
  box_width {{parent.Reformat1.box_width}}
  box_height 100
  box_fixed true
  name ReformatBox1
  xpos -1580
  ypos -994
 }
 Ramp {
  p0 {0 0}
  p1 {{input.width} 0}
  color {{p1}}
  name Ramp3
  xpos -1580
  ypos -898
 }
 ColorLookup {
  lut {master {}
    red {curve 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.397 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.483 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.569 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.655 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.741 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.828 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914 0.914}
    green {curve 0.433 0.464 0.513 0.611 0.576 0.46 0.426 0.412 0.404 0.397 0.384 0.374 0.346 0.333 0.311 0.287 0.257 0.23 0.21 0.219 0.208 0.211 0.208 0.187 0.191 0.187 0.18 0.164 0.17 0.177 0.175 0.188 0.252 0.325 0.385 0.416 0.433 0.487 0.532 0.588 0.637 0.634 0.549 0.506 0.49 0.458 0.426 0.412 0.397 0.365 0.337 0.301 0.262 0.221 0.192 0.164 0.167 0.162 0.176 0.179 0.148 0.156 0.142 0.148 0.138 0.145 0.145 0.161 0.197 0.256 0.324 0.393 0.451 0.487 0.508 0.538 0.587 0.634 0.659 0.611 0.552 0.526 0.484 0.452 0.428 0.406 0.371 0.334 0.293 0.243 0.204 0.177 0.151 0.151 0.162 0.158 0.161 0.142 0.141 0.129 0.134 0.14 0.156 0.166 0.192 0.221 0.265 0.325 0.392 0.451 0.508 0.48 0.513 0.554 0.597 0.63 0.634 0.58 0.546 0.499 0.466 0.434 0.408 0.372 0.332 0.288 0.242 0.202 0.179 0.16 0.157 0.162 0.157 0.159 0.149 0.153 0.147 0.154 0.164 0.18 0.199 0.226 0.25 0.279 0.325 0.38 0.439 0.48 0.436 0.468 0.502 0.541 0.57 0.605 0.594 0.555 0.511 0.473 0.439 0.409 0.371 0.332 0.288 0.252 0.217 0.196 0.181 0.178 0.185 0.176 0.173 0.168 0.176 0.178 0.19 0.202 0.214 0.235 0.254 0.27 0.291 0.323 0.366 0.41 0.436 0.396 0.414 0.438 0.465 0.485 0.527 0.566 0.557 0.523 0.478 0.442 0.409 0.371 0.334 0.294 0.265 0.244 0.223 0.225 0.212 0.218 0.211 0.211 0.207 0.214 0.217 0.229 0.237 0.244 0.264 0.275 0.285 0.3 0.321 0.348 0.376 0.396 0.357 0.368 0.377 0.391 0.402 0.431 0.481 0.503 0.521 0.482 0.444 0.409 0.372 0.337 0.307 0.286 0.27 0.257 0.247 0.251 0.257 0.255 0.254 0.25 0.258 0.259 0.265 0.269 0.278 0.284 0.292 0.297 0.305 0.317 0.33 0.344 0.357 0.321 0.322 0.328 0.332 0.333 0.346 0.365 0.389 0.411 0.459 0.443 0.399 0.352 0.327 0.313 0.304 0.3 0.294 0.295 0.294 0.293 0.292 0.291 0.295 0.3 0.301 0.302 0.304 0.304 0.304 0.305 0.307 0.309 0.312 0.313 0.316 0.321}
    blue {curve 0.26 0.281 0.298 0.306 0.342 0.365 0.39 0.381 0.392 0.416 0.413 0.43 0.448 0.446 0.433 0.425 0.419 0.394 0.362 0.328 0.305 0.298 0.286 0.247 0.26 0.219 0.199 0.168 0.178 0.14 0.11 0.084 0.104 0.158 0.18 0.225 0.26 0.235 0.26 0.28 0.298 0.327 0.372 0.395 0.417 0.43 0.435 0.455 0.488 0.479 0.521 0.522 0.515 0.49 0.436 0.383 0.331 0.295 0.282 0.258 0.219 0.208 0.179 0.168 0.141 0.129 0.106 0.094 0.095 0.112 0.127 0.165 0.199 0.235 0.226 0.258 0.28 0.298 0.316 0.361 0.399 0.427 0.446 0.461 0.482 0.52 0.521 0.553 0.563 0.573 0.524 0.454 0.389 0.33 0.295 0.266 0.247 0.214 0.195 0.168 0.178 0.142 0.14 0.128 0.129 0.126 0.131 0.144 0.167 0.199 0.226 0.238 0.266 0.289 0.31 0.329 0.351 0.395 0.428 0.453 0.475 0.494 0.533 0.542 0.568 0.584 0.576 0.53 0.451 0.385 0.331 0.299 0.266 0.245 0.22 0.206 0.184 0.174 0.167 0.166 0.166 0.173 0.172 0.165 0.172 0.187 0.208 0.238 0.258 0.28 0.3 0.321 0.343 0.362 0.391 0.427 0.458 0.482 0.503 0.546 0.554 0.573 0.582 0.546 0.499 0.431 0.375 0.33 0.304 0.275 0.254 0.234 0.225 0.212 0.209 0.206 0.203 0.21 0.215 0.212 0.204 0.208 0.214 0.231 0.258 0.277 0.294 0.31 0.328 0.348 0.372 0.397 0.427 0.462 0.487 0.51 0.544 0.558 0.559 0.556 0.503 0.444 0.402 0.355 0.329 0.309 0.289 0.275 0.26 0.254 0.245 0.245 0.241 0.238 0.249 0.249 0.245 0.241 0.242 0.246 0.258 0.277 0.295 0.305 0.315 0.327 0.339 0.359 0.39 0.421 0.461 0.491 0.515 0.54 0.546 0.522 0.478 0.429 0.393 0.368 0.345 0.325 0.313 0.303 0.295 0.286 0.284 0.279 0.277 0.274 0.277 0.277 0.28 0.276 0.273 0.274 0.279 0.285 0.295 0.311 0.314 0.316 0.32 0.323 0.331 0.346 0.367 0.397 0.468 0.513 0.494 0.425 0.388 0.372 0.348 0.336 0.331 0.326 0.32 0.316 0.314 0.312 0.309 0.321 0.32 0.319 0.305 0.317 0.316 0.316 0.315 0.316 0.317 0.319 0.321 0.311}
    alpha {}}
  name ColorLookup7
  label "Pointers Samples Yxy\nSource: https://www.rit.edu/cos/colorscience/rc_useful_data.php"
  xpos -1580
  ypos -790
 }
 Colorspace {
  colorspace_in CIE-Yxy
  primary_in "Adobe (1998)"
  colorspace_out CIE-XYZ
  name Colorspace12
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -1580
  ypos -688
 }
 Fill {
  output alpha
  name Fill5
  xpos -1580
  ypos -639
 }
 BlackOutside {
  name BlackOutside7
  xpos -1580
  ypos -562
 }
 Position {
  translate {6 {parent.Position1.translate.y-input.height}}
  name Position3
  xpos -1580
  ypos -538
 }
 Dot {
  name Dot15
  xpos -1546
  ypos -414
 }
push $N2d310c00
 Reformat {
  type "to box"
  box_width 2048
  box_height 2048
  box_fixed true
  name ReformatBox4
  xpos -700
  ypos -1258
 }
 Expression {
  temp_name0 n
  temp_expr0 input.width/8
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 x/width*(1-y/height)
  channel3 alpha
  expr3 1
  name Expression7
  xpos -700
  ypos -1209
 }
 Dot {
  name Dot10
  xpos -666
  ypos -1158
 }
set N2f5b4c00 [stack 0]
 Dot {
  name Dot26
  xpos -886
  ypos -1158
 }
set N2f5b5000 [stack 0]
 Dot {
  name Dot23
  xpos -1106
  ypos -1158
 }
set N2f5b5400 [stack 0]
 Dot {
  name Dot12
  xpos -1326
  ypos -1158
 }
 Mirror2 {
  flip true
  flop true
  name Mirror2_1
  xpos -1360
  ypos -1042
 }
 Reformat {
  type "to box"
  box_width 512
  box_height {{box_width}}
  box_fixed true
  name Reformat1
  xpos -1360
  ypos -994
 }
 Gamma {
  channels rgb
  value 2
  name Gamma1
  xpos -1360
  ypos -898
 }
 Multiply {
  channels rgb
  value 8000
  name Multiply1
  label "\[value value]"
  xpos -1360
  ypos -811
 }
 ColorLookup {
  lut {master {}
    red {curve R 0.4830000103 x50 0.5045000315 0.5260000229 0.5475000143 0.5690000057 0.5904999971 0.6119999886 0.63349998 0.6549999714 0.6805312037 0.7087500095 0.7315937281 0.7409999967 0.7409999967 0.7409999967 0.7409999967 0.7409999967 0.75459373 0.7845000029 0.8144062757 0.8280000091 0.8280000091 0.8280000091 0.8280000091 0.8280000091 0.8009687662 0.74150002 0.6820312142 0.6549999714 0.6684374809 0.6980000138 0.7275624871 0.7409999967 0.7315937281 0.7087500095 0.6805312037 0.6549999714 0.629468739 0.6012499928 0.5784062743 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5555624962 0.5260000229 0.4964375198 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4964375198 0.5260000229 0.5555624962 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5690000057 0.5653046966 0.5555624962 0.5417890549 0.5260000229 0.5102109313 0.4964375198 0.4866953194 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4695625007 0.4400000274 0.4104375243 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.3970000148 0.4104375243 0.4400000274 0.4695625007 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103 0.4830000103}
    green {curve R 0.6589999795 x50 0.6542205811 0.6484853029 0.6414804459 0.6340000033 0.6249843836 0.6147499681 0.6041406393 0.5939999819 0.5844687223 0.575124979 0.5659687519 0.5569999814 0.5484530926 0.5402500033 0.5319218636 0.5230000019 0.5131718516 0.5027499795 0.4922031164 0.4819999933 0.4722187519 0.4626249969 0.4532187581 0.4440000057 0.4351093769 0.4265000224 0.4178906381 0.4090000093 0.3997343779 0.3902499974 0.380640626 0.3709999919 0.3614374995 0.3518749774 0.3421249986 0.3319999874 0.321398437 0.3104375005 0.2992577851 0.2879999876 0.2764999866 0.2647500038 0.2531249821 0.2419999987 0.2312265635 0.2206875086 0.2108047009 0.202000007 0.1947187632 0.1886250079 0.1829687506 0.1770000011 0.1693515629 0.1608124971 0.1538671851 0.1509999931 0.1509999931 0.1509999931 0.1509999931 0.1509999931 0.1527187377 0.1564999968 0.1602812558 0.1620000005 0.1620000005 0.1620000005 0.1620000005 0.1620000005 0.1612187475 0.1595000029 0.1577812582 0.1570000052 0.1573124975 0.1579999924 0.1586875021 0.1589999944 0.1575781256 0.1543750018 0.1509843767 0.1490000039 0.1485625058 0.1484999955 0.1484375 0.1480000019 0.1467812508 0.1449999958 0.1432187557 0.1420000046 0.1415625066 0.1414999962 0.1414375007 0.1410000026 0.1397656202 0.1378750056 0.1357968748 0.1340000033 0.1323750019 0.1307500005 0.1295000017 0.1289999932 0.130031243 0.1324999928 0.1354687512 0.1379999965 0.1402187496 0.1424999982 0.1442812532 0.1449999958 0.1449999958 0.1449999958 0.1449999958 0.1449999958 0.1464921832 0.1503124982 0.1554765552 0.1609999985 0.1673984379 0.1749375015 0.1822578013 0.1879999936 0.1906718612 0.1913749874 0.1926406175 0.1969999969 0.2064140588 0.2199375033 0.2357421964 0.2520000041 0.2688750029 0.2871249914 0.3058125079 0.324000001 0.3417187631 0.359375 0.3765937686 0.3930000067 0.4082968831 0.4227499962 0.4368281364 0.451000005 0.4659531415 0.4812500179 0.4956718981 0.5080000162 0.5169296861 0.5234375 0.5297265649 0.5379999876 0.5491171479 0.5618124604 0.5751015544 0.5879999995 0.6009531021 0.6142500043 0.6266719103 0.6370000243 0.6457066536 0.6532088518 0.6575522423 0.6589999795}
    blue {curve R 0.3160000145 x50 0.324739933 0.3330312669 0.3418398499 0.351000011 0.3607422113 0.3709374964 0.3811640739 0.3910000026 0.4003046751 0.4093124866 0.4181640446 0.4269999862 0.4359609187 0.4449374974 0.453695327 0.4620000124 0.4697890878 0.4771875143 0.4842422009 0.4909999967 0.4971874952 0.5028749704 0.5086249709 0.5149999857 0.5227031112 0.53125 0.5394218564 0.5460000038 0.5502656102 0.5530000329 0.5552343726 0.5580000281 0.561632812 0.5655625463 0.5694609284 0.5730000138 0.5765469074 0.5801249743 0.5828906298 0.5839999914 0.5838750005 0.5830000043 0.5806249976 0.5759999752 0.5682968497 0.5576249957 0.5446406007 0.5299999714 0.5128515363 0.4931874871 0.4729296863 0.4539999962 0.4368359447 0.420437485 0.4045703113 0.3889999986 0.3731718659 0.3573749959 0.3426406384 0.3300000131 0.3193906248 0.310375005 0.3034218848 0.298999995 0.2972500026 0.2969999909 0.2967499793 0.2949999869 0.2899531126 0.2821249962 0.2734843791 0.2660000026 0.2602812648 0.2552500069 0.2503437698 0.2450000048 0.2380000055 0.2300000042 0.2232500017 0.2199999988 0.2195625007 0.2194999903 0.2194374949 0.2189999968 0.2183593661 0.2176249921 0.2163281292 0.2140000015 0.2101874948 0.205249995 0.1999374926 0.1949999928 0.1904453039 0.185937494 0.1817109436 0.1780000031 0.1754062474 0.1736250073 0.1715312451 0.1679999977 0.1620937437 0.1546249986 0.147093758 0.1410000026 0.1372031271 0.1347499937 0.1324218661 0.1289999932 0.1237656176 0.1174999923 0.1112343743 0.1059999987 0.1021796837 0.09918750077 0.09660156071 0.09399999678 0.09089062363 0.0876249969 0.0850468725 0.08399999887 0.08524999768 0.0882499963 0.09187500179 0.09499999881 0.09706249833 0.09875000268 0.1008125022 0.1040000021 0.1084140688 0.1136875004 0.1198671907 0.1270000041 0.1355390698 0.145312503 0.1554296911 0.1650000066 0.1739453226 0.1826875061 0.1910859346 0.199000001 0.2061250061 0.2126249969 0.2190624923 0.2259999961 0.2338827997 0.2423124909 0.2505859137 0.2579999864 0.2642968595 0.26987499 0.2750156224 0.2800000012 0.2847812474 0.2892500162 0.2935937643 0.2980000079 0.3025000095 0.3070000112 0.3115000129 0.3160000145}
    alpha {}}
  name ColorLookup5
  label "Pointer's Gamut Boundary Yxy\ninterpolated: incr 50 - 0 to 8000"
  xpos -1360
  ypos -775
 }
 Multiply {
  channels rgb
  value {0.31 1 1 1}
  name Multiply2
  label "dim boundary"
  xpos -1360
  ypos -725
 }
 Colorspace {
  colorspace_in CIE-Yxy
  primary_in "Adobe (1998)"
  colorspace_out CIE-XYZ
  name Colorspace5
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -1360
  ypos -688
 }
 Fill {
  output alpha
  name Fill4
  xpos -1360
  ypos -639
 }
 BlackOutside {
  name BlackOutside1
  xpos -1360
  ypos -562
 }
 Position {
  translate {6 {ReformatBox4.box_width-input.width}}
  name Position1
  xpos -1360
  ypos -538
 }
 Dot {
  name Dot24
  xpos -1326
  ypos -486
 }
push $N2f5b5400
 Reformat {
  type "to box"
  box_width {{parent.Reformat1.box_width}}
  box_height 100
  box_fixed true
  name ReformatBox2
  xpos -1140
  ypos -994
 }
 Expression {
  temp_name0 n
  temp_expr0 input.width/8
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 x/width*(1-y/height)
  channel3 alpha
  expr3 1
  name Expression1
  xpos -1140
  ypos -898
 }
set N9ed5e400 [stack 0]
 Dot {
  name Dot8
  xpos -996
  ypos -894
 }
 ColorLookup {
  lut {master {curve L 0 s0 t0.9499999881 C k x0.308139503 1 s0}
    red {}
    green {}
    blue {}
    alpha {}}
  name ColorLookup1
  xpos -1030
  ypos -849
 }
 Dot {
  name Dot14
  xpos -996
  ypos -750
 }
push $N9ed5e400
 Multiply {
  channels rgb
  value 269
  name Multiply5
  label "\[value value]"
  xpos -1140
  ypos -856
 }
 ColorLookup {
  lut {master {}
    red {curve C 1.8783474 1.85965741 1.8410753 1.82260251 1.80424976 1.78602886 1.76794314 1.75000143 1.73221421 1.71458244 1.69711792 1.67982578 1.66271067 1.6457777 1.62903571 1.6124835 1.59613538 1.57998943 1.56404996 1.54832447 1.5328095 1.51751649 1.50244594 1.48759735 1.47297573 1.45858264 1.44442391 1.43049574 1.41680288 1.40334678 1.39012623 1.37714779 1.36440396 1.35190022 1.33963728 1.32761216 1.31582856 1.30428183 1.29297352 1.28190565 1.27107596 1.2604804 1.25012183 1.23999798 1.23010659 1.22044563 1.21101499 1.20181489 1.19284034 1.18408906 1.17556167 1.16725397 1.15916491 1.15129638 1.14363372 1.13618886 1.12895167 1.12192106 1.11509454 1.10846853 1.10204577 1.09580922 1.08977199 1.08392429 1.07826447 1.07278681 1.06749392 1.06237841 1.05743873 1.05267084 1.04807138 1.04364109 1.03937256 1.03526449 1.03131545 1.02751946 1.02387333 1.02037668 1.01702523 1.01381445 1.01074362 1.00780725 1.00500631 1.00233305 0.99978602 0.99736285 0.9950608 0.99287677 0.99080539 0.98884678 0.98699367 0.9852494 0.98361033 0.98206747 0.98062134 0.97926998 0.97800934 0.97683728 0.97575116 0.97474778 0.97382426 0.97297859 0.97220623 0.97150886 0.97087657 0.97031689 0.96981871 0.96938527 0.96900952 0.96869147 0.96842706 0.96821606 0.96805781 0.96794283 0.96787858 0.96785843 0.96787864 0.96793604 0.96803701 0.96817231 0.96833968 0.96854311 0.96877253 0.96903455 0.96932232 0.96963543 0.96997368 0.97033387 0.97071254 0.9711163 0.97153723 0.97197378 0.97242606 0.97289121 0.97337079 0.97386622 0.97437072 0.97488332 0.97540969 0.97594237 0.97647977 0.97702706 0.97757769 0.97813445 0.97869468 0.97925854 0.97982538 0.98039114 0.98096472 0.98153675 0.98210776 0.98267955 0.98325121 0.98382008 0.98438704 0.9849571 0.98552132 0.98608243 0.98664182 0.98719966 0.98775077 0.98829895 0.98884273 0.98938417 0.98991877 0.9904511 0.99097681 0.99149919 0.99201453 0.99252397 0.99303031 0.99353105 0.99402624 0.99451613 0.99499857 0.99547589 0.99594522 0.99641174 0.99687338 0.99732745 0.99777603 0.9982177 0.99865389 0.999084 0.99950838 0.99992663 1.00033772 1.00074494 1.00114489 1.00153947 1.00192833 1.00231075 1.00268865 1.00305855 1.00342607 1.00378489 1.00413895 1.00448751 1.00483036 1.00517035 1.00550389 1.00583148 1.00615203 1.00646758 1.00678015 1.00708604 1.00738645 1.00768471 1.00797844 1.0082655 1.00854778 1.00882483 1.00909901 1.00936711 1.00963116 1.00989032 1.0101465 1.01039672 1.01064491 1.01088691 1.0111258 1.01135957 1.01158977 1.01181614 1.01203847 1.01225793 1.01247287 1.01268291 1.01289058 1.01309609 1.01329684 1.01349473 1.0136888 1.0138787 1.01406395 1.01424909 1.01442885 1.01460576 1.01478052 1.01495218 1.01512218 1.01528883 1.01545072 1.01561022 1.01576698 1.01592219 1.01607502 1.01622343 1.01636875 1.0165143 1.01665616 1.01679492 1.0169313 1.01706588 1.01719737 1.01732695 1.01745498 1.01757956 1.01770294 1.01782393 1.01794255 1.0180583 1.01817465 1.01828551 1.01839495 1.01850486 1.01861191 1.01871693 1.01882088 1.01891339}
    green {curve C 1}
    blue {curve C 0.00879261 0.00962762 0.010532 0.01151017 0.01256675 0.01370643 0.01493413 0.01625487 0.01767381 0.01919618 0.02082733 0.02257277 0.02443803 0.02642871 0.02855051 0.03080913 0.0332104 0.0357601 0.03846392 0.04132775 0.04435719 0.04755813 0.05093599 0.05449668 0.0582453 0.0621875 0.06632853 0.07067341 0.07522713 0.07999477 0.08498063 0.09018957 0.09562518 0.10129225 0.10719412 0.11333443 0.11971687 0.12634411 0.133219 0.14034435 0.14772213 0.15535444 0.16324303 0.17138906 0.179794 0.18845794 0.197382 0.20656651 0.21601067 0.22571453 0.23567709 0.24589771 0.25637382 0.26710594 0.2780903 0.28932518 0.30080822 0.3125369 0.32450783 0.33671761 0.34916404 0.36183971 0.37474373 0.38787127 0.40121818 0.41477671 0.42854655 0.44251823 0.45668846 0.47105014 0.48559928 0.50033116 0.5152359 0.5303098 0.5455451 0.56093836 0.5764783 0.59215891 0.60797763 0.62392306 0.63999057 0.65616876 0.6724565 0.68884456 0.70532417 0.72188419 0.73852479 0.7552371 0.77200818 0.78883314 0.80570388 0.82261622 0.83956301 0.8565321 0.87351894 0.89051074 0.90751225 0.92450547 0.94148719 0.95845115 0.97538745 0.99229181 1.00915313 1.02597356 1.04273522 1.05944169 1.07608175 1.09265125 1.10914159 1.12555146 1.14187002 1.15809321 1.1742171 1.190238 1.20614767 1.22194457 1.23762202 1.2531724 1.26859927 1.28389311 1.29905295 1.31407428 1.32895291 1.34368753 1.35827363 1.3727088 1.38699389 1.40111876 1.41508293 1.42889357 1.44254065 1.45602405 1.46934104 1.48249614 1.49548101 1.50830269 1.5209527 1.53343177 1.54574537 1.5578897 1.56985986 1.5816654 1.59329891 1.60476208 1.61605716 1.62718153 1.63813758 1.64892519 1.65955138 1.67000985 1.68030369 1.69043732 1.70040607 1.71021223 1.71985734 1.72934508 1.73867714 1.74785423 1.75688136 1.76575518 1.77447391 1.78304338 1.79146802 1.79975164 1.80788386 1.81587982 1.82373333 1.83144975 1.83902776 1.84647095 1.85378456 1.86096811 1.86802399 1.87495112 1.88175035 1.88842535 1.89497983 1.90141833 1.90774179 1.91394711 1.92004013 1.92602086 1.93188739 1.93765306 1.94330883 1.94886208 1.95430994 1.95965815 1.96490622 1.97005856 1.97511387 1.98007631 1.98494554 1.98972344 1.99441445 1.99901712 2.00353193 2.00796437 2.01231384 2.01658392 2.02076721 2.02487659 2.02890825 2.03286695 2.03675175 2.04056406 2.04430199 2.04797506 2.05157685 2.05511236 2.0585804 2.06198287 2.06532407 2.06860161 2.07181907 2.07497644 2.07807779 2.0811162 2.08409977 2.08702946 2.08990335 2.09272337 2.09549189 2.0982089 2.10087585 2.10349345 2.10606146 2.1085825 2.11105394 2.11348104 2.11586332 2.11820364 2.12050176 2.12275648 2.12496805 2.127141 2.12927723 2.13136625 2.13341999 2.13543844 2.13741732 2.13936305 2.1412704 2.1431427 2.14498401 2.14678812 2.14856291 2.1503005 2.15200949 2.15368938 2.15533352 2.15695238 2.15853977 2.16009951 2.16162968 2.16313291 2.16460824 2.16605687 2.16747928 2.16887903 2.17024994 2.1715951 2.17291784 2.17421341 2.17548871 2.17674041 2.17797112 2.17918396 2.18036819 2.18143296}
    alpha {}}
  name ColorLookup3
  label "Planckian Locus 0-269"
  xpos -1140
  ypos -808
 }
 Multiply {
  inputs 1+1
  channels rgb
  value 0
  maskChannelMask rgba.red
  invert_mask true
  name Multiply3
  label dim
  xpos -1140
  ypos -760
 }
 BlackOutside {
  name BlackOutside6
  xpos -1140
  ypos -706
 }
 Position {
  translate {6 {parent.Position2.translate.y-input.height}}
  name Position8
  xpos -1140
  ypos -682
 }
 Dot {
  name Dot28
  xpos -1106
  ypos -654
 }
push $N2f5b5000
 Dot {
  name Dot4
  xpos -886
  ypos -1086
 }
set N2f5bde00 [stack 0]
 Rectangle {
  replace true
  area {0 0 6 {height}}
  name Rectangle1
  xpos -810
  ypos -1089
 }
 BlackOutside {
  name BlackOutside5
  xpos -810
  ypos -1041
 }
push $N2f5bde00
 Radial {
  inputs 1+1
  replace true
  area {-5422 -3542 7470 5590}
  softness 0
  ramp linear
  color {0.0719 0.02604 0.0001 1}
  p1 {0 0}
  color0 {0.039378 0.001097 0.188331 1}
  p0 {0 2048}
  name Radial1
  xpos -920
  ypos -1041
 }
 Dot {
  name Dot9
  xpos -886
  ypos -894
 }
push $N2f5b4c00
 Gamma {
  channels rgba
  value 0.5
  name Gamma2
  xpos -700
  ypos -1120
 }
 Expression {
  temp_name0 start
  temp_expr0 360
  temp_name1 end
  temp_expr1 830
  channel0 {rgba.red rgba.green rgba.blue none}
  expr0 r*(end-start)+start
  channel1 none
  channel2 none
  expr3 1
  name Expression2
  label "360nm to 830nm"
  xpos -700
  ypos -1096
 }
 ColorLookup {
  lut {master {}
    red {curve x360 0.0001299 C 0.00014585 0.0001638 0.000184 0.00020669 0.0002321 0.00026073 0.00029307 0.00032939 0.00036991 0.0004149 0.00046416 0.00051899 0.00058185 0.00065523 0.0007416 0.00084503 0.00096453 0.00109495 0.00123115 0.001368 0.00150205 0.00164233 0.00180238 0.00199576 0.002236 0.00253539 0.0028926 0.00330083 0.00375324 0.004243 0.00476239 0.00533005 0.00597871 0.00674112 0.00765 0.00875137 0.01002888 0.0114217 0.01286901 0.01431 0.01570443 0.01714744 0.01878122 0.02074801 0.02319 0.02620736 0.02978248 0.03388092 0.03846824 0.04351 0.0489956 0.0550226 0.0617188 0.069212 0.07763 0.08695811 0.09717672 0.1084063 0.1207672 0.13438 0.1493582 0.16539571 0.1819831 0.19861101 0.21477 0.23018681 0.24487969 0.25877729 0.27180791 0.28389999 0.29494381 0.3048965 0.31378731 0.32164541 0.3285 0.3343513 0.33921009 0.34312129 0.3461296 0.34828001 0.3495999 0.3501474 0.35001299 0.349287 0.34806001 0.34637329 0.34426239 0.3418088 0.3390941 0.3362 0.33319771 0.33004111 0.32663569 0.32288679 0.31869999 0.3140251 0.30888399 0.3032904 0.2972579 0.29080001 0.28397009 0.27672139 0.2689178 0.26042271 0.2511 0.2408475 0.2298512 0.2184072 0.2068115 0.19536 0.18421359 0.1733273 0.16268811 0.1522833 0.14210001 0.1321786 0.1225696 0.1132752 0.1042979 0.09564 0.08729955 0.07930804 0.07171776 0.06458099 0.05795001 0.05186211 0.04628152 0.04115088 0.03641283 0.03201 0.0279172 0.0241444 0.020687 0.0175404 0.0147 0.01216179 0.00991996 0.00796724 0.00629635 0.0049 0.00377717 0.00294532 0.00242488 0.00223629 0.0024 0.00292552 0.00383656 0.00517484 0.00698208 0.0093 0.01214949 0.01553588 0.01947752 0.02399277 0.0291 0.03481485 0.04112016 0.04798504 0.05537861 0.06327 0.07163501 0.08046224 0.08973996 0.09945645 0.1096 0.1201674 0.1311145 0.1423679 0.15385421 0.1655 0.17725711 0.18914001 0.2011694 0.21336579 0.2257499 0.2383209 0.2510668 0.26399219 0.2771017 0.2904 0.30389121 0.31757259 0.33143839 0.3454828 0.35969999 0.37408391 0.3886396 0.4033784 0.41831151 0.43344989 0.44879529 0.46433601 0.480064 0.49597129 0.51205009 0.52829587 0.54469162 0.56120938 0.57782149 0.59450001 0.6112209 0.62797582 0.64476019 0.66156971 0.67839998 0.69523919 0.7120586 0.72882837 0.7455188 0.76209998 0.77854317 0.79482561 0.81092638 0.82682478 0.84249997 0.85793251 0.87308162 0.88789439 0.90231812 0.9163 0.9297995 0.94279838 0.95527762 0.96721792 0.97860003 0.9893856 0.99954879 1.00908923 1.01800644 1.02629995 1.03398275 1.04098594 1.04718804 1.05246675 1.05669999 1.05979443 1.06179917 1.06280684 1.0629096 1.06219995 1.06073523 1.05844355 1.05522442 1.05097675 1.04560006 1.03903687 1.03136074 1.02266622 1.0130477 1.00259995 0.99136752 0.97933137 0.96649158 0.9528479 0.93839997 0.92319399 0.90724403 0.89050198 0.87291998 0.85444993 0.83508402 0.814946 0.794186 0.77295399 0.75139999 0.72958362 0.70758879 0.68560219 0.66381037 0.64240003 0.62151492 0.6011138 0.58110517 0.56139767 0.54189998 0.52259952 0.50354642 0.4847436 0.46619391 0.4479 0.42986131 0.41209799 0.39464399 0.37753329 0.3608 0.34445629 0.32851681 0.31301919 0.29800111 0.28349999 0.26954481 0.25611839 0.2431896 0.2307272 0.21870001 0.2070971 0.19592319 0.1851708 0.1748323 0.1649 0.1553667 0.14623 0.13749 0.1291467 0.1212 0.1136397 0.106465 0.09969044 0.09333061 0.0874 0.08190096 0.07680428 0.07207712 0.06768664 0.0636 0.05980685 0.05628216 0.05297104 0.04981861 0.04677 0.04378405 0.04087536 0.03807264 0.03540461 0.0329 0.03056419 0.02838056 0.02634484 0.02445275 0.0227 0.02108429 0.01959988 0.01823732 0.01698717 0.01584 0.01479064 0.01383132 0.01294868 0.0121292 0.01135916 0.01062935 0.00993885 0.00928842 0.00867885 0.00811092 0.00758239 0.00708875 0.00662731 0.00619541 0.00579035 0.00540983 0.00505258 0.00471751 0.00440351 0.00410946 0.00383391 0.00357575 0.00333434 0.00310907 0.00289933 0.00270435 0.00252302 0.00235417 0.00219662 0.00204919 0.00191096 0.00178144 0.00166011 0.00154646 0.00143997 0.00134004 0.00124628 0.00115847 0.00107643 0.00099995 0.00092874 0.00086243 0.00080075 0.0007434 0.00069008 0.00064052 0.0005945 0.00055186 0.00051243 0.00047602 0.00044245 0.00041151 0.00038298 0.00035665 0.0003323 0.00030976 0.00028889 0.00026954 0.00025157 0.00023483 0.00021917 0.00020453 0.00019084 0.00017807 0.00016615 0.00015502 0.00014462 0.00013491 0.00012585 0.00011741 0.00010955 0.00010222 9.539e-05 8.902e-05 8.308e-05 7.751e-05 7.231e-05 6.746e-05 6.293e-05 5.871e-05 5.477e-05 5.11e-05 4.768e-05 4.449e-05 4.151e-05 3.873e-05 3.614e-05 3.372e-05 3.146e-05 2.935e-05 2.738e-05 2.552e-05 2.379e-05 2.218e-05 2.067e-05 1.927e-05 1.797e-05 1.675e-05 1.562e-05 1.456e-05 1.357e-05 1.265e-05 1.18e-05 1.1e-05 1.025e-05 9.56e-06 8.91e-06 8.31e-06 7.75e-06 7.22e-06 6.73e-06 6.28e-06 5.85e-06 5.46e-06 5.09e-06 4.74e-06 4.42e-06 4.12e-06 3.84e-06 3.58e-06 3.34e-06 3.11e-06 2.9e-06 2.71e-06 2.52e-06 2.35e-06 2.19e-06 2.04e-06 1.91e-06 1.78e-06 1.66e-06 1.54e-06 1.44e-06 1.34e-06 S 1.25e-06}
    green {curve x360 3.92e-06 C 4.39e-06 4.93e-06 5.53e-06 6.21e-06 6.97e-06 7.81e-06 8.77e-06 9.84e-06 1.104e-05 1.239e-05 1.389e-05 1.556e-05 1.744e-05 1.958e-05 2.202e-05 2.484e-05 2.804e-05 3.153e-05 3.522e-05 3.9e-05 4.283e-05 4.691e-05 5.159e-05 5.718e-05 6.4e-05 7.234e-05 8.221e-05 9.351e-05 0.00010614 0.00012 0.00013498 0.00015149 0.00017021 0.00019182 0.000217 0.00024691 0.00028124 0.00031852 0.00035727 0.000396 0.00043371 0.00047302 0.00051788 0.00057222 0.00064 0.00072456 0.0008255 0.00094116 0.00106988 0.00121 0.00136209 0.00153075 0.00172037 0.00193532 0.00218 0.0024548 0.002764 0.0031178 0.0035264 0.004 0.00454624 0.00515932 0.00582928 0.00654616 0.0073 0.00808651 0.00890872 0.00976768 0.01066443 0.0116 0.01257317 0.01358272 0.01462968 0.01571509 0.01684 0.01800736 0.01921448 0.02045392 0.02171824 0.023 0.02429461 0.02561024 0.02695857 0.02835125 0.0298 0.03131083 0.03288368 0.03452112 0.03622571 0.038 0.03984667 0.041768 0.043766 0.04584267 0.048 0.05024368 0.05257304 0.05498056 0.05745872 0.06 0.06260197 0.06527752 0.06804208 0.07091109 0.0739 0.077016 0.0802664 0.0836668 0.0872328 0.09098 0.09491755 0.09904584 0.1033674 0.1078846 0.1126 0.117532 0.1226744 0.12799279 0.1334528 0.13902 0.1446764 0.1504693 0.15646189 0.1627177 0.1693 0.1762431 0.18355811 0.1912735 0.19941799 0.20802 0.2171199 0.2267345 0.2368571 0.2474812 0.2586 0.2701849 0.28229389 0.2950505 0.30857801 0.32300001 0.33840209 0.35468581 0.37169859 0.3892875 0.4073 0.42562991 0.44430959 0.4633944 0.48293951 0.50300002 0.52356929 0.54451197 0.56568998 0.58696532 0.60820001 0.6293456 0.65030682 0.67087519 0.69084239 0.70999998 0.72818518 0.74546361 0.76196939 0.7778368 0.79320002 0.80811042 0.82249618 0.83630681 0.8494916 0.86199999 0.87381083 0.88496238 0.89549363 0.90544319 0.91485012 0.92373478 0.93209243 0.93992257 0.94722521 0.954 0.9602561 0.96600741 0.97126061 0.97602248 0.98030001 0.98409241 0.98741817 0.99031281 0.99281162 0.99495012 0.99671078 0.99809831 0.99911201 0.99974817 1 0.99985671 0.99930459 0.99832553 0.99689871 0.995 0.9926005 0.98974258 0.98644441 0.98272407 0.97860003 0.97408372 0.96917123 0.96385682 0.95813489 0.95200002 0.94545043 0.93849921 0.93116277 0.92345762 0.91540003 0.90700638 0.89827722 0.8892048 0.8797816 0.87 0.85986131 0.849392 0.83862197 0.82758129 0.81629997 0.80479473 0.793082 0.781192 0.76915473 0.75700003 0.74475408 0.73242241 0.7200036 0.70749652 0.69489998 0.68221921 0.66947162 0.65667439 0.64384478 0.63099998 0.61815548 0.60531437 0.59247559 0.57963789 0.5668 0.5539611 0.54113722 0.5283528 0.51563227 0.50300002 0.4904688 0.47803041 0.46567759 0.4534032 0.44119999 0.42908001 0.417036 0.40503201 0.39303201 0.38100001 0.36891839 0.3568272 0.34477681 0.33281761 0.32100001 0.30933809 0.2978504 0.28659359 0.27562451 0.26499999 0.25476319 0.2448896 0.2353344 0.22605281 0.21699999 0.20816161 0.1995488 0.1911552 0.1829744 0.175 0.1672235 0.15964641 0.1522776 0.1451259 0.1382 0.1315003 0.1250248 0.1187792 0.1127691 0.107 0.1014762 0.09618864 0.09112296 0.08626485 0.0816 0.07712064 0.07282552 0.06871008 0.06476976 0.061 0.05739621 0.05395504 0.05067376 0.04754965 0.04458 0.04175872 0.03908496 0.03656384 0.03420048 0.032 0.02996261 0.02807664 0.02632936 0.02470805 0.0232 0.02180077 0.02050112 0.01928108 0.01812069 0.017 0.01590379 0.01483718 0.01381068 0.01283478 0.01192 0.01106831 0.01027339 0.00953331 0.00884616 0.00821 0.00762378 0.00708542 0.00659148 0.00613848 0.005723 0.00534306 0.0049958 0.0046764 0.00438007 0.004102 0.00383845 0.0035891 0.00335422 0.00313409 0.002929 0.00273814 0.00255988 0.00239324 0.00223728 0.002091 0.00195359 0.00182458 0.00170358 0.00159019 0.001484 0.0013845 0.00129127 0.00120409 0.00112274 0.001047 0.00097659 0.00091111 0.00085013 0.00079324 0.00074 0.00069008 0.00064331 0.0005995 0.00055845 0.00052 0.00048391 0.00045005 0.00041835 0.00038872 0.0003611 0.00033538 0.00031144 0.00028917 0.00026845 0.0002492 0.0002313 0.00021469 0.00019929 0.00018505 0.0001719 0.00015978 0.0001486 0.0001383 0.00012879 0.00012 0.00011186 0.00010432 9.734e-05 9.085e-05 8.48e-05 7.915e-05 7.386e-05 6.892e-05 6.43e-05 6e-05 5.598e-05 5.223e-05 4.872e-05 4.545e-05 4.24e-05 3.956e-05 3.692e-05 3.445e-05 3.215e-05 3e-05 2.799e-05 2.611e-05 2.436e-05 2.272e-05 2.12e-05 1.978e-05 1.845e-05 1.722e-05 1.606e-05 1.499e-05 1.399e-05 1.305e-05 1.218e-05 1.136e-05 1.06e-05 9.89e-06 9.22e-06 8.59e-06 8.01e-06 7.47e-06 6.96e-06 6.49e-06 6.05e-06 5.64e-06 5.26e-06 4.9e-06 4.57e-06 4.26e-06 3.97e-06 3.7e-06 3.45e-06 3.22e-06 3e-06 2.8e-06 2.61e-06 2.43e-06 2.27e-06 2.11e-06 1.97e-06 1.84e-06 1.71e-06 1.6e-06 1.49e-06 1.39e-06 1.29e-06 1.21e-06 1.12e-06 1.05e-06 9.8e-07 9.1e-07 8.5e-07 7.9e-07 7.4e-07 6.9e-07 6.4e-07 6e-07 5.6e-07 5.2e-07 4.8e-07 S 4.5e-07}
    blue {curve x360 0.0006061 C 0.00068088 0.00076515 0.00086001 0.00096659 0.001086 0.00122059 0.00137273 0.00154358 0.00173429 0.001946 0.00217778 0.00243581 0.00273195 0.00307806 0.003486 0.00397523 0.00454088 0.00515832 0.00580291 0.00645 0.00708322 0.00774549 0.00850115 0.00941454 0.01054999 0.0119658 0.01365587 0.01558805 0.01773015 0.02005001 0.02251136 0.02520288 0.02827972 0.03189704 0.03621 0.04143771 0.04750372 0.05411988 0.06099803 0.06785001 0.07448632 0.08136156 0.08915364 0.09854048 0.1102 0.1246133 0.1417017 0.16130351 0.1832568 0.20739999 0.23369209 0.26261139 0.29477459 0.33079851 0.37130001 0.4162091 0.4654642 0.51969481 0.5795303 0.64560002 0.71848381 0.79671329 0.87784588 0.95943898 1.0390501 1.11536729 1.18849707 1.25812328 1.32392955 1.38559997 1.44263518 1.49480355 1.54219031 1.58488071 1.62295997 1.65640485 1.68529594 1.70987451 1.73038209 1.74705994 1.76004458 1.76962328 1.77626371 1.78043342 1.78260004 1.78296816 1.78169978 1.77919817 1.7758671 1.77210998 1.76825893 1.76403904 1.7589438 1.75246632 1.74409997 1.73355949 1.7208581 1.70593691 1.68873715 1.66919994 1.64752865 1.62341273 1.59602225 1.56452799 1.52810001 1.4861114 1.43952155 1.38987994 1.33873618 1.28763998 1.23742235 1.18782425 1.13876104 1.09014797 1.04190004 0.99419761 0.94734728 0.90145308 0.8566193 0.81295007 0.77051729 0.7294448 0.68991357 0.65210491 0.61619997 0.58232862 0.55041617 0.52033758 0.49196729 0.46518001 0.4399246 0.41618359 0.39388219 0.3729459 0.35330001 0.33485779 0.31755209 0.30133751 0.28616861 0.27200001 0.25881711 0.2464838 0.2347718 0.2234533 0.2123 0.20116919 0.19011959 0.1792254 0.1685608 0.1582 0.1481383 0.1383758 0.1289942 0.1200751 0.1117 0.1039048 0.09666748 0.08998272 0.08384531 0.07824999 0.07320899 0.06867816 0.06456784 0.06078835 0.05725001 0.05390435 0.05074664 0.04775276 0.04489859 0.04216 0.03950728 0.03693564 0.03445836 0.03208872 0.02984 0.02771181 0.02569444 0.02378716 0.02198925 0.0203 0.01871805 0.01724036 0.01586364 0.01458461 0.0134 0.01230723 0.01130188 0.01037792 0.00952931 0.00875 0.0080352 0.0073816 0.0067854 0.0062428 0.00575 0.0053036 0.0048998 0.0045342 0.0042024 0.0039 0.0036232 0.0033706 0.0031414 0.0029348 0.00275 0.0025852 0.0024386 0.0023094 0.0021968 0.0021 0.00201773 0.0019482 0.0018898 0.00184093 0.0018 0.00176627 0.0017378 0.0017112 0.00168307 0.00165 0.00161013 0.0015644 0.0015136 0.00145853 0.0014 0.00133667 0.00127 0.001205 0.00114667 0.0011 0.0010688 0.0010494 0.0010356 0.0010212 0.001 0.00096864 0.00092992 0.00088688 0.00084256 0.0008 0.00076096 0.00072368 0.00068592 0.00064544 0.0006 0.00054787 0.0004916 0.0004354 0.00038347 0.00034 0.00030725 0.00028316 0.00026544 0.00025181 0.00024 0.00022955 0.00022064 0.00021196 0.00020219 0.00019 0.00017421 0.00015564 0.00013596 0.00011685 0.0001 8.613e-05 7.46e-05 6.5e-05 5.693e-05 5e-05 4.416e-05 3.948e-05 3.572e-05 3.264e-05 3e-05 2.765e-05 2.556e-05 2.364e-05 2.181e-05 2e-05 1.813e-05 1.62e-05 1.42e-05 1.213e-05 1e-05 7.73e-06 5.4e-06 3.2e-06 1.33e-06 0 0 0 0 0 0 0 0 S 0}
    alpha {}}
  name ColorLookup4
  label "CIE 1931 2 Degree Standard Observer\n360nm to 830nm"
  xpos -700
  ypos -1030
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeLineOfPurples
  xpos -700
  ypos -897
  disable {{!parent.draw_line_of_purples}}
 }
 Fill {
  color {0 0 0 1}
  name Disable_SpectralLocus
  xpos -700
  ypos -826
  disable {{parent.draw_spectral_locus}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergePlanckianLocus
  xpos -700
  ypos -658
  disable {{!parent.draw_planckian_locus}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergePointerGamut
  xpos -700
  ypos -489
  disable {{!parent.draw_pointers_gamut}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergePointerGamut_Samples
  xpos -700
  ypos -417
  disable {{!draw_pointers_samples}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeMacbeth
  xpos -700
  ypos -273
  disable {{!parent.draw_macbeth_chart}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutGrid
  xpos -700
  ypos -81
  disable {{!parent.gamut_grid}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutA
  xpos -700
  ypos 255
  disable {{!parent.gamut_a}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutB
  xpos -700
  ypos 279
  disable {{!parent.gamut_b}}
 }
 Merge2 {
  inputs 2
  bbox B
  name MergeGamutC
  xpos -700
  ypos 303
  disable {{!parent.gamut_c}}
 }
 Dot {
  name Dot2
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -666
  ypos 450
 }
set N7cbcaa00 [stack 0]
 Dot {
  name Dot5
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -556
  ypos 450
 }
 Colorspace {
  colorspace_in CIE-XYZ
  primary_in "Adobe (1998)"
  colorspace_out CIE-Yxy
  name Colorspace6
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos -590
  ypos 488
 }
 Expression {
  expr0 r
  expr1 "4*g / ( -2*g + 12*b + 3)"
  expr2 "9*b / ( -2*g + 12*b + 3)"
  name Expression5
  label "CIE Yxy to CIELuv"
  xpos -590
  ypos 536
  disable {{!parent.diagram}}
 }
 Dot {
  name Dot11
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -556
  ypos 618
 }
push $N7cbcaa00
 ColorMatrix {
  matrix {
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
    }
  invert true
  name ColorMatrix1
  label "XYZ to working"
  xpos -700
  ypos 488
  disable {{!map_overlays_to_input_gamut}}
 }
 BlinkScript {
  inputs 2
  KernelDescription "2 \"PlotChromaticity_grid\" iterate pixelWise b2e7b5f8a89bdb0629aa8cc2eae387ef3436f24cb0af642eeba41235874506c4 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 6 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"tolerance\" Float 1 AAAAAA== \"antialias\" Bool 1 AA== \"draw_axes\" Bool 1 AA== \"grid_color\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== 6 \"padding\" 1 1 \"left_margin\" 1 1 \"tolerance\" 1 1 \"antialias\" 1 1 \"draw_axes\" 1 1 \"grid_color\" 4 1 2 \"outsize\" Float 1 1 AAAAAA== \"offset\" Float 1 1 AAAAAA=="
  kernelSource "kernel PlotChromaticity_grid : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float tolerance;\n  bool antialias;\n  bool draw_axes;\n  float4 grid_color;\n\nlocal:\n  float outsize;\n  float offset;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = float(dst.bounds.height()/padding);\n    // xy offset for margin on lower left corner\n    offset = dst.bounds.height()*left_margin;\n  \}\n\n  float gaussian(float d, float a, float expv) \{\n    return max(0.0f, exp(-a*d*d)-expv);\n  \}\n\n  float gaussian_filter(float x, float y, float r) \{\n    // return gaussian weighted distance from origin (0, 0)\n    // given coordinate (x, y) and radius r\n    float a = 1.5f; // rate falloff\n    float expv = exp(-a*r*r);\n    return gaussian(x, a, expv) * gaussian(y, a, expv);\n  \}\n\n  void write_aa(float x, float y, float4 rgb) \{\n    // skip black pixels\n    if (rgb.x == 0.0f && rgb.y == 0.0f && rgb.z == 0.0f) return;\n    \n    // size of pixel neighborhood = n*2+1 by n*2+1\n    int n = 2;\n\n    // center of neighborhood\n    int u0 = round(x);\n    int v0 = round(y);\n\n    // skip if center pixel weight is greater than tolerance\n    if ( dst.bounds.inside(u0, v0)) \{\n      if (dst(u0, v0, 3) >= tolerance) return;\n    \}\n\n    // loop over neighborhood\n    for (int j = -n; j <= n; j++) \{\n      int v = v0 + j;\n      for (int i = -n; i <= n; i++) \{\n        int u = u0 + i;\n        if ( dst.bounds.inside(u, v)) \{\n          // get filter weight for coord (u,v)\n          float w = gaussian_filter(u-x, v-y, float(n));\n          float4 c0 = dst(u, v); // existing color\n\n          // merge current color sample over existing color sample\n          for (int k=0; k<3; k++) \{\n            dst(u, v, k) = rgb\[k]*w+c0\[k]*(1-w); \n          \}\n\n          // merge current weight over existing weight\n          float w0 = dst(u, v, 3);\n          dst(u, v, 3) = w+w0*(1-w);\n        \}\n      \}\n    \}\n  \}\n\n  void draw_grid() \{\n    // grid width in pixels. expresses a 0 to 1 range in CIE xy\n    float grid_width = 1.0f * outsize + offset;\n    // draw grid lines\n    float i = offset;\n    while (i <= grid_width && i > 0.0f) \{\n      write_aa(offset, i, grid_color);\n      write_aa(i, offset, grid_color);\n      i += 1.0;\n    \}\n    // cross-hatching interval in pixels\n    float hatch_interval = (grid_width - offset) * 0.1f;\n    // cross-hatch length in pixels\n    float hatch_width = outsize * 0.01f;\n    i = offset;\n    while (i <= grid_width) \{\n      i += hatch_interval;\n      float j = 0.0;\n      while (j <= hatch_width/2) \{\n        write_aa(offset+j, i, grid_color);\n        write_aa(offset-j, i, grid_color);\n        write_aa(i, offset+j, grid_color);\n        write_aa(i, offset-j, grid_color);\n        j += 1.0;\n      \}\n    \}\n  \}\n\n  void process(int2 pos) \{\n    float4 rgba = col(pos.x, pos.y);\n    \n    // Get CIE xy position from Yxy input for current pixel\n    float2 xy = float2(Yxy(pos.x, pos.y, 1), Yxy(pos.x, pos.y, 2));\n    \n    // Find output pixel coordinate for this CIE xy pixel value\n    float2 out_coord = float2(xy.x * outsize + offset, xy.y * outsize + offset);\n\n    // For each RGB component, write value from color input to output coordinate\n    if (antialias) \{\n      write_aa(out_coord.x, out_coord.y, rgba);\n    \} else \{\n      // For each RGB component, write value from color input to output coordinate\n      int2 p = int2(round(out_coord.x), round(out_coord.y));\n      if (dst.bounds.inside(p.x, p.y)) \{\n        for (int k=0; k<3; k++) \{\n          dst(p.x, p.y, k) = col(pos.x, pos.y, k);\n        \}\n        dst(p.x, p.y, 3) = 1.0f;\n      \}\n    \}\n\n    // draw CIExy coordinate system axes\n    if (draw_axes && pos.x == 0 && pos.y == 0) \{\n      draw_grid();\n    \}\n  \}\n\};"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  PlotChromaticity_grid_padding {{parent.PlotChromaticities.PlotChromaticity_padding}}
  PlotChromaticity_grid_left_margin {{parent.PlotChromaticities.PlotChromaticity_left_margin}}
  PlotChromaticity_grid_tolerance 0.8
  PlotChromaticity_grid_antialias true
  PlotChromaticity_grid_draw_axes {{parent.coordinate_system}}
  PlotChromaticity_grid_grid_color {0.15 0 0.005 1}
  format "2048 2048 0 0 2048 2048 1 square_2K"
  rebuild_finalise ""
  name PlotInput2
  xpos -700
  ypos 608
 }
 FrameHold {
  firstFrame 1
  name FrameHold1
  xpos -700
  ypos 680
  cached true
 }
 Dot {
  name Dot3
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos -666
  ypos 762
 }
 Input {
  inputs 0
  name Input
  xpos 620
  ypos -1426
 }
 AddChannels {
  name AddChannels1
  xpos 620
  ypos -1360
 }
 Reformat {
  type "to box"
  box_width {{parent.resolution}}
  box_height {{box_width}}
  box_fixed true
  box_pixel_aspect {{input.pixel_aspect}}
  resize distort
  filter impulse
  name OutputFormat
  xpos 620
  ypos -1282
  disable {{!parent.resample_input}}
 }
 Crop {
  box {0 0 {width} {height}}
  crop false
  name CropBBox
  xpos 620
  ypos -1257
 }
 Dot {
  name Dot7
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 654
  ypos 162
 }
set N9ed5aa00 [stack 0]
 Constant {
  inputs 0
  channels rgb
  color {0 0 0 1}
  format "256 256 0 0 256 256 1 square_256"
  name Constant2
  xpos 400
  ypos 38
  postage_stamp false
 }
 Reformat {
  type "to box"
  box_width {{parent.resolution}}
  box_height {{box_width}}
  box_fixed true
  box_pixel_aspect {{input.pixel_aspect}}
  resize distort
  filter impulse
  name OutputFormat1
  xpos 400
  ypos 64
  disable {{!parent.resample_input}}
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input0]"}}
  name Switch1
  xpos 400
  ypos 158
 }
 Fill {
  output rgb
  color 0.18
  name SampleColor
  xpos 290
  ypos 158
 }
 Crop {
  box {0 0 {width} {height}}
  crop false
  name Crop2
  xpos 290
  ypos 184
 }
 Fill {
  output alpha
  name Fill3
  xpos 290
  ypos 224
 }
 Dot {
  name Dot6
  xpos 324
  ypos 282
 }
set N2d313e00 [stack 0]
 ColorMatrix {
  matrix {
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
      {{parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix} {parent.GamutToXYZ.ColorMatrix.matrix}}
    }
  name ColorMatrix4
  label "working to XYZ"
  xpos 180
  ypos 272
 }
 Colorspace {
  colorspace_in CIE-XYZ
  primary_in "Adobe (1998)"
  colorspace_out CIE-Yxy
  name Colorspace1
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos 180
  ypos 320
 }
 Expression {
  expr0 r
  expr1 "4*g / ( -2*g + 12*b + 3)"
  expr2 "9*b / ( -2*g + 12*b + 3)"
  name Expression6
  label "CIE Yxy to CIELuv"
  xpos 180
  ypos 368
  disable {{!parent.diagram}}
 }
push $N2d313e00
 BlinkScript {
  inputs 2
  KernelDescription "2 \"PlotChromaticity_sample\" iterate pixelWise 20e14b615a937bac78c1a771cbdfd10cc7c5fb6c487f65d0bb2d6633e404b958 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 3 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"tolerance\" Float 1 AAAAAA== 3 \"padding\" 1 1 \"left_margin\" 1 1 \"tolerance\" 1 1 2 \"outsize\" Float 1 1 AAAAAA== \"offset\" Float 1 1 AAAAAA=="
  kernelSource "kernel PlotChromaticity_sample : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float tolerance;\n\nlocal:\n  float outsize;\n  float offset;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = float(dst.bounds.height()/padding);\n    // xy offset for margin on lower left corner\n    offset = dst.bounds.height()*left_margin;\n  \}\n\n  void process(int2 pos) \{\n    // only process the first pixel\n    if (pos.x > 0 && pos.y > 0) return;\n\n    // Get CIE xy position from Yxy input for current pixel\n    float2 xy = float2(Yxy(pos.x, pos.y, 1), Yxy(pos.x, pos.y, 2));\n    \n    // Find output pixel coordinate for this CIE xy pixel value\n    float2 out_coord = float2(xy.x * outsize + offset, xy.y * outsize + offset);\n\n    // For each RGB component, write value from color input to output coordinate\n    int2 p = int2(round(out_coord.x), round(out_coord.y));\n    if (dst.bounds.inside(p.x, p.y)) \{\n      for (int k=0; k<3; k++) \{\n        dst(p.x, p.y, k) = col(pos.x, pos.y, k);\n      \}\n      dst(p.x, p.y, 3) = 1.0f;\n    \}\n  \}\n\};"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  PlotChromaticity_sample_padding {{"parent.diagram ? parent.right_margin*0.8 : parent.right_margin"}}
  PlotChromaticity_sample_left_margin {{parent.left_margin}}
  PlotChromaticity_sample_tolerance 1
  format "2048 2048 0 0 2048 2048 1 square_2K"
  rebuild_finalise ""
  name PlotChromaticities1
  xpos 290
  ypos 368
 }
 Dot {
  name Dot22
  xpos 324
  ypos 450
 }
set N7cbd0e00 [stack 0]
 Dilate {
  channels rgba
  size {{Output.width/2048}}
  name Dilate1
  label "\[value size]"
  xpos 290
  ypos 488
 }
set N7cbd1200 [stack 0]
 Dilate {
  channels rgba
  size {{Output.width/2048*2}}
  name Dilate2
  label "\[value size]"
  xpos 180
  ypos 488
 }
push $N7cbd0e00
 Dot {
  name Dot21
  xpos -6
  ypos 450
 }
 FilterErode {
  channels rgba
  size {{-Output.width/2048/5}}
  filter triangle
  name FilterErode1
  label "\[value size]"
  xpos -40
  ypos 489
 }
set N7cbd3c00 [stack 0]
 Dilate {
  channels rgba
  size {0 {parent.Dilate3.size.w}}
  name Dilate4
  label "\[value size]"
  xpos -40
  ypos 584
 }
push $N7cbd3c00
 Dilate {
  channels rgba
  size {{Output.width*plus_size/100} 0}
  name Dilate3
  label "\[value size]"
  xpos 70
  ypos 488
  addUserKnob {20 User}
  addUserKnob {7 plus_size R 0 4}
  plus_size 0.8
 }
 Merge2 {
  inputs 2
  operation screen
  bbox B
  name Merge9
  xpos 70
  ypos 591
 }
 Merge2 {
  inputs 2
  operation stencil
  bbox B
  name Merge10
  xpos 180
  ypos 591
 }
 Group {
  name HueRotate
  xpos 180
  ypos 639
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -24
  }
  Unpremult {
   name Unpremult1
   xpos -40
   ypos 15
  }
  Colorspace {
   colorspace_out HSV
   name Colorspace1
   xpos -40
   ypos 72
  }
  Add {
   channels {rgba.red -rgba.green -rgba.blue none}
   value 0.5
   name Add1
   xpos -40
   ypos 111
  }
  Fill {
   output {-rgba.red -rgba.green rgba.blue none}
   name Fill1
   xpos -40
   ypos 147
  }
  Colorspace {
   colorspace_in HSV
   name Colorspace2
   xpos -40
   ypos 183
  }
  Premult {
   name Premult1
   xpos -40
   ypos 231
  }
  Output {
   name Output1
   xpos -40
   ypos 302
  }
 end_group
push $N7cbd1200
 Merge2 {
  inputs 2
  bbox B
  name Merge8
  xpos 290
  ypos 638
 }
 Dot {
  name Dot20
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 324
  ypos 690
 }
push $N9ed5aa00
 Dot {
  name Dot1
  label " "
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 764
  ypos 162
 }
 Group {
  name GamutToXYZ
  label "\[if \{\[value invert]\} \{return \"XYZ to \[value gamut]\"\} else \{return \"\[value gamut] to XYZ\"\}]\n\n"
  xpos 730
  ypos 247
  addUserKnob {20 GamutToXYZ_tab l GamutToXYZ}
  addUserKnob {4 gamut t "Choose gamut" M {XYZ ACES ACEScg "Filmlight E-Gamut" Rec709 Rec2020 P3D60 P3D65 P3DCI "Arri AlexaWideGamut" REDDRAGONcolor REDDRAGONcolor2 REDcolor REDcolor2 REDcolor3 REDcolor4 REDWideGamutRGB "GoPro Protune Native" CanonCinemaGamut SonySGamut SonySGamut3Cine PanasonicVGamut "DJI D-Gamut" "Fujifilm F-Gamut" BMDFilmV1 BMD4kFilmV1 BMD4kFilmV3 BMD46kFilmV1 BMD46kFilmV3 BMDWideGamutV4 "AdobeRGB\t" AdobeWideGamutRGB ROMM RIMM ERIMM ProPhotoRGB RusselRGB SharpRGB AppleRGB BestRGB}}
  gamut ACES
  addUserKnob {6 invert +STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 chromaticity_coordinates_label l " " T "<b>Chromaticity Coordinates</b>"}
  addUserKnob {41 rxy T ColorMatrix.rxy}
  addUserKnob {41 gxy T ColorMatrix.gxy}
  addUserKnob {41 bxy T ColorMatrix.bxy}
  addUserKnob {41 wxy T ColorMatrix.wxy}
  addUserKnob {41 matrix T ColorMatrix.matrix}
 }
  Input {
   inputs 0
   name Input
   xpos -40
   ypos -10
  }
  ColorMatrix {
   matrix {
       {{curve(which) 1 0.9525524378 0.6624541879 0.7053968906 0.4123907983 0.6369580626 0.5049495697 0.4865709841 0.4451698363 0.6380076408 0.5070186853 0.4462202489 0.4300414324 0.4581649601 0.4878340662 0.4517004192 0.7352752686 0.5022571683 0.7160496712 0.7064827085 0.5990839601 0.6796444654 0.6481720209 0.6369580626 0.6390493512 0.6141571999 0.3724023998 0.60689044 0.4017650783 0.6065810919 0.5766690373 0.7165006995 0.797760427 0.797760427 0.797760427 0.7976718545 0.7015837431 0.8156226277 0.4496616423 0.6318944097} {curve(which) 0 0 0.1340042055 0.1640413404 0.3575843275 0.1446169019 0.2646814585 0.2656676769 0.2771343887 0.2147038579 0.3587769568 0.3157556653 0.3700728714 0.3832037449 0.3432727158 0.3178463876 0.06860940903 0.2929667532 0.1296834797 0.1288010478 0.2489254922 0.1522114277 0.1940581352 0.1446169019 0.1578372866 0.2825684249 0.4324877858 0.2193847299 0.4560420811 0.2203479856 0.1855582297 0.1010205746 0.1351858526 0.1351858526 0.1351858526 0.1351878047 0.1554162204 0.04716260359 0.3162561059 0.2053879201} {curve(which) 0 9.367863095e-05 0.1561876982 0.08101774752 0.180480808 0.1688809693 0.1830150485 0.1982172877 0.1722826511 0.09774444997 0.0868505761 0.190669477 0.152531758 0.1112773567 0.1215386018 0.1830992699 0.1465712637 0.1552320272 0.1047228053 0.1151721701 0.1024464965 0.1186000481 0.108225815 0.1688809693 0.1516760886 0.05183707923 0.1436725408 0.124180764 0.09264881909 0.123526901 0.1882286519 0.1467743814 0.03134934977 0.03134934977 0.03134934977 0.03133957833 0.09979832917 0.1372147948 0.1845382005 0.1270133406}}
       {{curve(which) 0 0.3439664543 0.2722287476 0.2801307142 0.2126390189 0.2627002299 0.237623319 0.2289745659 0.209491685 0.2919537723 0.2207257152 0.1942579001 0.2022213936 0.1694435924 0.2289056629 0.2119505703 0.2866941094 0.1387997568 0.2612613738 0.2709796727 0.2150758505 0.2606855333 0.2830046713 0.2627002299 0.1743051857 0.2365771234 0.1383759677 0.1973138005 0.1721783578 0.2680045366 0.2973450124 0.258728236 0.2880711257 0.2880711257 0.2880711257 0.2880405784 0.3152042925 0.3790788651 0.2446159422 0.2276017666} {curve(which) 1 0.7281661034 0.6740817428 0.8202066422 0.7151686549 0.6779980659 0.6891706586 0.6917385459 0.7215952873 0.8238410354 0.839184761 0.7385566831 0.7585275769 0.8648257852 0.7808576822 0.7230190039 0.8429791331 0.910841465 0.8696421385 0.786606431 0.8850684762 0.7748944759 0.8131960034 0.6779980659 0.951146543 0.8896810412 0.911518693 0.943950057 0.8553914428 0.8326833844 0.6273635626 0.7246823311 0.7118432522 0.7118432522 0.7118432522 0.7118694782 0.6648360491 0.5769088268 0.6720442176 0.7383946776} {curve(which) 0 -0.07213255018 0.05368951708 -0.1003373638 0.07219231874 0.05930171534 0.07320601493 0.07928691059 0.06891305745 -0.1157948226 -0.05991046131 0.06718540192 0.03925102949 -0.03426937759 -0.009763340466 0.06503042579 -0.1296732277 -0.04964122549 -0.1309035122 -0.05758608505 -0.1001443192 -0.03558001295 -0.09620071948 0.05930171534 -0.1254517138 -0.1262581497 -0.04989464581 -0.1412638426 -0.02756982669 -0.1006879359 0.07529145479 0.01658944227 8.565396274e-05 8.565396274e-05 8.565396274e-05 8.991353388e-05 0.01995966583 0.04401229322 0.08333983272 0.0340035744}}
       {{curve(which) 0 -3.863927134e-08 -0.005574660841 -0.1037815213 0.01933082007 0 0 0 0 0.0027982709 -0.0544523783 -0.04792318866 -0.0176958181 -0.1061859056 -0.02100777067 -0.01945115253 -0.07968087494 0.07801423222 -0.009676366113 -0.009677864611 -0.03206583485 -0.009310216643 -0.01825834997 0 -0.11669112 -0.02325225808 -0.1602820009 -0.1427432895 -0.10720893 -0.02941203304 0.02703136392 -2.906408625e-08 -3.236030111e-08 -3.236030111e-08 -3.236030111e-08 0 0 -0.01229703799 0.02518104948 0} {curve(which) 0 0 0.004060741514 -0.07290724665 0.1191947311 0.0280726999 0.0449459292 0.04511339962 0.04706057906 -0.06703422964 -0.0003228379355 -0.0002844714036 0.08768811822 0.02554347552 0.01782695204 0.01650637016 -0.3473432064 -0.3148325086 -0.2364816219 0.004600019194 -0.02765839547 -0.004612449091 -0.08316776901 0.0280726999 -0.5518454909 -0.4897170365 -0.171635136 -0.4278847873 0.07809129357 -0.08659287542 0.07068887353 0.05121183768 1.2621717e-08 1.2621717e-08 1.2621717e-08 -1.262213711e-08 0.04317118227 0.01672476344 0.1411857158 0.01001892332} {curve(which) 1 1.008825183 1.010339141 1.265746474 0.950532198 1.060985088 0.9638792276 1.043944359 0.9073553085 1.153293729 1.063571215 1.057001948 0.9388025999 1.089437366 1.01197505 1.011739731 1.51608181 1.325875998 1.335215807 1.094135642 1.148782015 1.102980375 1.190483928 1.060985088 1.745692492 1.590125084 1.409072995 1.65968585 1.118175387 1.205062628 0.9913375378 0.7738927603 0.8251045942 0.8251045942 0.8251045942 0.8248898983 0.8782252669 0.9955722094 0.9226909876 0.8150856495}}
     }
   invert {{parent.invert}}
   name ColorMatrix
   label "RGB to XYZ"
   xpos -40
   ypos 32
   addUserKnob {20 Gamut}
   addUserKnob {3 which}
   which {{parent.gamut}}
   addUserKnob {12 rxy}
   rxy {{curve(which) 1 0.7347 0.713 0.8 0.64 0.708 0.68 0.68 0.68 0.684 0.7530442228 0.7530444911 0.6997470013 0.8786825105 0.7011810359 0.7011805919 0.780308 0.69848046 0.74 0.73 0.766 0.73 0.71 0.708 0.9173 0.7422 1.0625 0.9175 0.8608 0.7177 0.64 0.7347 0.7347 0.7347 0.7347 0.734699 0.69 0.6898 0.625 0.7351916376} {curve(which) 0 0.2653 0.293 0.3177 0.33 0.292 0.32 0.32 0.32 0.313 0.3278305767 0.3278310295 0.3290469303 0.3249640074 0.3290141556 0.3290136991 0.304253 0.19302645 0.27 0.28 0.275 0.28 0.31 0.292 0.2502 0.2859 0.3948 0.2983 0.3689 0.3171 0.33 0.2653 0.2653 0.2653 0.2653 0.265301 0.31 0.3206 0.34 0.2648083624}}
   addUserKnob {12 gxy}
   gxy {{curve(which) 0 0 0.165 0.18 0.3 0.17 0.265 0.265 0.265 0.221 0.2995702285 0.2995704905 0.304264039 0.3008887144 0.3006003047 0.3006003955 0.121595 0.32955538 0.17 0.14 0.225 0.165 0.21 0.17 0.2833 0.414 0.3689 0.2983 0.3282 0.228 0.21 0.1152 0.1596 0.1596 0.1596 0.159597 0.18 0.0736 0.28 0.2153361345} {curve(which) 1 1 0.83 0.9 0.6 0.797 0.69 0.69 0.69 0.848 0.700699322 0.7006994156 0.6236411451 0.6790547558 0.6837888343 0.6837888243 1.493994 1.02459662 1.14 0.855 0.8 0.84 0.88 0.797 1.7072 1.3035 0.7775 1.2835 0.6156 0.8616 0.71 0.8264 0.8404 0.8404 0.8404 0.840403 0.77 0.9003 0.595 0.7741596639}}
   addUserKnob {12 bxy}
   bxy {{curve(which) 0 0.0001 0.128 0.065 0.15 0.131 0.15 0.15 0.15 0.0861 0.07964206674 0.1450115843 0.1349139613 0.09539869461 0.1081544556 0.1453319462 0.095612 0.10844263 0.08 0.1 0.089 0.1 0.09 0.131 0.0856 0.0342 0.0956 0.0756 0.0783 0.1006 0.15 0.1566 0.0366 0.0366 0.0366 0.036598 0.1 0.1166 0.155 0.1301229508} {curve(which) 0 -0.077 0.044 -0.0805 0.06 0.046 0.06 0.06 0.06 -0.102 -0.05493795109 0.05109712509 0.03471744128 -0.02937932683 -0.008688175787 0.05161680362 -0.084589 -0.03467857 -0.1 -0.05 -0.087 -0.03 -0.08 0.046 -0.0708 -0.0833 -0.0332 -0.086 -0.0233 -0.082 0.06 0.0177 0.0001 0.0001 0.0001 0.000105 0.02 0.0374 0.07 0.03483606557}}
   addUserKnob {12 wxy}
   wxy {{curve(which) 0.33333333 0.32168 0.32168 0.3127 0.3127 0.3127 0.32168 0.3127 0.314 0.3127 0.3216831877 0.3216832104 0.3216832894 0.3216832894 0.3216832104 0.3216832894 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3127 0.3135 0.3135 0.3135 0.3127 0.3127 0.3127 0.3127 0.3457 0.3457 0.3457 0.3457 0.345704 0.33243 0.33333333 0.3127 0.3457} {curve(which) 0.33333333 0.33767 0.33767 0.329 0.329 0.329 0.33767 0.329 0.351 0.329 0.337673316 0.3376736101 0.3376734472 0.3376734472 0.3376736101 0.3376734472 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.329 0.3305 0.3305 0.3305 0.329 0.329 0.329 0.329 0.3585 0.3585 0.3585 0.3585 0.35854 0.34744 0.33333333 0.329 0.3585}}
  }
  Output {
   name Output
   xpos -40
   ypos 86
  }
 end_group
 Colorspace {
  colorspace_in CIE-XYZ
  primary_in "Adobe (1998)"
  colorspace_out CIE-Yxy
  name Colorspace2
  label "\[value colorspace_in] -> \[value colorspace_out]"
  xpos 730
  ypos 296
 }
 Expression {
  expr0 r
  expr1 "4*g / ( -2*g + 12*b + 3)"
  expr2 "9*b / ( -2*g + 12*b + 3)"
  name Expression4
  label "CIE Yxy to CIELuv"
  xpos 730
  ypos 344
  disable {{!parent.diagram}}
 }
 Dot {
  name Dot13
  label " Pos"
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 764
  ypos 546
 }
push $N9ed5aa00
 Dot {
  name Dot16
  label " Col"
  note_font "Helvetica Bold"
  note_font_size 24
  note_font_color 0xa5a5a501
  xpos 654
  ypos 450
 }
 BlinkScript {
  inputs 2
  KernelDescription "2 \"PlotChromaticity\" iterate pixelWise 3e86399c7642fe5c35c23528a644f88a8bf13f967de084ae6842f8be55098c6b 3 \"col\" Read Random \"Yxy\" Read Random \"dst\" Write Random 4 \"padding\" Float 1 AAAAAA== \"left_margin\" Float 1 AAAAAA== \"tolerance\" Float 1 AAAAAA== \"antialias\" Bool 1 AA== 4 \"padding\" 1 1 \"left_margin\" 1 1 \"tolerance\" 1 1 \"antialias\" 1 1 2 \"outsize\" Float 1 1 AAAAAA== \"offset\" Float 1 1 AAAAAA=="
  kernelSource "kernel PlotChromaticity : public ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom, eEdgeClamped> col;\n  Image<eRead, eAccessRandom, eEdgeClamped> Yxy;\n  Image<eWrite, eAccessRandom> dst;\n\nparam:\n  float padding;\n  float left_margin;\n  float tolerance;\n  bool antialias;\n\nlocal:\n  float outsize;\n  float offset;\n\n  void init() \{\n    // calculate output width and height and offset based on padding\n    outsize = float(dst.bounds.height()/padding);\n    // xy offset for margin on lower left corner\n    offset = dst.bounds.height()*left_margin;\n  \}\n\n  float gaussian(float d, float a, float expv) \{\n    return max(0.0f, exp(-a*d*d)-expv);\n  \}\n\n  float gaussian_filter(float x, float y, float r) \{\n    // return gaussian weighted distance from origin (0, 0)\n    // given coordinate (x, y) and radius r\n    float a = 1.5f; // rate falloff\n    float expv = exp(-a*r*r);\n    return gaussian(x, a, expv) * gaussian(y, a, expv);\n  \}\n\n  void write_aa(float x, float y, float4 rgb) \{\n    // skip black pixels\n    if (rgb.x == 0.0f && rgb.y == 0.0f && rgb.z == 0.0f) return;\n    \n    // size of pixel neighborhood = n*2+1 by n*2+1\n    int n = 2;\n\n    // center of neighborhood\n    int u0 = round(x);\n    int v0 = round(y);\n\n    // skip if center pixel weight is greater than tolerance\n    if ( dst.bounds.inside(u0, v0)) \{\n      if (dst(u0, v0, 3) >= tolerance) return;\n    \}\n\n    // loop over neighborhood\n    for (int j = -n; j <= n; j++) \{\n      int v = v0 + j;\n      for (int i = -n; i <= n; i++) \{\n        int u = u0 + i;\n        if ( dst.bounds.inside(u, v)) \{\n          // get filter weight for coord (u,v)\n          float w = gaussian_filter(u-x, v-y, float(n));\n          float4 c0 = dst(u, v); // existing color\n\n          // merge current color sample over existing color sample\n          for (int k=0; k<3; k++) \{\n            dst(u, v, k) = rgb\[k]*w+c0\[k]*(1-w); \n          \}\n\n          // merge current weight over existing weight\n          float w0 = dst(u, v, 3);\n          dst(u, v, 3) = w+w0*(1-w);\n        \}\n      \}\n    \}\n  \}\n\n\n  void process(int2 pos) \{\n    float4 rgba = col(pos.x, pos.y);\n    \n    // Get CIE xy position from Yxy input for current pixel\n    float2 xy = float2(Yxy(pos.x, pos.y, 1), Yxy(pos.x, pos.y, 2));\n    \n    // Find output pixel coordinate for this CIE xy pixel value\n    float2 out_coord = float2(xy.x * outsize + offset, xy.y * outsize + offset);\n\n    // For each RGB component, write value from color input to output coordinate\n    if (antialias) \{\n      write_aa(out_coord.x, out_coord.y, rgba);\n    \} else \{\n      // For each RGB component, write value from color input to output coordinate\n      int2 p = int2(round(out_coord.x), round(out_coord.y));\n      if (dst.bounds.inside(p.x, p.y)) \{\n        for (int k=0; k<3; k++) \{\n          dst(p.x, p.y, k) = col(pos.x, pos.y, k);\n        \}\n        dst(p.x, p.y, 3) = 1.0f;\n      \}\n    \}\n  \}\n\};"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  PlotChromaticity_padding {{"parent.diagram ? parent.right_margin*0.8 : parent.right_margin"}}
  PlotChromaticity_left_margin {{parent.left_margin}}
  PlotChromaticity_tolerance 2
  PlotChromaticity_antialias true
  format "2048 2048 0 0 2048 2048 1 square_2K"
  rebuild_finalise ""
  name PlotChromaticities
  xpos 620
  ypos 536
  disable {{!parent.plot_input}}
 }
 Fill {
  color 0
  name BLACK
  tile_color 0x111111ff
  xpos 620
  ypos 591
  disable {{parent.plot_input}}
 }
 Merge2 {
  inputs 2
  bbox B
  name Merge7
  xpos 620
  ypos 686
  disable {{!parent.enable_sample_color}}
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 620
  ypos 758
 }
 Output {
  name Output
  xpos 620
  ypos 1046
 }
end_group
push $N6d517600
Write {
 file /Users/afry/Working/ACESCentral/P3_Troubleshooting/JMh_SideSliceDiagram_distance1000.png
 file_type png
 checkHashOnRead false
 version 2
 in_colorspace scene_linear
 out_colorspace scene_linear
 name Write3
 xpos 489
 ypos 1052
}
Reformat {
 inputs 0
 type "to box"
 box_width 512
 box_height 4
 box_fixed true
 name Reformat10
 xpos 2222
 ypos 1031
}
Ramp {
 p0 {0 0}
 p1 {{width-1} 0}
 name Ramp2
 xpos 2222
 ypos 1055
}
set N8e7d8400 [stack 0]
Grade {
 blackpoint {1 0 0 1}
 whitepoint {1 0 1 1}
 reverse true
 name Grade14
 xpos 3393
 ypos 1097
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {1 1 0 1}
 whitepoint {1 1 1 1}
 reverse true
 name Grade15
 xpos 3295
 ypos 1097
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {0 0 1 1}
 whitepoint {1 0 1 1}
 reverse true
 name Grade16
 xpos 3155
 ypos 1102
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {1 0 1 1}
 whitepoint {1 1 1 1}
 reverse true
 name Grade17
 xpos 3035
 ypos 1101
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {0 1 1 1}
 whitepoint {0 1 0 1}
 reverse true
 name Grade18
 xpos 2917
 ypos 1098
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {0 1 1 1}
 whitepoint {1 1 1 1}
 reverse true
 name Grade19
 xpos 2797
 ypos 1098
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {0 1 1 1}
 whitepoint {0 0 1 1}
 reverse true
 name Grade20
 xpos 2691
 ypos 1106
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {1 1 0 1}
 whitepoint {0 1 0 1}
 reverse true
 name Grade21
 xpos 2599
 ypos 1106
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {1 1 0 1}
 whitepoint {1 0 0 1}
 reverse true
 name Grade22
 xpos 2512
 ypos 1105
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {0 0 0 1}
 whitepoint {0 0 1 1}
 reverse true
 name Grade23
 xpos 2402
 ypos 1101
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {0 0 0 1}
 whitepoint {0 1 0 1}
 reverse true
 name Grade24
 xpos 2309
 ypos 1101
 postage_stamp true
}
push $N8e7d8400
Grade {
 blackpoint {0 0 0 1}
 whitepoint {1 0 0 1}
 reverse true
 name Grade25
 xpos 2222
 ypos 1100
 postage_stamp true
}
ContactSheet {
 inputs 12
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows {{inputs}}
 columns 1
 name ContactSheet10
 xpos 2222
 ypos 1208
}
set Nac6af200 [stack 0]
Colorspace {
 primary_in DCI-P3
 colorspace_out CIE-Yxy
 name Colorspace3
 xpos 2371
 ypos 1311
}
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 rgba.red 0 0 rgba.green 0 1 rgba.blue 0 2 rgba.red 0 0 rgba.green 0 1 rgba.blue 0 2"
 name Shuffle23
 xpos 2371
 ypos 1335
}
push $Nac6af200
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 0.001
 name PositionToPoints11
 xpos 2490
 ypos 1411
}
push $Nac6af200
Colorspace {
 colorspace_out CIE-Yxy
 name Colorspace2
 xpos 2222
 ypos 1316
}
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 rgba.red 0 0 rgba.green 0 1 rgba.blue 0 2 rgba.red 0 0 rgba.green 0 1 rgba.blue 0 2"
 name Shuffle22
 xpos 2222
 ypos 1340
}
push $Nac6af200
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 0.001
 name PositionToPoints10
 xpos 2343
 ypos 1416
}
Scene {
 inputs 2
 name Scene2
 xpos 2478
 ypos 1447
}
Reformat {
 inputs 0
 type "to box"
 box_width 512
 box_height 4
 box_fixed true
 name Reformat12
 xpos 4883
 ypos -87
}
Ramp {
 p0 {0 0}
 p1 {{width-1} 0}
 name Ramp3
 xpos 4883
 ypos -63
}
set N7b267800 [stack 0]
Grade {
 blackpoint {1 0 0 1}
 whitepoint {1 0 1 1}
 reverse true
 name Grade26
 xpos 6054
 ypos -21
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {1 1 0 1}
 whitepoint {1 1 1 1}
 reverse true
 name Grade27
 xpos 5956
 ypos -21
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {0 0 1 1}
 whitepoint {1 0 1 1}
 reverse true
 name Grade28
 xpos 5816
 ypos -16
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {1 0 1 1}
 whitepoint {1 1 1 1}
 reverse true
 name Grade29
 xpos 5696
 ypos -17
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {0 1 1 1}
 whitepoint {0 1 0 1}
 reverse true
 name Grade30
 xpos 5578
 ypos -20
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {0 1 1 1}
 whitepoint {1 1 1 1}
 reverse true
 name Grade31
 xpos 5458
 ypos -20
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {0 1 1 1}
 whitepoint {0 0 1 1}
 reverse true
 name Grade32
 xpos 5352
 ypos -12
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {1 1 0 1}
 whitepoint {0 1 0 1}
 reverse true
 name Grade33
 xpos 5260
 ypos -12
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {1 1 0 1}
 whitepoint {1 0 0 1}
 reverse true
 name Grade34
 xpos 5173
 ypos -13
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {0 0 0 1}
 whitepoint {0 0 1 1}
 reverse true
 name Grade35
 xpos 5070
 ypos -15
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {0 0 0 1}
 whitepoint {0 1 0 1}
 reverse true
 name Grade36
 xpos 4970
 ypos -17
 postage_stamp true
}
push $N7b267800
Grade {
 blackpoint {0 0 0 1}
 whitepoint {1 0 0 1}
 reverse true
 name Grade37
 xpos 4883
 ypos -17
 postage_stamp true
}
ContactSheet {
 inputs 12
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows {{inputs}}
 columns 1
 name ContactSheet11
 xpos 4910
 ypos 162
}
Reformat {
 inputs 0
 type "to box"
 format "256 256 0 0 256 256 1 square_256"
 box_width 64
 box_height {{box_width}}
 box_fixed true
 name Reformat13
 xpos 5057
 ypos 238
}
Expression {
 expr0 x/(width-1)
 expr1 y/(height-1)
 name Expression16
 xpos 5057
 ypos 302
}
set N2f78a400 [stack 0]
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 white -1 -1 rgba.blue 0 2 rgba.alpha 0 3 rgba.alpha 0 3"
 name Shuffle30
 xpos 5589
 ypos 346
}
push $N2f78a400
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 rgba.green 0 1 rgba.blue 0 2 white -1 -1 rgba.green 0 1 rgba.red 0 0 rgba.red 0 0"
 name Shuffle29
 xpos 5463
 ypos 347
}
push $N2f78a400
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 rgba.green 0 1 rgba.blue 0 2 black -1 -1 rgba.green 0 1 rgba.red 0 0 rgba.red 0 0"
 name Shuffle28
 xpos 5368
 ypos 345
}
push $N2f78a400
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 white -1 -1 rgba.red 0 0 rgba.green 0 1 rgba.blue 0 2 rgba.red 0 0 rgba.green 0 1"
 name Shuffle26
 xpos 5240
 ypos 345
}
push $N2f78a400
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 black -1 -1 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.alpha 0 3 rgba.alpha 0 3 rgba.red 0 0 rgba.blue 0 2"
 name Shuffle25
 xpos 5123
 ypos 345
}
push $N2f78a400
ContactSheet {
 inputs 6
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows {{inputs}}
 columns 1
 name ContactSheet12
 xpos 5057
 ypos 410
}
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
 name Shuffle27
 xpos 5057
 ypos 476
}
PositionToPoints2 {
 display textured
 render_mode textured
 P_channel rgb
 detail 1
 pointSize 1
 name PositionToPoints13
 xpos 5057
 ypos 519
}
Reformat {
 inputs 0
 type "to box"
 format "256 256 0 0 256 256 1 square_256"
 box_width 16
 box_height {{box_width}}
 box_fixed true
 name Reformat14
 xpos 3414
 ypos -348
}
Expression {
 expr0 x/(width-1)
 expr1 y/(height-1)
 name Expression17
 xpos 3414
 ypos -284
}
set Na96f8a00 [stack 0]
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 white -1 -1 rgba.blue 0 2 rgba.alpha 0 3 rgba.alpha 0 3"
 name Shuffle31
 xpos 3946
 ypos -240
}
push $Na96f8a00
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 rgba.green 0 1 rgba.blue 0 2 white -1 -1 rgba.green 0 1 rgba.red 0 0 rgba.red 0 0"
 name Shuffle32
 xpos 3820
 ypos -239
}
push $Na96f8a00
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 rgba.green 0 1 rgba.blue 0 2 black -1 -1 rgba.green 0 1 rgba.red 0 0 rgba.red 0 0"
 name Shuffle33
 xpos 3725
 ypos -241
}
push $Na96f8a00
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.alpha 0 3 rgba.alpha 0 3 white -1 -1 rgba.red 0 0 rgba.green 0 1 rgba.blue 0 2 rgba.red 0 0 rgba.green 0 1"
 name Shuffle34
 xpos 3597
 ypos -241
}
push $Na96f8a00
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 black -1 -1 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.alpha 0 3 rgba.alpha 0 3 rgba.red 0 0 rgba.blue 0 2"
 name Shuffle35
 xpos 3480
 ypos -241
}
push $Na96f8a00
ContactSheet {
 inputs 6
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows {{inputs}}
 columns 1
 name ContactSheet13
 xpos 3414
 ypos -176
}
Shuffle2 {
 fromInput1 {{0} B}
 fromInput2 {{0} B}
 mappings "4 rgba.red 0 0 rgba.red 0 0 rgba.green 0 1 rgba.green 0 1 rgba.blue 0 2 rgba.blue 0 2 white -1 -1 rgba.alpha 0 3"
 name Shuffle36
 xpos 3414
 ypos -152
}
set N3d050c00 [stack 0]
Dot {
 name Dot9
 xpos 3844
 ypos -73
}
set Na569d200 [stack 0]
Group {
 name DRT_CAM23
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 3709
 ypos 30
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 primaries_in P3-D65
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 1
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
set N530a0c00 [stack 0]
Group {
 name DRT_CAM24
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 3892
 ypos 30
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit P3-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 invert true
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2430
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise 476961b8cea534d36c4f89bb3e086293a677b4c8cd1d73eccfdcc13f2bd95d0d 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    \n    \n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 13
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Shuffle {
 name Shuffle38
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 3892
 ypos 123
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply14
 note_font "Bitstream Vera Sans"
 xpos 3892
 ypos 159
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression19
 note_font "Bitstream Vera Sans"
 xpos 3892
 ypos 195
}
set Nb9d79800 [stack 0]
push $Na569d200
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints15
 xpos 3994
 ypos 287
}
set Nb9a04a00 [stack 0]
push $N530a0c00
Shuffle {
 name Shuffle39
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 3709
 ypos 131
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply15
 note_font "Bitstream Vera Sans"
 xpos 3709
 ypos 167
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression20
 note_font "Bitstream Vera Sans"
 xpos 3709
 ypos 203
}
set Ncdfffc00 [stack 0]
push $Na569d200
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints16
 xpos 3810
 ypos 294
}
Scene {
 inputs 2
 name Scene4
 xpos 3945
 ypos 387
}
push $N3d050c00
Dot {
 name Dot8
 xpos 3448
 ypos -85
}
set N6f929600 [stack 0]
Group {
 name DRT_CAM21
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 3313
 ypos 11
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 primaries_in sRGB/Rec.709-D65
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 1
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
set Nd1ba2e00 [stack 0]
Group {
 name DRT_CAM22
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 3496
 ypos 11
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 applyChromaCompression true
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 apply_gamut_compression true
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 1000
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 1}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 smooth_cusps 0.6
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 invert true
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2430
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise 476961b8cea534d36c4f89bb3e086293a677b4c8cd1d73eccfdcc13f2bd95d0d 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 1);\n    \}\n    else if (diagnosticMode == 13)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, invert);\n    \}\n    \n    \n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 13
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  selected true
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Shuffle {
 name Shuffle37
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 3496
 ypos 111
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply13
 note_font "Bitstream Vera Sans"
 xpos 3496
 ypos 147
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression18
 note_font "Bitstream Vera Sans"
 xpos 3496
 ypos 183
}
set Nd903a400 [stack 0]
push $N6f929600
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints14
 xpos 3598
 ypos 273
}
set Nd9130600 [stack 0]
push $Nd1ba2e00
Shuffle {
 name Shuffle24
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 3313
 ypos 119
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply12
 note_font "Bitstream Vera Sans"
 xpos 3313
 ypos 155
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression9
 note_font "Bitstream Vera Sans"
 xpos 3313
 ypos 191
}
set Ndb8aa800 [stack 0]
push $N6f929600
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints12
 xpos 3414
 ypos 282
}
set Nb9ffba00 [stack 0]
Scene {
 inputs 2
 name Scene3
 xpos 3525
 ypos 419
}
push $Nb9a04a00
push $Nd9130600
Scene {
 inputs 2
 name Scene5
 xpos 3819
 ypos 428
}
push $Nb9d79800
push $Ncdfffc00
Dissolve {
 inputs 2
 which {{curve x1 0 x20 1}}
 name Dissolve2
 xpos 3668
 ypos 354
}
ContactSheet {
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows {{inputs}}
 columns 20
 splitinputs true
 startframe 1
 endframe 20
 name ContactSheet16
 xpos 3668
 ypos 386
}
push $Na569d200
ContactSheet {
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows {{inputs}}
 columns 20
 splitinputs true
 startframe 1
 endframe 20
 name ContactSheet17
 xpos 3761
 ypos 387
}
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints18
 xpos 3740
 ypos 500
}
push $N2d588800
Reformat {
 type scale
 scale 8
 name Reformat11
 xpos 3044
 ypos -69
 disable true
}
push $Nd903a400
push $Ndb8aa800
Dissolve {
 inputs 2
 which {{curve x1 0 x20 1}}
 name Dissolve1
 xpos 3279
 ypos 352
}
set N64419200 [stack 0]
ContactSheet {
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows {{inputs}}
 columns 20
 splitinputs true
 startframe 1
 endframe 20
 name ContactSheet14
 xpos 3279
 ypos 384
}
push $N6f929600
ContactSheet {
 width {{input.width*columns}}
 height {{input.height*rows}}
 rows {{inputs}}
 columns 20
 splitinputs true
 startframe 1
 endframe 20
 name ContactSheet15
 xpos 3372
 ypos 385
}
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints17
 xpos 3352
 ypos 504
}
push $N2d588800
Dot {
 name Dot11
 xpos 4499
 ypos -20
}
set Nd1a7fa00 [stack 0]
Group {
 name DRT_CAM26
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 4368
 ypos 15
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 primaries_in sRGB/Rec.709-D65
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 1
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Shuffle {
 name Shuffle41
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 4368
 ypos 159
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply18
 note_font "Bitstream Vera Sans"
 xpos 4368
 ypos 195
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression22
 note_font "Bitstream Vera Sans"
 xpos 4368
 ypos 231
}
push $Nd1a7fa00
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints20
 xpos 4465
 ypos 310
}
push $N2d588800
Dot {
 name Dot10
 xpos 4332
 ypos -39
}
set Naeb05600 [stack 0]
Group {
 name DRT_CAM25
 label "Input: \[value encoding_in] / \[value primaries_in]\nLimit: \[value primaries_limit] / \[value ssts_luminance.2]nits\nOutput: \[value encoding_out] / \[value primaries_out]\n\[value toneScaleMode]\n\[file tail \[value BlinkScript1.kernelSourceFile]]"
 note_font "Bitstream Vera Sans"
 xpos 4201
 ypos -4
 addUserKnob {20 User}
 addUserKnob {26 input_div l Input}
 addUserKnob {4 encoding_in l encoding t "the input log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_in l primaries t "the input primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" ""}}
 primaries_in AP1-ACES
 addUserKnob {26 ""}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_in l HK_mode_in T BlinkScript1.DRT_CAM_Kernel_HK_mode_in}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_in l discountIlluminant_in -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_in}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_mid l HK_mode_mid T BlinkScript1.DRT_CAM_Kernel_HK_mode_mid}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_mid l discountIlluminant_mid -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_mid}
 addUserKnob {41 DRT_CAM_Kernel_HK_mode_out l HK_mode_out T BlinkScript1.DRT_CAM_Kernel_HK_mode_out}
 addUserKnob {41 DRT_CAM_Kernel_discountIlluminant_out l discountIlluminant_out -STARTLINE T BlinkScript1.DRT_CAM_Kernel_discountIlluminant_out}
 addUserKnob {26 ""}
 addUserKnob {6 compress_mode l compressMode t "LMS compression mode\n" +STARTLINE}
 compress_mode true
 addUserKnob {4 HellwigCam16Data l "Hellwig Cam16 Data" M {Stock Thomas "Live from params"}}
 HellwigCam16Data "Live from params"
 addUserKnob {4 inputViewingConditions l "Input Viewing Conditions" M {dark dim average}}
 inputViewingConditions dim
 addUserKnob {7 ac_resp l "Achromatic response" t "Changes how L, M and S channels contribute to the model's achromatic response.  0 is equal contribution from each channel, 1 is 2x contribution for L channel, which is the model's default."}
 ac_resp 1
 addUserKnob {26 ""}
 addUserKnob {26 tonescale_div l Tonescale}
 addUserKnob {4 toneScaleMode l "ToneScale Mode" M {Linear "Daniele Evo Curve" "" ""}}
 toneScaleMode "Daniele Evo Curve"
 addUserKnob {6 applyTonecurve l "apply Tonecurve" t "toggle the SingleStageToneScale transform" +STARTLINE}
 applyTonecurve true
 addUserKnob {13 ssts_luminance l Luminance t "min, mid & peak luminance values in Cd/sqm as parameters for the SSTS"}
 ssts_luminance {1e-06 10 100}
 addUserKnob {26 ssts_luminance_label l " " -STARTLINE T "min / mid / peak"}
 addUserKnob {26 gamut_mapping_div l "Gamut Mapping"}
 addUserKnob {6 applyChromaCompression l "apply in gamut compression" +STARTLINE}
 addUserKnob {13 chromaCompress l chromaCompression t "In-gamut chroma compression parameters: limit, compression strength, compression expansion rate"}
 chromaCompress {1.22 2.6 0.73}
 addUserKnob {4 et l "eccentricity factor" t "Eccentricity factor for chroma compression gamut scaling" M {CAM16 Hellwig2022 Custom None "" "" "" ""}}
 et Custom
 addUserKnob {26 cc_gamut l "" -STARTLINE T "compression gamut: Rec.709"}
 addUserKnob {7 saturation t "Global saturation" R 0 1.5}
 saturation 1
 addUserKnob {6 apply_gamut_compression l "apply out of gamut compression " t "toggle the gamut compression towards the limiting primaries" +STARTLINE}
 addUserKnob {4 primaries_limit l "limiting primaries" t "the limiting primaries of the gamut to which to compress to" M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 primaries_limit sRGB/Rec.709-D65
 addUserKnob {7 cusp_mid_blend l "cusp to mid blend" t "blend the lightness (J) of the focal point of the compression between the lightness of the gamut cusp at the given hue (0.0)  and the mid luminance of the SSTS (1.0)"}
 cusp_mid_blend 0.85
 addUserKnob {26 cusp_mid_blend_label l " " -STARTLINE T "cusp (0) to mid gray (1)"}
 addUserKnob {7 focus_distance l "focus distance" t "Focus distance value behind acchromatic.  Larger value is closer to opposite cusp point behind the achromatic.  Smaller value is closer to achromatic.\n\n0=achromatic, 1=cusp behind achromatic"}
 focus_distance 3
 addUserKnob {19 compression_params l compression t "the threshold, min limit, max limit, and power parameters for the PowerP compression function\n\nvalues below the threshold will not be compressed and values at the limit will be compressed towards the gamut boundary while the power values defines the shape of the curve"}
 compression_params {0.2 1.1 1.7 3}
 addUserKnob {6 compression_params_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 smooth_cusps l "smooth cusps" t "the amount by how much to smooth the edges and corners of the limiting gamut cube, except the black & white corners."}
 addUserKnob {20 sixAxisCompression n 1}
 sixAxisCompression 0
 addUserKnob {6 sixAxisCompressionMode +STARTLINE}
 addUserKnob {19 compressionFuncParamsR}
 compressionFuncParamsR {0.75 1.1 1.1 1}
 addUserKnob {6 compressionFuncParamsR_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsY}
 compressionFuncParamsY {0.75 1.05 1.05 1}
 addUserKnob {6 compressionFuncParamsY_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsG}
 compressionFuncParamsG {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsG_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsC}
 compressionFuncParamsC {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsC_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsB}
 compressionFuncParamsB {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsB_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 compressionFuncParamsM}
 compressionFuncParamsM {0.75 1.2 1.45 1}
 addUserKnob {6 compressionFuncParamsM_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {20 endGroup n -1}
 addUserKnob {6 color_rgba_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 color_rgb_panelDropped l "panel dropped state" +HIDDEN +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 output_div l Output}
 addUserKnob {4 encoding_out l encoding t "the output log or gamma encoding" M {Linear ACEScct sRGB BT.1886 "Gamma 2.6" ST2084 "" ""}}
 addUserKnob {4 primaries_out l primaries t "the output primaries and white point" -STARTLINE M {AP0-ACES AP1-ACES sRGB/Rec.709-D65 Rec.2020-D65 P3-D65 P3-DCI "" "" "" ""}}
 addUserKnob {4 viewing_conditions l "viewing conditions" t "the ZCAM viewing conditions" M {dark dim average ""}}
 viewing_conditions dim
 addUserKnob {7 reference_luminance l "reference luminance" t "the ZCAM reference luminance in Cd/sqm" R 0 200}
 reference_luminance 100
 addUserKnob {7 background_luminance l "background luminance" t "the ZCAM background luminance in Cd/sqm" R 0 100}
 background_luminance 10
 addUserKnob {6 clamp_output l "clamp output" t "clamp the output values between 0,0 and 1.0" +STARTLINE}
 clamp_output true
 addUserKnob {6 soft_clamp l "soft clamp output" t "Soft clamp display output values so that no negative RGB channels occur" -STARTLINE}
 soft_clamp true
 addUserKnob {26 ""}
 addUserKnob {26 HellwigParams l "Hellwig2022 Params"}
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A l "Input Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b l "Input background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b 20
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_L_A_out l "Output Adapting field" t "    //     L_A\n    //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n    //         to be 20% of the luminance of a white object in the scene)."}
 BlinkScript1_DRT_CAM_Kernel_L_A_out 100
 addUserKnob {8 BlinkScript1_DRT_CAM_Kernel_Y_b_out l "Output background" t "    //     Y_b\n    //         Luminous factor of background :math:`Y_b` such as\n    //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n    //         light source and :math:`L_b` is the luminance of the background. For\n    //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n    //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n    //         approximate an :math:`L^*` of 50 is used."}
 BlinkScript1_DRT_CAM_Kernel_Y_b_out 20
 addUserKnob {26 ""}
 addUserKnob {26 _2 l "" +STARTLINE T "Custom CAM 16 style prims"}
 addUserKnob {41 DRT_CAM_Kernel_rxy l rxy T BlinkScript1.DRT_CAM_Kernel_rxy}
 addUserKnob {41 DRT_CAM_Kernel_gxy l gxy T BlinkScript1.DRT_CAM_Kernel_gxy}
 addUserKnob {41 DRT_CAM_Kernel_bxy l bxy T BlinkScript1.DRT_CAM_Kernel_bxy}
 addUserKnob {41 DRT_CAM_Kernel_wxy l wxy T BlinkScript1.DRT_CAM_Kernel_wxy}
 addUserKnob {26 ""}
 addUserKnob {26 direction_div l Direction}
 addUserKnob {6 invert t "apply the pseudo-inverse transform" +STARTLINE}
 addUserKnob {41 DRT_CAM_Kernel_diagnosticMode l diagnosticMode T BlinkScript1.DRT_CAM_Kernel_diagnosticMode}
 addUserKnob {26 blink_kernel_div l "Blink Kernel"}
 addUserKnob {6 use_gpu l "Use GPU if available" +STARTLINE}
 use_gpu true
 addUserKnob {26 ""}
}
 Input {
  inputs 0
  name Input1
  xpos -908
  ypos -292
 }
 BlinkScript {
  kernelSourceFile /Users/afry/GitHub/output-transforms-dev/display-transforms/nuke/CAM_DRT_v035.blink
  recompileCount 2416
  ProgramGroup 1
  KernelDescription "2 \"DRT_CAM_Kernel\" iterate pixelWise b35ea2caf209e5a51812a078d3669c4fe0b54c6c13b14ed3f146299e649f9731 2 \"src\" Read Point \"dst\" Write Point 71 \"encodingIn\" Int 1 AAAAAA== \"primariesIn\" Int 1 AAAAAA== \"toneScaleMode\" Int 1 AAAAAA== \"discountIlluminant_in\" Bool 1 AA== \"discountIlluminant_mid\" Bool 1 AA== \"discountIlluminant_out\" Bool 1 AA== \"HK_mode_in\" Bool 1 AA== \"HK_mode_mid\" Bool 1 AA== \"HK_mode_out\" Bool 1 AA== \"compressMode\" Int 1 AAAAAA== \"referenceLuminance\" Float 1 AAAAAA== \"backgroundLuminance\" Float 1 AAAAAA== \"viewingConditions\" Int 1 AAAAAA== \"outputViewingConditions\" Int 1 AAAAAA== \"applyTonecurve\" Bool 1 AA== \"sstsLuminance\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"applyChromaCompression\" Bool 1 AA== \"chromaCParams\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"cc_et\" Int 1 AAAAAA== \"crxy\" Float 2 AAAAAAAAAAA= \"cgxy\" Float 2 AAAAAAAAAAA= \"cbxy\" Float 2 AAAAAAAAAAA= \"cwxy\" Float 2 AAAAAAAAAAA= \"sat\" Float 1 AAAAAA== \"primariesLimit\" Int 1 AAAAAA== \"applyGamutCompression\" Bool 1 AA== \"cuspMidBlend\" Float 1 AAAAAA== \"focusDistance\" Float 1 AAAAAA== \"compressionFuncParams\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"sixAxisCompressionMode\" Bool 1 AA== \"compressionFuncParamsR\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsY\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsG\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsC\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsB\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"compressionFuncParamsM\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"smoothCusps\" Float 1 AAAAAA== \"encodingOut\" Int 1 AAAAAA== \"primariesOut\" Int 1 AAAAAA== \"clampOutput\" Bool 1 AA== \"softclampOutput\" Bool 1 AA== \"clamp_thr\" Float 1 AAAAAA== \"clamp_dist\" Float 1 AAAAAA== \"invert\" Bool 1 AA== \"diagnosticMode\" Int 1 AAAAAA== \"mmScaleFactor\" Float 1 AAAAAA== \"daniele_n\" Float 1 AAAAAA== \"daniele_n_r\" Float 1 AAAAAA== \"daniele_g\" Float 1 AAAAAA== \"daniele_c\" Float 1 AAAAAA== \"daniele_c_d\" Float 1 AAAAAA== \"daniele_w_g\" Float 1 AAAAAA== \"daniele_t_1\" Float 1 AAAAAA== \"daniele_r_hit_min\" Float 1 AAAAAA== \"daniele_r_hit_max\" Float 1 AAAAAA== \"catDataSelection\" Int 1 AAAAAA== \"rxy\" Float 2 AAAAAAAAAAA= \"gxy\" Float 2 AAAAAAAAAAA= \"bxy\" Float 2 AAAAAAAAAAA= \"wxy\" Float 2 AAAAAAAAAAA= \"ra\" Float 1 AAAAAA== \"ba\" Float 1 AAAAAA== \"XYZ_w\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"XYZ_w_scaler\" Float 1 AAAAAA== \"L_A\" Float 1 AAAAAA== \"Y_b\" Float 1 AAAAAA== \"L_B\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"userSurround\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"discount_illuminant\" Bool 1 AA== \"L_A_out\" Float 1 AAAAAA== \"Y_b_out\" Float 1 AAAAAA== 71 \"encodingIn\" 1 1 \"primariesIn\" 1 1 \"toneScaleMode\" 1 1 \"discountIlluminant_in\" 1 1 \"discountIlluminant_mid\" 1 1 \"discountIlluminant_out\" 1 1 \"HK_mode_in\" 1 1 \"HK_mode_mid\" 1 1 \"HK_mode_out\" 1 1 \"compressMode\" 1 1 \"referenceLuminance\" 1 1 \"backgroundLuminance\" 1 1 \"viewingConditions\" 1 1 \"outputViewingConditions\" 1 1 \"applyTonecurve\" 1 1 \"sstsLuminance\" 3 1 \"applyChromaCompression\" 1 1 \"chromaCParams\" 3 1 \"cc_et\" 1 1 \"crxy\" 2 1 \"cgxy\" 2 1 \"cbxy\" 2 1 \"cwxy\" 2 1 \"sat\" 1 1 \"primariesLimit\" 1 1 \"applyGamutCompression\" 1 1 \"cuspMidBlend\" 1 1 \"focusDistance\" 1 1 \"compressionFuncParams\" 4 1 \"sixAxisCompressionMode\" 1 1 \"compressionFuncParamsR\" 4 1 \"compressionFuncParamsY\" 4 1 \"compressionFuncParamsG\" 4 1 \"compressionFuncParamsC\" 4 1 \"compressionFuncParamsB\" 4 1 \"compressionFuncParamsM\" 4 1 \"smoothCusps\" 1 1 \"encodingOut\" 1 1 \"primariesOut\" 1 1 \"clampOutput\" 1 1 \"softclampOutput\" 1 1 \"clamp_thr\" 1 1 \"clamp_dist\" 1 1 \"invert\" 1 1 \"diagnosticMode\" 1 1 \"mmScaleFactor\" 1 1 \"daniele_n\" 1 1 \"daniele_n_r\" 1 1 \"daniele_g\" 1 1 \"daniele_c\" 1 1 \"daniele_c_d\" 1 1 \"daniele_w_g\" 1 1 \"daniele_t_1\" 1 1 \"daniele_r_hit_min\" 1 1 \"daniele_r_hit_max\" 1 1 \"catDataSelection\" 1 1 \"rxy\" 2 1 \"gxy\" 2 1 \"bxy\" 2 1 \"wxy\" 2 1 \"ra\" 1 1 \"ba\" 1 1 \"XYZ_w\" 3 1 \"XYZ_w_scaler\" 1 1 \"L_A\" 1 1 \"Y_b\" 1 1 \"L_B\" 3 1 \"userSurround\" 3 1 \"discount_illuminant\" 1 1 \"L_A_out\" 1 1 \"Y_b_out\" 1 1 47 \"HALF_MINIMUM\" Float 1 1 AAAAAA== \"HALF_MAXIMUM\" Float 1 1 AAAAAA== \"CAT_CAT16\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"panlrcm\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"daniele_r_hit\" Float 1 1 AAAAAA== \"daniele_m_0\" Float 1 1 AAAAAA== \"daniele_m_1\" Float 1 1 AAAAAA== \"daniele_u\" Float 1 1 AAAAAA== \"daniele_m\" Float 1 1 AAAAAA== \"daniele_w_i\" Float 1 1 AAAAAA== \"daniele_c_t\" Float 1 1 AAAAAA== \"daniele_g_ip\" Float 1 1 AAAAAA== \"daniele_g_ipp2\" Float 1 1 AAAAAA== \"daniele_w_2\" Float 1 1 AAAAAA== \"daniele_s_2\" Float 1 1 AAAAAA== \"daniele_u_2\" Float 1 1 AAAAAA== \"daniele_m_2\" Float 1 1 AAAAAA== \"scaleM\" Float 1 1 AAAAAA== \"nJ_exp\" Float 1 1 AAAAAA== \"st2084_m_1\" Float 1 1 AAAAAA== \"st2084_m_2\" Float 1 1 AAAAAA== \"st2084_c_1\" Float 1 1 AAAAAA== \"st2084_c_2\" Float 1 1 AAAAAA== \"st2084_c_3\" Float 1 1 AAAAAA== \"st2084_m_1_d\" Float 1 1 AAAAAA== \"st2084_m_2_d\" Float 1 1 AAAAAA== \"st2084_L_p\" Float 1 1 AAAAAA== \"identity_matrix\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"XYZ_to_RGB_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_input\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_limit\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"RGB_to_XYZ_output\" Float 9 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"d65White\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"inWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"outWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"refWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"limitWhite\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"boundaryRGB\" Float 1 1 AAAAAA== \"limitJmax\" Float 1 1 AAAAAA== \"midJ\" Float 1 1 AAAAAA== \"gamut_gamma\" Float 1 1 AAAAAA== \"gamutCuspTableSize\" Int 1 1 AAAAAA== \"gamutCuspTableUnsorted\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"gamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \"cgamutCuspTable\" Float 3 360 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  kernelSource "\nkernel DRT_CAM_Kernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //\n    // Input Parameters\n    //\n\n    // Encoding of the Input Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingIn;\n\n    // Primaries of the Input Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesIn;\n\n    // Tonescale mode\n    // 0: Linear\n    // 1: Daniele Evo Curve\n    int toneScaleMode;\n\n    // Disable Degree of Adaptation Model for Zhai2018 CAT\n    // This is only effective if the limit primaries have a non-D65 white point\n    // since the input conversion is assumed to be fully adapted\n    // and the output conversion does not apply a CAT\n    bool discountIlluminant_in;\n    bool discountIlluminant_mid;\n    bool discountIlluminant_out;\n\n    // Toggles for Hellwig 2022 specific params\n    bool HK_mode_in;\n    bool HK_mode_mid;\n    bool HK_mode_out;\n    int compressMode;\n\n    // Reference Luminance in Cd/sqm\n    float referenceLuminance;\n\n    // Background Luminance in Cd/sqm\n    float backgroundLuminance;\n\n    // Viewing Conditions (for output)\n    // 0: Dark\n    // 1: Dim\n    // 2: Average\n    int viewingConditions;\n    int outputViewingConditions;\n\n    // Toggle  Tone Mapping\n    bool applyTonecurve;\n    \n    // SSTS Luminances Min/Mid/Peak\n    float3 sstsLuminance;\n\n    // Toggle chroma compression\n    bool applyChromaCompression;\n\n    // Chroma compression params (limit, k1, k2)\n    float3 chromaCParams;\n    int cc_et;\n    // xy coordintes for chroma compression gamut\n    float2 crxy;\n    float2 cgxy;\n    float2 cbxy;\n    float2 cwxy;\n\n    // Global saturation\n    float sat;\n\n    //\n    // Gamut Mapping Parameters\n    //\n\n    // Primaries of the Target Gamut\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesLimit;\n\n\n    // Toggle Gamut Compression\n    bool applyGamutCompression;\n\n    // Blend Between Compressing towards\n    // Target Gamut Cusp Luminance (0.0)\n    // and SSTS Mid Luminance (1.0)\n    float cuspMidBlend;\n\n    // Focus distance of the compression focal point from the achromatic axis\n    float focusDistance;\n\n    // Gamut Compression Fuction Parameters\n    // Threshold / min Limit / max Limit / Power\n    float4 compressionFuncParams;\n    bool sixAxisCompressionMode;\n    float4 compressionFuncParamsR;\n    float4 compressionFuncParamsY;\n    float4 compressionFuncParamsG;\n    float4 compressionFuncParamsC;\n    float4 compressionFuncParamsB;\n    float4 compressionFuncParamsM;\n\n\n    // How much the edges of the target RGB cube are smoothed when finding the gamut boundary \n    // in order to reduce visible contours at the gamut cusps\n    float smoothCusps;\n\n    //\n    // Output Parameters\n    //\n\n    // Encoding of the Output Image\n    // 0: Linear\n    // 1: ACEScct\n    // 2: sRGB\n    // 3: BT.1886 (Gamma 2.4)\n    // 4: Gamma 2.6\n    // 5: ST2084\n    int encodingOut;\n\n    // Primaries of the Output Image\n    // 0: AP0-ACES\n    // 1: AP1-ACES\n    // 2: sRGB/Rec.709-D65\n    // 3: Rec.2020-D65\n    // 4: P3-D65\n    // 5: P3-DCI\n    int primariesOut;\n\n    // Clamp output values to 0.0 - 1.0\n    bool clampOutput;\n    bool softclampOutput;\n    float clamp_thr;\n    float clamp_dist;\n\n    //\n    // Extra Parameters\n    //\n\n    // Toggle Inverse Transform\n    bool invert;\n    // Diagnostic path modes\n    int diagnosticMode;\n\n    // DanieleEvoCurve (ACES2 candidate) parameters\n    float mmScaleFactor;\n    float daniele_n; // peak white  \n    float daniele_n_r;    // Normalized white in nits (what 1.0 should be)\n    float daniele_g;      // surround / contrast\n    float daniele_c;      // scene-referred grey\n    float daniele_c_d;    // display-referred grey (in nits)\n    float daniele_w_g;    // grey change between different peak luminance\n    float daniele_t_1;     // shadow toe, flare/glare compensation - how ever you want to call it\n    float daniele_r_hit_min;  // Scene-referred value \"hitting the roof\" at 100 nits\n    float daniele_r_hit_max;  // Scene-referred value \"hitting the roof\" at 10,000 nits\n\n    // Hellwig 2022 CAM params\n    // the kernel parameters\n\n    // 0 = Stock CAT16\n    // 1 = Thomas's custom primaries\n    // 2 = live from params below\n    int catDataSelection; // original vs modified CAT16 matrix\n    // xy coordintes for custom CAT matrix\n    float2 rxy;\n    float2 gxy;\n    float2 bxy;\n    float2 wxy;\n    float ra;\n    float ba;\n \n    // Input vars\n    float3 XYZ_w;\n    float XYZ_w_scaler;\n    float L_A;\n    float Y_b;\n    float3 L_B;\n    float3 userSurround;\n    bool discount_illuminant;\n    // Output vars\n    float L_A_out;\n    float Y_b_out;\n\n\n  local:\n\n    // constants\n    float HALF_MINIMUM;\n    float HALF_MAXIMUM;\n\n    // Hellwig 2022 constants\n    float3x3 CAT_CAT16;\n    float3x3 panlrcm;\n\n    float daniele_r_hit;\n    float daniele_m_0;\n    float daniele_m_1;\n    float daniele_u;\n    float daniele_m;\n    float daniele_w_i;\n    float daniele_c_t;\n    float daniele_g_ip;\n    float daniele_g_ipp2;\n    float daniele_w_2;\n    float daniele_s_2;\n    float daniele_u_2;\n    float daniele_m_2;\n\n    // Chroma compression pre-calculated constants\n    float scaleM;     // Tonescale based M scaling factor\n    float nJ_exp;     // Tonescale based J exponent\n\n    // ST2084 vars\n    float st2084_m_1;\n    float st2084_m_2;\n    float st2084_c_1;\n    float st2084_c_2;\n    float st2084_c_3;\n    float st2084_m_1_d;\n    float st2084_m_2_d;\n    float st2084_L_p;\n\n    // using the float3x3 type to store the array of 6 coefficients\n    // because Blink does not support generic array assignments\n\n    // matrix vars\n    float3x3 identity_matrix;\n\n    float3x3 XYZ_to_RGB_input;\n    float3x3 XYZ_to_RGB_limit;\n    float3x3 XYZ_to_RGB_output;\n\n    float3x3 RGB_to_XYZ_input;\n    float3x3 RGB_to_XYZ_limit;\n    float3x3 RGB_to_XYZ_output;\n\n    // white points\n    float3 d65White;\n    float3 inWhite;\n    float3 outWhite;\n    float3 refWhite;\n    float3 limitWhite;\n\n    // the maximum RGB value of the limiting gamut\n    float boundaryRGB;\n\n    // the maximum lightness value of the limiting gamut\n    float limitJmax;\n\n    // Middle gray J\n    float midJ;\n\n    // Gamut intersection line gamma\n    float gamut_gamma;\n\n    // the 1D LUT used for quickly findig the approximate limiting gamut cusp JMh coordinates\n    // the samples are spaced by HSV hue increments of the limiting RGB gamut\n    // so to find the correct entry for a given CAM hue (h) value \n    // one must search the table entries for the matching entry.z component\n    int gamutCuspTableSize;\n\n    // the 'gamutCuspTableUnsorted' table is populated\n    // in increments of H of the limiting gamut HSV space starting at H=0.0\n    // since it is unlikely that HSV.H=0 and JMh.h=0 line up\n    // the entries are then wrap-around shifted\n    // so that the 'gamutCuspTable' starts with the lowest JMh.h value\n    // both tables need to be declared here since temporary array variables\n    // in the init() fuction seem to crash Nuke on some systems\n    float3 gamutCuspTableUnsorted\[360];\n    float3 gamutCuspTable\[360];\n    float3 cgamutCuspTable\[360];\n\n  void define()\n  \{\n\n  \}\n\n  // multiplies a 3D vector with a 3x3 matrix\n  float3 vector_dot( float3x3 m, float3 v)\n  \{\n    float3 r = 1.0f;\n    for(int c = 0; c<3; c++)\n    \{\n      r\[c] = m\[c]\[0]*v.x + m\[c]\[1]*v.y + m\[c]\[2]*v.z;\n    \}\n\n    return r;\n  \}\n\n  // linear interpolation between two values a & b with the bias t\n  float lerp(float a, float b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // linear interpolation between two float4 values a & b with the bias t\n  float4 lerp4(float4 a, float4 b, float t)\n  \{\n    return a + t * (b - a);\n  \}\n\n  // \"safe\" power function to avoid NANs or INFs when taking a fractional power of a negative base\n  // this one initially returned -pow(abs(b), e) for negative b\n  // but this ended up producing undesirable results in some cases\n  // so now it just returns 0.0 instead\n  float spow( float base, float exponent )\n  \{\n    // a = np.atleast_1d(a)\n    float a = base;\n    float b = exponent;\n    // // p = as_float_array(p)\n\n    // float a_p = sign(a) * pow(  fabs(a) ,p)  ; \n\n    // // a_p\[np.isnan(a_p)] = 0\n\n    // return a_p;\n\n    // np.sign(a) * pow(np.abs(a) , b) \n\n    // float a_p =  sign(a) * pow(fabs(a) , b) ;\n    // if ( isnan(a_p) )\n    // \{\n    //     a_p = a_p;\n    // \}\n    // else \n    // \{\n    //     a_p = 0.0;\n    // \}\n    // return a_p;\n\n    if(base < 0.0f && exponent != floor(exponent) )\n    \{\n      return 0.0f;\n    \}\n    else\n    \{\n     return pow(base, exponent); \n    \}\n  \}\n\n\n  // clamp the components of a 3D vector between a min & max value\n  float3 clamp3(float3 v, float min, float max)\n  \{\n    v.x = clamp(v.x, min, max);\n    v.y = clamp(v.y, min, max);\n    v.z = clamp(v.z, min, max);\n    return v;\n  \}\n\n\n  float3 float3spow( float3 base, float exponent )\n  \{\n      return float3(spow(base.x, exponent), spow(base.y, exponent), spow(base.z, exponent));\n  \}\n\n  float3 float3sign( float3 v )\n  \{\n      return float3(sign(v.x), sign(v.y), sign(v.z));\n  \}\n\n\n  float3 float3abs( float3 a )\n  \{\n    return fabs(a);\n  \}\n\n\n\n    // \"safe\" div\n    float sdiv( float a, float b )\n    \{\n        if(b == 0.0f)\n        \{\n        return 0.0f;\n        \}\n        else\n        \{\n        return a / b;\n        \}\n    \}\n    \n  float clip(float x, float a, float b)\n  \{\n    return max(a, min(x, b));\n  \}\n\n  float mod(float a, float N)\n  \{\n    return a - N*floor(a/N);\n  \} \n\n  float degree_of_adaptation(float  F, float L_A )\n  \{\n    float D = F * (1 - (1 / 3.6) * exp((-L_A - 42) / 92));\n\n    return D;\n  \}\n\n  // convert radians to degrees\n  float degrees( float radians )\n  \{\n    return radians * 180.0f / PI;\n  \}\n\n\n  // convert degrees to radians\n  float radians( float degrees )\n  \{\n    return degrees / 180.0f * PI;\n  \}\n\n  float3 compress_aces(float3 rgb, float3 c, float3 m, float3 y, int invert)\n  \{\n    float ach = max(rgb.x, max(rgb.y, rgb.z));\n    float3 d = 0.0f;\n\n    if (ach)\n    \{\n      d.x = (ach - rgb.x) / fabs(ach);\n      d.y = (ach - rgb.y) / fabs(ach);\n      d.z = (ach - rgb.z) / fabs(ach);\n    \}\n\n    rgb.x = compressPowerP(d.x, c.x, c.y, c.z, invert);\n    rgb.y = compressPowerP(d.y, m.x, m.y, m.z, invert);\n    rgb.z = compressPowerP(d.z, y.x, y.y, y.z, invert);\n\n    rgb = ach - rgb * fabs(ach);\n\n    return rgb;\n  \}\n\n  float3 compress_bjorn(float3 xyz)\n  \{\n    float x = xyz.x;\n    float y = xyz.y;\n    float z = xyz.z;\n\n    float C = (x+y+z)/3;\n    if (C == 0.0f)\n      return xyz;\n\n    float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2)) ;\n    // np.sqrt(2/3)\n    // 0.816496580927726\n    R = R * 0.816496580927726;\n\n    if (R != 0.0)\n    \{\n      x = (x-C)/R ;\n      y = (y-C)/R ;\n      z = (z-C)/R ;\n    \}\n\n    float r = R/C ;\n    float s = -min(x, min(y, z));\n\n    float t = 0.0;\n    if (r > 0.000001f)\n    \{\n      t = (0.5+spow((spow((s-0.5),2) + spow((sqrt(4/spow(r,2)+1)-1),2)/4),0.5));\n      if (t < 0.000001f)\n        return xyz;\n      t = 1/t;\n    \}\n\n    x = C*x*t + C ;\n    y = C*y*t + C ;\n    z = C*z*t + C ;\n\n    return float3(x,y,z);\n  \}\n\nfloat3 uncompress_bjorn(float3 xyz)\n\{\n  float x = xyz.x;\n  float y = xyz.y;\n  float z = xyz.z;\n\n  float C = (x+y+z)*(1.0/3.0) ;\n  if (C == 0.0)\n    return xyz;\n\n  float R = sqrt(spow((x-C),2) + spow((y-C),2) + spow((z-C),2));\n  // np.sqrt(2/3)\n  // 0.816496580927726\n  R = R * 0.816496580927726;\n\n  if (R != 0.0)\n  \{\n    x = (x-C)/R ;\n    y = (y-C)/R ;\n    z = (z-C)/R ;\n  \}\n\n  float t = R/C ;\n  float s = -min(x, min(y, z));\n\n  float r = 0.0;\n  if (t > 0.000001f)\n  \{\n    r = sqrt(spow((2*sqrt(spow((1/t-0.5),2)-spow((s-0.5),2))+1),2)-1);\n    if (r < 0.000001f)\n      return xyz;\n    r = 2/r;\n  \}\n\n  x = C*x*r + C ;\n  y = C*y*r + C ;\n  z = C*z*r + C ;\n\n  return float3(x,y,z);\n\}\n\n  float3 compress(float3 rgb)\n  \{\n    return compress_bjorn(rgb);\n  \}\n\n  float3 uncompress(float3 rgb)\n  \{\n    return uncompress_bjorn(rgb);\n  \}\n\n  float hue_angle_dependency_Hellwig2022(float h)\n  \{\n    // h = as_float_array(h)\n    return float(         \\\n     -0.160 * cos(h)      \\\n    + 0.132 * cos(2 * h)  \\\n    - 0.405 * sin(h)      \\\n    + 0.080 * sin(2 * h)  \\ \n    + 0.792               \\\n    );\n    \}\n\n\n  float3x3  RGBPrimsToXYZMatrix(float2 rxy, float2 gxy, float2 bxy, float2 wxy,float Y, bool direction)\n  \{\n    // # given r g b chromaticities and whitepoint, convert RGB colors to XYZ\n    // # based on CtlColorSpace.cpp from the CTL source code : 77\n    // # param: xy - dict of chromaticity xy coordinates: rxy: float2(x, y) etc\n    // # param: Y - luminance of \"white\" - defaults to 1.0\n    // # param: inverse - calculate XYZ to RGB instead\n\n    float2 r = rxy;\n    float2 g = gxy;\n    float2 b = bxy;\n    float2 w = wxy;\n\n    float X = w.x * Y / w.y;\n    float Z = (1 - w.x - w.y) * Y / w.y;\n\n    // # Scale factors for matrix rows\n    float d = r.x * (b.y - g.y) + b.x * (g.y - r.y) + g.x * (r.y - b.y);\n\n    float Sr =    (X * (b.y - g.y) -      \\\n            g.x * (Y * (b.y - 1.0f) +  \\\n            b.y  * (X + Z)) +       \\\n            b.x  * (Y * (g.y - 1.0f) + \\\n            g.y * (X + Z))) / d ;\n    \n    float Sg =    (X * (r.y - b.y) +      \\\n            r.x * (Y * (b.y - 1.0f) +  \\\n            b.y * (X + Z)) -        \\\n            b.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    float Sb =    (X * (g.y - r.y) -      \\\n            r.x * (Y * (g.y - 1.0f) +  \\\n            g.y * (X + Z)) +        \\\n            g.x * (Y * (r.y - 1.0f) +  \\\n            r.y * (X + Z))) / d ;\n\n    // # Assemble the matrix\n    float Mdata\[] =\n    \{\n            Sr * r.x, Sr * r.y, Sr * (1.0f - r.x - r.y),\n            Sg * g.x, Sg * g.y, Sg * (1.0f - g.x - g.y),\n            Sb * b.x, Sb * b.y, Sb * (1.0f - b.x - b.y),\n    \};\n\n    float MdataNukeOrder\[] = \{\n      Mdata\[0], Mdata\[3], Mdata\[6],\n      Mdata\[1], Mdata\[4], Mdata\[7],\n      Mdata\[2], Mdata\[5], Mdata\[8],\n    \};\n\n    float3x3 newMatrix;\n    newMatrix.setArray(MdataNukeOrder);\n\n    // create inverse matrix\n    float3x3 newMatrixInverse = newMatrix.invert();\n\n    // return forward or inverse matrix\n    if (direction == 0)\n    \{\n      return newMatrix;\n    \}\n    else if (direction == 1)\n    \{\n      return newMatrixInverse;\n    \}\n  \}\n\n  float3 viewingConditionsToSurround(int viewingConditions)\n  \{\n      float3 newSurround;\n      // hack to turn incoming int value into surround coeffs\n      if (viewingConditions == 0)\n      \{\n          // \"Dark\": InductionFactors_CIECAM02(0.8, 0.525, 0.8),\n          newSurround = float3(0.8, 0.525, 0.8);\n      \}\n      else if (viewingConditions == 1)\n      \{\n          // \"Dim\": InductionFactors_CIECAM02(0.9, 0.59, 0.9),\n          newSurround = float3(0.9, 0.59, 0.9);\n      \}\n      else if (viewingConditions == 2)\n      \{\n          // \"Average\": InductionFactors_CIECAM02(1, 0.69, 1),\n          newSurround = float3(1.0, 0.69, 1.0);\n      \}\n      else if (viewingConditions == 3)\n      \{\n          // Pull from external input\n          newSurround = userSurround;\n      \}\n      return newSurround;\n  \}\n\n  // \"PowerP\" compression function (also used in the ACES Reference Gamut Compression transform)\n  // values of v above  'treshold' are compressed by a 'power' function\n  // so that an input value of 'limit' results in an output of 1.0\n  float compressPowerP( float v, float threshold, float limit, float power, int inverse )\n  \{\n    float s = (limit-threshold)/pow(pow((1.0f-threshold)/(limit-threshold),-power)-1.0f,1.0f/power);\n\n    float vCompressed;\n\n    if( inverse )\n    \{\n      vCompressed = (v<threshold||limit<1.0001f||v>threshold+s)?v:threshold+s*pow(-(pow((v-threshold)/s,power)/(pow((v-threshold)/s,power)-1.0f)),1.0f/power);\n    \}\n    else\n    \{\n      vCompressed = (v<threshold||limit<1.0001f)?v:threshold+s*((v-threshold)/s)/(pow(1.0f+pow((v-threshold)/s,power),1.0f/power));\n    \}\n\n    return vCompressed;\n  \}\n\n  // convert XYZ tristimulus values to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 XYZ_to_JMh( float3 XYZ, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    return XYZ_to_Hellwig2022_JMh(XYZ, referenceWhite, L_A, Y_b,viewingConditionsToSurround(viewingConditions),discountIlluminant,HK_mode);\n  \}\n\n  // convert the CAM J (lightness), M (colorfulness) and h (hue) correlates to XYZ tristimulus values\n  // needs XYZ tristimulus values for the reference white and a D65 white as well as the viewing conditions as parameters\n  float3 JMh_to_XYZ( float3 JMh, float3 referenceWhite, float3 d65White, int viewingConditions , float L_A, float Y_b, bool discountIlluminant, bool HK_mode)\n  \{\n    float3 XYZ;\n    XYZ = Hellwig2022_JMh_to_XYZ(JMh, referenceWhite, L_A, Y_b, viewingConditionsToSurround(viewingConditions), discountIlluminant,HK_mode);\n    return XYZ;\n  \}\n\n  // convert ACEScct encoded values to linear\n  float ACEScct_to_linear( float v )\n  \{\n    return v > 0.155251141552511f ? spow( 2.0f, v * 17.52f - 9.72f) : (v - 0.0729055341958355f) / 10.5402377416545f;\n  \}\n\n  // encode linear values as ACEScct\n  float linear_to_ACEScct( float v )\n  \{\n    return v > 0.0078125f ? (log2(v) + 9.72f) / 17.52f : 10.5402377416545f * v + 0.0729055341958355f;\n  \}\n\n\n  // convert sRGB gamma encoded values to linear\n  float sRGB_to_linear( float v )\n  \{\n    return v < 0.04045f ? v / 12.92f : spow((v + 0.055f) / 1.055f, 2.4f);\n  \}\n\n  // encode linear values as sRGB gamma\n  float linear_to_sRGB( float v )\n  \{\n    return v <= 0.0031308f ? 12.92f * v : 1.055 * (spow(v, 1.0f / 2.4f)) - 0.055f;\n  \}\n\n  // convert ST2084 PQ encoded values to linear\n  float ST2084_to_linear( float v )\n  \{\n    float V_p = spow(v, st2084_m_2_d);\n    return spow((max(0.0f, V_p - st2084_c_1) / (st2084_c_2 - st2084_c_3 * V_p)), st2084_m_1_d)*st2084_L_p;\n  \}\n\n  // encode linear values as ST2084 PQ\n  float linear_to_ST2084( float v )\n  \{\n    float Y_p = spow(max(0.0f, v) / st2084_L_p, st2084_m_1);\n\n    return spow((st2084_c_1 + st2084_c_2 * Y_p) / (st2084_c_3 * Y_p + 1.0f), st2084_m_2);\n  \}\n\n  // decode value 'v' with the inverse of the selected encoding fuction to luminance\n  float encodingToLuminance(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return ACEScct_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return sRGB_to_linear(v) * referenceLuminance;\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v, 2.4f) * referenceLuminance;\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v, 2.6f) * referenceLuminance;\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return ST2084_to_linear(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v * referenceLuminance;\n    \}\n  \}\n\n  // decode the components of a 3D vector 'v' with the inverse of the selected encoding fuction to luminance\n  float3 encodingToLuminance3(int encoding, float3 v)\n  \{\n    float3 lin;\n    lin.x = encodingToLuminance(encoding, v.x);\n    lin.y = encodingToLuminance(encoding, v.y);\n    lin.z = encodingToLuminance(encoding, v.z);\n\n    return lin;\n  \}\n\n  // encode the linear luminance value 'v' with the encoding fuction selected by 'encoding'\n  float luminanceToEncoding(int encoding, float v)\n  \{\n    if( encoding == 1 )\n    \{\n      // ACEScct\n      return linear_to_ACEScct(v / referenceLuminance);\n    \}\n    else if( encoding == 2 )\n    \{\n      // sRGB\n      return linear_to_sRGB(v / referenceLuminance);\n    \}\n    else if( encoding == 3 )\n    \{\n      // BT.1886 (Gamma 2.4)\n      return spow(v / referenceLuminance, 1.0f/2.4f);\n    \}\n    else if( encoding == 4 )\n    \{\n      // Gamma 2.6\n      return spow(v / referenceLuminance, 1.0f/2.6f);\n    \}\n    else if( encoding == 5 )\n    \{\n      // ST2084\n      return linear_to_ST2084(v);\n    \}\n    else\n    \{\n      // Linear\n      // default\n      return v / referenceLuminance;\n    \}\n  \}\n\n  // encode the linear luminance value components of a 3D vector 'v' with the encoding fuction selected by 'encoding'\n  float3 luminanceToEncoding3(int encoding, float3 v)\n  \{\n    float3 enc;\n    enc.x = luminanceToEncoding(encoding, v.x);\n    enc.y = luminanceToEncoding(encoding, v.y);\n    enc.z = luminanceToEncoding(encoding, v.z);\n\n    return enc;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 output_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = encodingToLuminance3(encodingOut, RGB);\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, limitWhite, d65White, viewingConditions, L_A_out, Y_b_out, discountIlluminant_out,HK_mode_out);\n    return JMh;\n  \}\n\n  // convert RGB values in the output colorspace to the CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 luminance_RGB_to_JMh(float3 luminanceRGB)\n  \{\n    float3 XYZ = vector_dot(RGB_to_XYZ_output, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, outputViewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_output_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, limitWhite, d65White, outputViewingConditions , L_A_out, Y_b_out, discountIlluminant_out, HK_mode_out);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n    if( softclampOutput )\n    \{\n      // Soft clamp by compressing negative display linear values\n      float3 compr = float3(clamp_thr, clamp_dist, 1.2f);\n      luminanceRGB = compress_aces(luminanceRGB, compr, compr, compr, 0);\n    \}\n\n    float3 outputRGB = luminanceToEncoding3( encodingOut, luminanceRGB);\n\n    if( clampOutput )\n    \{\n      outputRGB = clamp3(outputRGB, 0.0f, 1.0f);\n    \}\n\n    return outputRGB;\n  \}\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to  RGB values in the output colorspace\n  float3 JMh_to_luminance_RGB(float3 JMh)\n  \{\n      float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, outputViewingConditions , L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n      float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n\n      return luminanceRGB;\n  \}\n\n\n  // convert linear RGB values with the limiting primaries to CAM J (lightness), M (colorfulness) and h (hue) correlates\n  float3 limit_RGB_to_JMh(float3 RGB)\n  \{\n    float3 luminanceRGB = RGB * boundaryRGB *referenceLuminance;\n    float3 XYZ = vector_dot(RGB_to_XYZ_limit, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(XYZ, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid);\n    return JMh;\n  \}\n\n\n  // convert CAM J (lightness), M (colorfulness) and h (hue) correlates to linear RGB values with the limiting primaries\n  float3 JMh_to_limit_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, refWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_mid, HK_mode_mid );\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_output, luminanceXYZ);\n    float3 RGB = luminanceRGB / boundaryRGB / referenceLuminance;\n    return RGB;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_forward(float3 RGB, float F_L)\n  \{\n      float3 F_L_RGB = float3spow(F_L * float3abs(RGB) / 100.0f, 0.42f);\n      float3 RGB_c = (400.0f * sign(RGB) * F_L_RGB) / (27.13f + F_L_RGB);\n      return RGB_c;\n  \}\n\n  float3 post_adaptation_non_linear_response_compression_inverse(float3 RGB,float F_L)\n  \{\n      float3 RGB_p =  (float3sign(RGB) * 100.0f / F_L * float3spow((27.13f * float3abs(RGB)) / (400.0f - float3abs(RGB)), 1.0f / 0.42f) );\n      return RGB_p;\n  \}\n\n  // XYZ to Hellwig2020 JMh\n  //\n  //     XYZ\n  //         *CIE XYZ* tristimulus values of test sample / stimulus.\n  //     XYZ_w\n  //         *CIE XYZ* tristimulus values of reference white.\n  //     L_A\n  //         Adapting field *luminance* :math:`L_A` in :math:`cd/m^2`, (often taken\n  //         to be 20% of the luminance of a white object in the scene).\n  //     Y_b\n  //         Luminous factor of background :math:`Y_b` such as\n  //         :math:`Y_b = 100 x L_b / L_w` where :math:`L_w` is the luminance of the\n  //         light source and :math:`L_b` is the luminance of the background. For\n  //         viewing images, :math:`Y_b` can be the average :math:`Y` value for the\n  //         pixels in the entire image, or frequently, a :math:`Y` value of 20,\n  //         approximate an :math:`L^*` of 50 is used.\n  //     surround\n  //         Surround viewing conditions induction factors.\n  //         Truth value indicating if the illuminant should be discounted.\n  //     discount_illuminant\n  //\n  // NOTE: Following modifications have been made to stock Hellwig2022 model for this DRT:\n  //\n  // - Custom primaries\n  // - Eccentriticty factor has been removed\n  // - Compress mode\n  //\n  float3 XYZ_to_Hellwig2022_JMh( float3 XYZ, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        XYZ_w = XYZ_w * XYZ_w_scaler;\n        float _X_w = XYZ_w.x ;\n        float Y_w = XYZ_w.y ;\n        float _Z_w = XYZ_w.z ;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        // # Step 1\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB = vector_dot(MATRIX_16, XYZ)\n\n        float3 RGB = vector_dot(MATRIX_16, XYZ);\n        // float3 RGB = XYZ;\n\n        // # Step 2\n        // RGB_c = D_RGB * RGB\n        float3 RGB_c = D_RGB * RGB;\n\n        // # Step 3\n        // # Applying forward post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_c = compress(RGB_c);\n        \}\n\n        float3 RGB_a = post_adaptation_non_linear_response_compression_forward(RGB_c, F_L);\n\n        if (compressMode)\n        \{\n          RGB_a = uncompress(RGB_a);\n        \}\n\n        // # Step 4\n        // # Converting to preliminary cartesian coordinates.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a = RGB_a.x ;\n        float G_a = RGB_a.y ;\n        float B_a = RGB_a.z ;\n        // a = R_a - 12 * G_a / 11 + B_a / 11\n        float a = R_a - 12.0f * G_a / 11.0f + B_a / 11.0f;\n        // b = (R_a + G_a - 2 * B_a) / 9\n        float b = (R_a + G_a - 2.0f * B_a) / 9.0f;\n\n        // # Computing the *hue* angle :math:`h`.\n        // h = np.degrees(np.arctan2(b, a)) % 360\n        // Unclear why this isnt matching the python version.\n        float h = mod(degrees(atan2(b, a)), 360.0f);\n\n        float hr = radians(h);\n\n        // # Step 6\n        // # Computing achromatic responses for the stimulus.\n        // R_a, G_a, B_a = tsplit(RGB_a)\n        float R_a2 = RGB_a.x ;\n        float G_a2 = RGB_a.y ;\n        float B_a2 = RGB_a.z ;\n\n        // A = 2 * R_a + G_a + 0.05 * B_a - 0.305\n        float A = ra * R_a2 + G_a2 + ba * B_a2;\n\n        // # Step 7\n        // # Computing the correlate of *Lightness* :math:`J`.\n        // with sdiv_mode():\n        //     J = 100 * spow(sdiv(A, A_w), surround.c * z)\n\n        float J = 100.0f * spow(sdiv(A, A_w), surround.y * z);\n\n        // # Step 8\n        // # Computing the correlate of *brightness* :math:`Q`.\n        // with sdiv_mode():\n        //     Q = (2 / as_float(surround.c)) * (J / 100) * A_w\n        float Q = (2.0f / float(surround.y)) * (J / 100.0f) * A_w;\n\n        // # Step 9\n        // # Computing the correlate of *colourfulness* :math:`M`.\n        // M = 43 * surround.N_c * e_t * np.sqrt(a**2 + b**2)\n        float M = 43.0f * surround.z * sqrt(a * a + b * b);\n\n        // # Computing the correlate of *chroma* :math:`C`.\n        // with sdiv_mode():\n        //     C = 35 * sdiv(M, A_w)\n        float C = 35.0f * sdiv(M, A_w);\n\n\n        // # Computing the correlate of *saturation* :math:`s`.\n        // with sdiv_mode():\n        //     s = 100 * sdiv(M, Q)\n        float s = 100.0f * sdiv(M, Q);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float J_HK = J + hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        float Q_HK = (2.0f / surround.y) * (J_HK / 100.0f) * A_w ;\n\n        if (HK_mode)\n        \{\n          return \{J_HK,M,h\};\n        \}\n        else\n        \{\n          if (J == 0.0f)\n            M = 0.0f;\n          return \{J,M,h\};\n        \}\n    \}\n\n    float3 Hellwig2022_JMh_to_XYZ( float3 JMh, float3 XYZ_w, float L_A, float Y_b, float3 surround, bool discountIlluminant, bool HK_mode)\n    \{\n        float J = JMh.x;\n        float M = JMh.y;\n        float h = JMh.z;\n        XYZ_w  = XYZ_w  * XYZ_w_scaler;\n  \n        // L_A = as_float_array(L_A)\n        // XYZ_w = to_domain_100(XYZ_w)\n        // _X_w, Y_w, _Z_w = tsplit(XYZ_w)\n        float _X_w = XYZ_w.x;\n        float Y_w = XYZ_w.y;\n        float _Z_w = XYZ_w.z;\n\n        // # Step 0\n        // # Converting *CIE XYZ* tristimulus values to sharpened *RGB* values.\n        // RGB_w = vector_dot(MATRIX_16, XYZ_w)\n        float3x3 MATRIX_16 = CAT_CAT16;\n        float3 RGB_w = vector_dot(MATRIX_16, XYZ_w);\n\n        // # Computing degree of adaptation :math:`D`.\n        float D = clip(degree_of_adaptation(surround.x, L_A), 0, 1);\n        if(discountIlluminant)\n        \{\n            D = 1.0f;\n        \}\n\n        // # Viewing conditions dependent parameters\n        float k = 1 / (5 * L_A + 1);\n        float k4 = pow(k,4);\n        float F_L = 0.2f * k4 * (5.0f * L_A) + 0.1f * pow((1.0f - k4), 2.0f) * spow(5.0f * L_A, 1.0f / 3.0f) ;\n        float n = sdiv(Y_b, Y_w);\n        float z = 1.48 + sqrt(n);\n\n        // // float D_RGB = ( D\[..., np.newaxis] * Y_w\[..., np.newaxis] / RGB_w + 1 - D\[..., np.newaxis] )\n        float3 D_RGB = D * Y_w / RGB_w + 1 - D;\n        float3 RGB_wc = D_RGB * RGB_w;\n\n        // # Applying forward post-adaptation non-linear response compression.\n        // F_L_RGB = spow(F_L\[..., np.newaxis] * np.absolute(RGB_wc) / 100, 0.42)\n        float3 F_L_RGB = float3spow(F_L * float3abs(RGB_wc) / 100.0f, 0.42f);\n\n        // # Computing achromatic responses for the whitepoint.\n        // RGB_aw = (400 * np.sign(RGB_wc) * F_L_RGB) / (27.13 + F_L_RGB) + 0.1\n        float3 RGB_aw = (400.0f * float3sign(RGB_wc) * F_L_RGB) / (27.13f + F_L_RGB);\n\n        // # Computing achromatic responses for the whitepoint.\n        // R_aw, G_aw, B_aw = tsplit(RGB_aw)\n        float R_aw = RGB_aw.x ;\n        float G_aw = RGB_aw.y ;\n        float B_aw = RGB_aw.z ;\n        // A_w = 2 * R_aw + G_aw + 0.05 * B_aw - 0.305\n        float A_w = ra * R_aw + G_aw + ba * B_aw;\n\n        float hr = radians(h);\n\n        // # *HelmholtzKohlrausch* Effect Extension.\n        float C = (M * 35) / A_w;\n        if (HK_mode)\n        \{\n          J = J - hue_angle_dependency_Hellwig2022(hr) * spow(C, 0.587f);\n        \}\n\n        // # Computing achromatic response :math:`A` for the stimulus.\n        // A = A = A_w * spow(J / 100, 1 / (surround.c * z))\n        float A = A_w * spow(J / 100.0f, 1.0f / (surround.y * z));\n\n        // # Computing *P_p_1* to *P_p_2*.\n        // P_p_1 = 43 * surround.N_c * e_t\n        // P_p_2 = A\n        float P_p_1 = 43.0f * surround.z;\n        float P_p_2 = A;\n\n\n        // # Step 3\n        // # Computing opponent colour dimensions :math:`a` and :math:`b`.\n        // with sdiv_mode():\n        //     gamma = M / P_p_1\n        float gamma = M / P_p_1;\n    \n        // a = gamma * np.cos(hr)\n        float a = gamma * cos(hr);\n        // b = gamma * np.sin(hr)\n        float b = gamma * sin(hr);\n\n\n        // # Step 4\n        // # Applying post-adaptation non-linear response compression matrix.\n        float3 RGB_a = vector_dot(panlrcm, float3(P_p_2, a, b)) / 1403.0f;\n\n        // # Step 5\n        // # Applying inverse post-adaptation non-linear response compression.\n\n        if (compressMode)\n        \{\n          RGB_a = compress(RGB_a);\n        \}\n\n        float3 RGB_c = post_adaptation_non_linear_response_compression_inverse(RGB_a, F_L);\n\n        if (compressMode)\n        \{\n          RGB_c = uncompress(RGB_c);\n        \}\n\n        // # Step 6\n        // RGB = RGB_c / D_RGB\n        float3 RGB = RGB_c / D_RGB;\n        \n    \n        // # Step 7\n        // XYZ = vector_dot(MATRIX_INVERSE_16, RGB)\n        float3x3 MATRIX_INVERSE_16 = CAT_CAT16.invert();\n        float3 XYZ = vector_dot(MATRIX_INVERSE_16, RGB);\n\n        return XYZ;\n    \}\n\n\n  // convert HSV cylindrical projection values to RGB\n  float3 HSV_to_RGB( float3 HSV )\n  \{\n    float C = HSV.z*HSV.y;\n    float X = C*(1.0f-fabs(fmod(HSV.x*6.0f,2.0f)-1.0f));\n    float m = HSV.z-C;\n\n    float3 RGB;\n    RGB.x = (HSV.x<1.0f/6.0f?  C :HSV.x<2.0f/6.0f?  X :HSV.x<3.0f/6.0f?0.0f:HSV.x<4.0f/6.0f?0.0f:HSV.x<5.0f/6.0f?  X :  C )+m;\n    RGB.y = (HSV.x<1.0f/6.0f?  X :HSV.x<2.0f/6.0f?  C :HSV.x<3.0f/6.0f?  C :HSV.x<4.0f/6.0f?  X :HSV.x<5.0f/6.0f?0.0f:0.0f)+m;\n    RGB.z = (HSV.x<1.0f/6.0f?0.0f:HSV.x<2.0f/6.0f?0.0f:HSV.x<3.0f/6.0f?  X :HSV.x<4.0f/6.0f?  C :HSV.x<5.0f/6.0f?  C :  X )+m;\n    return RGB;\n  \}\n\n\n  // convert RGB to HSV cylindrical projection values\n  float3 RGB_to_HSV( float3 RGB )\n  \{\n    float cmax = max(RGB.x,max(RGB.y,RGB.z));\n    float cmin = min(RGB.x,min(RGB.y,RGB.z));\n    float delta = cmax-cmin;\n\n    float3 HSV;\n    HSV.x = delta==0.0f?0.0f:cmax==RGB.x?(fmod((RGB.y-RGB.z)/delta+6.0f,6.0f))/6.0f:cmax==RGB.y?(((RGB.z-RGB.x)/delta+2.0f)/6.0f):(((RGB.x-RGB.y)/delta+4.0f)/6.0f);\n    HSV.y = cmax == 0.0f ? 0.0f : delta / cmax;\n    HSV.z = cmax;\n    return HSV;\n  \}\n\n\n  // retrieve the JM coordinates of the limiting gamut cusp at the hue slice 'h'\n  // cusps are very expensive to compute\n  // and the DRT is only using them for lightness mapping\n  // which does not require a high degree of accuracy\n  // so instead we use a pre-computed table of cusp points\n  // sampled at 1 degree hue intervals of the the RGB target gamut\n  // and lerp between them to get the approximate J & M values\n  float2 cuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= gamutCuspTable\[0].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = gamutCuspTable\[0];\n    \}\n    else if( h >= gamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = gamutCuspTable\[gamutCuspTableSize-1];\n      hi = gamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= gamutCuspTable\[i].z )\n        \{\n          lo = gamutCuspTable\[i-1];\n          hi = gamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float2 ccuspFromTable(float h)\n  \{\n\n    float3 lo;\n    float3 hi;\n\n    if( h <= cgamutCuspTable\[0].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      lo.z = lo.z-360.0f;\n      hi = cgamutCuspTable\[0];\n    \}\n    else if( h >= cgamutCuspTable\[gamutCuspTableSize-1].z )\n    \{\n      lo = cgamutCuspTable\[gamutCuspTableSize-1];\n      hi = cgamutCuspTable\[0];\n      hi.z = hi.z+360.f;\n    \}\n    else\n    \{\n      for(int i = 1; i < gamutCuspTableSize; ++i)\n      \{\n        if( h <= cgamutCuspTable\[i].z )\n        \{\n          lo = cgamutCuspTable\[i-1];\n          hi = cgamutCuspTable\[i];\n          break;\n        \}\n      \}\n    \}\n\n    float t = (h - lo.z) / (hi.z - lo.z);\n\n    float cuspJ = lerp(lo.x, hi.x, t);\n    float cuspM = lerp(lo.y, hi.y, t);\n\n    return float2(cuspJ,cuspM);\n  \}\n\n  float daniele_evo_fwd(float Y)\n  \{\n    float f = daniele_m_2 * pow(max(0.0f, Y) / (Y + daniele_s_2), daniele_g);\n    float h = max(0.0f, f * f / (f + daniele_t_1));\n\n    return h;\n  \}\n\n  float daniele_evo_rev(float Y)\n  \{\n    Y = max(0.0f, min(daniele_n / (daniele_u_2 * daniele_n_r), Y));\n    float h = (Y + sqrt(Y * (4.0f * daniele_t_1 + Y))) / 2.0f;\n    float f = daniele_s_2 / (pow((daniele_m_2 / h), (1.0f / daniele_g)) - 1.0f);\n\n    return f;\n  \}\n\n  // Returns saturation multiplier.  This boost saturation more for darker colors than\n  // for brighter colors.  It keeps noise floor and very deep shadows less saturated.\n  float sat_factor(float nJ, float origJ)\n  \{\n    float shadows = max(0.02f, 0.15f - 0.00025f * daniele_n);\n    float shdsat = sat + 1.0f * (1.0f - shadows);\n    float satmul = sat + 1.0f * (1.0f - nJ);\n    float shadowmul = lerp(0.01f, shdsat, min(1.0f, origJ / shadows));\n\n    return nJ > shadows ? satmul : shadowmul;\n  \}\n\n  // Return compression gamut cusp M scaled with an eccentricity factor\n  float cusp_with_eccentricity_factor(float h)\n  \{\n    float2 JMcusp = ccuspFromTable(h);\n    float e_t = 1.0f;\n\n    // CAM16\n    if (cc_et == 0)\n    \{\n      // NOTE: custom scaler 0.275 instead of 0.25 in CAM16\n      e_t = 0.275f * (cos(2.0f + h * PI / 180.0f) + 3.8f);\n    \}\n    // Hellwig2022\n    // CAM16 vs Hellwig2022: https://onlinelibrary.wiley.com/cms/asset/60788dfc-6bae-4949-bf8d-bd8c3467aef8/col22792-fig-0005-m.jpg\n    else if (cc_et == 1)\n    \{\n      float hr = radians(h);\n      float _h = hr;\n      float _2_h = 2 * hr;\n      float _3_h = 3 * hr;\n      float _4_h = 4 * hr;\n      e_t = (\n        -0.0582f * cos(_h)\n        - 0.0258f * cos(_2_h)\n        - 0.1347f * cos(_3_h)\n        + 0.0289f * cos(_4_h)\n        - 0.1475f * sin(_h)\n        - 0.0308f * sin(_2_h)\n        + 0.0385f * sin(_3_h)\n        + 0.0096f * sin(_4_h)\n        + 1.0f\n      );\n    \}\n    // Custom https://www.desmos.com/calculator/vukgp6rtos\n    else if (cc_et == 2)\n    \{\n      float hr = radians(h);\n      float hr2 = hr * 2;\n      float hr3 = hr * 3;\n      e_t = (-0.47f * cos(hr) +\n              0.07f * cos(hr2) +\n             -0.11f * cos(hr3) +\n             -0.33f * sin(hr) +\n              0.19f * sin(hr2) +\n              0.00f * sin(hr3) +\n              1.86f) * 0.58f;\n    \}\n\n    return JMcusp.y * e_t;\n  \}\n\n  // Compress a range of values from 0 to limit.  Doesn't compress anything beyond the limit.\n  // The k1 parameter affects the strength of compression, the k2 parameter affects the\n  // expansion rate of the curve.  https://www.desmos.com/calculator/vqxgfzzyvx\n  float compress_range(float x, float limit, float k1, float k2, int invert)\n  \{\n    if (x > limit)\n      return x;\n\n    k1 = sqrt(k1 * k1 + k2 * k2);\n    float k3 = (limit + k1) / (limit + k2);\n\n    if (!invert)\n      return 0.5f * (k3 * x - k1 + sqrt((k3 * x - k1) * (k3 * x - k1) + 4 * k2 * k3 * x));\n    else\n      return (x * x + k1 * x) / (k3 * (x + k2));\n  \}\n\n  // In-gamut chroma compression\n  //\n  // Compresses colors inside the gamut with the aim for colorfulness to have an\n  // appropriate rate of change from display black to display white.\n  //\n  // Steps:\n  //  - Scale down M by tonescaledJ / origJ\n  //  - Normalize M to compression gamut cusp (becomes hue-dependent)\n  //  - Compress M with compress_range().  Compression is increased as tonescaledJ\n  //    increases to create the path-to-white.\n  //  - Denormalize M with the gamut cusp\n  //  - Apply global saturation, boosting shadows more\n  //\n  float chromaCompression(float3 JMh, float origJ, int invert)\n  \{\n    float M = JMh.y;\n    if (M == 0.0f)\n      return M;\n\n    float nJ = JMh.x / limitJmax;\n    float noJ = origJ / limitJmax;\n    float Mcusp = cusp_with_eccentricity_factor(JMh.z);\n    float sat_fact = sat_factor(nJ, noJ);\n\n    if (!invert)\n    \{\n      M *= pow(nJ, nJ_exp) / noJ;\n      M /= Mcusp;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 0);\n      M *= Mcusp * sat_fact * scaleM;\n    \}\n    else\n    \{\n      M /= Mcusp * sat_fact * scaleM;\n      M = compress_range(M, chromaCParams.x, nJ * chromaCParams.y, max(1.0f - nJ, 0.01f) * chromaCParams.z, 1);\n      M *= Mcusp;\n      M = noJ * (M / pow(nJ, nJ_exp));\n    \}\n\n    return M;\n  \}\n\n  float3 input_RGB_to_JMh(float3 inputRGB)\n  \{\n    // clamp input to +/- HALF_MAXIMUM range (to remove inf values, etc.)\n    inputRGB = clamp3(inputRGB, -HALF_MAXIMUM, HALF_MAXIMUM);\n\n    // convert to linear XYZ luminance values\n    float3 luminanceRGB = encodingToLuminance3( encodingIn, inputRGB);\n    float3 luminanceXYZ = vector_dot(RGB_to_XYZ_input, luminanceRGB);\n    float3 JMh = XYZ_to_JMh(luminanceXYZ, inWhite, d65White, viewingConditions, L_A, Y_b, discountIlluminant_in, HK_mode_in);\n\n    if (diagnosticMode == 6)\n    \{\n      return luminanceXYZ;\n    \}\n   else\n    \{\n      return JMh;\n    \}\n  \}\n\n\n  float3 JMh_to_input_RGB(float3 JMh)\n  \{\n    float3 luminanceXYZ = JMh_to_XYZ( JMh, inWhite, d65White, viewingConditions , L_A, Y_b, discountIlluminant_in, HK_mode_in);\n    float3 luminanceRGB = vector_dot(XYZ_to_RGB_input, luminanceXYZ);\n    float3 inputRGB = luminanceToEncoding3( encodingIn, luminanceRGB);\n\n    return inputRGB;\n  \}\n\n\n  float3 forwardTonescale( float3 inputJMh, float3 srcRGB )\n  \{\n    float3 outputJMh;\n    float3 monoJMh = float3(inputJMh.x,0.0f,0.0f);\n    float3 linearJMh = JMh_to_luminance_RGB(monoJMh);\n    float linear = linearJMh.x/referenceLuminance;\n\n    float luminanceTS = linear;\n\n    // switch for applying the different tonescale compression functions\n    if ( toneScaleMode == 0 )\n    \{\n      luminanceTS =  linear;\n    \}\n    else if( toneScaleMode == 1 )\n    \{\n        luminanceTS = daniele_evo_fwd(linear) * mmScaleFactor;\n    \}\n\n    float3 tonemappedmonoJMh = luminance_RGB_to_JMh(float3(luminanceTS,luminanceTS,luminanceTS));\n    float3 tonemappedJMh = float3(tonemappedmonoJMh.x,inputJMh.y,inputJMh.z);\n\n    if( applyTonecurve )\n    \{\n        outputJMh = tonemappedJMh;\n    \}\n    else\n    \{\n        outputJMh = inputJMh;\n    \}\n\n    if (applyChromaCompression)\n    \{\n      outputJMh.y = chromaCompression(outputJMh, inputJMh.x, 0);\n    \}\n    else\n    \{\n      outputJMh.y = outputJMh.y;  \n    \}\n\n    return outputJMh;\n  \}\n\n\n  float3 inverseTonescale( float3 JMh )\n  \{\n    float3 tonemappedJMh = JMh;\n\n    if( ! applyTonecurve && !applyChromaCompression )\n    \{\n      // nothing else to do here\n      return tonemappedJMh;\n    \}\n\n    float3 untonemappedColourJMh = tonemappedJMh;\n    \n    float3 monoTonemappedJMh = float3(tonemappedJMh.x,0.0f,0.0f);\n    float3 monoTonemappedRGB = JMh_to_luminance_RGB(monoTonemappedJMh);\n    float3 newMonoTonemappedJMh = luminance_RGB_to_JMh(monoTonemappedRGB);\n    float luminance = monoTonemappedRGB.x;\n\n    // Dummy value to init the var\n    float linear = 0.0f;\n    if( toneScaleMode == 1 )\n    \{\n        linear = daniele_evo_rev(luminance / mmScaleFactor);\n    \}\n    else\n    \{\n        linear = luminance;\n    \}\n\n    linear = linear*referenceLuminance;\n  \n    if( applyTonecurve )\n    \{\n      float3 untonemappedMonoJMh = luminance_RGB_to_JMh(float3(linear,linear,linear));\n      untonemappedColourJMh = float3(untonemappedMonoJMh.x,tonemappedJMh.y,tonemappedJMh.z);\n    \} \n\n    if (applyChromaCompression)\n    \{\n      untonemappedColourJMh.y = chromaCompression(tonemappedJMh, untonemappedColourJMh.x, 1);\n    \}\n\n    return  untonemappedColourJMh;\n  \}\n\n  // Smooth minimum of a and b\n  float smin(float a, float b, float s)\n  \{\n    float h = max(s - fabs(a - b), 0.0) / s;\n    return min(a, b) - h * h * h * s * (1.0f / 6.0f);\n  \}\n\n  // Approximation of the gamut intersection to a curved and smoothened triangle\n  // along the projection line 'from -> to'. \n  float2 find_gamut_intersection(float2 cusp, float2 from, float2 to, float smoothing)\n  \{\n    float t0, t1;\n\n    // Scale the cusp outward when smoothing to avoid reducing the gamut.  Reduce\n    // smoothing for high cusps because smin() will bias it too much for the longer line.\n    float s = max(lerp(smoothing, smoothing * 0.01f, cusp.x / limitJmax), 0.0001f);\n    cusp.y += 10.0f * s;\n    cusp.x += 6.0f * s;\n\n    // Line below the cusp is curved with gamut_gamma\n    float toJ_gamma = cusp.x * spow(to.x / cusp.x, gamut_gamma);\n    float fromJ_gamma = cusp.x * spow(from.x / cusp.x, gamut_gamma);\n    t0 = cusp.y * toJ_gamma / (from.y * cusp.x + cusp.y * (toJ_gamma - fromJ_gamma));\n\n    // Line above the cusp\n    t1 = cusp.y * (to.x - limitJmax) / (from.y * (cusp.x - limitJmax) + cusp.y * (to.x - from.x));\n\n    // Smooth minimum to smooth the cusp\n    t1 = smin(fabs(t0), fabs(t1), s);\n\n    return float2(to.x * (1.0f - t1) + t1 * from.x, t1 * from.y);\n  \}\n\n\n  float4 getCompressionFuncParams(float h)\n  \{\n    float angleR = 27.0f;\n    float angleY = 111.0f;\n    float angleG = 143.0f;\n    float angleC = 231.0f;\n    float angleB = 283.0f;\n    float angleM = 337.0f;\n\n    float lerpVal = 0.0f;\n    // float newW = 0.0f;\n    // float newX = 0.0f;\n    // float newY = 0.0f;\n    // float newZ = 0.0f;\n\n    if (!sixAxisCompressionMode)\n      return compressionFuncParams;\n    else\n    \{\n      if (h>=angleR && h<angleY)\n      \{\n        lerpVal = (h-angleR)/(angleY-angleR);\n        return lerp4(compressionFuncParamsR, compressionFuncParamsY, lerpVal);\n      \}\n      if (h>=angleY && h<angleG)\n      \{\n        lerpVal = (h-angleY)/(angleG-angleY);\n        return lerp4(compressionFuncParamsY, compressionFuncParamsG, lerpVal);\n      \}\n      if (h>=angleG && h<angleC)\n      \{\n          lerpVal = (h-angleG)/(angleC-angleG);\n          return lerp4(compressionFuncParamsG, compressionFuncParamsC, lerpVal);\n      \}\n      if (h>=angleC && h<angleB)\n      \{\n          lerpVal = (h-angleC)/(angleB-angleC);\n          return lerp4(compressionFuncParamsC, compressionFuncParamsB, lerpVal);\n      \}\n      if (h>=angleB && h<angleM)\n      \{\n          lerpVal = (h-angleB)/(angleM-angleB);\n          return lerp4(compressionFuncParamsB, compressionFuncParamsM, lerpVal);\n      \}\n      if (h>=angleM && h<angleR+360.0f)\n      \{\n          lerpVal = (h-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      if (h<angleR)\n      \{\n          lerpVal = (h+360.0f-angleM)/(angleR+360.0f-angleM);\n          return lerp4(compressionFuncParamsM, compressionFuncParamsR, lerpVal);\n      \}\n      else\n      \{\n        return compressionFuncParams;\n      \}\n    \}\n    \n  \}\n\n\n  float3 compressGamut(float3 JMh, int invert)\n  \{\n    float2 project_from = float2(JMh.x, JMh.y);\n    float2 JMcusp = cuspFromTable(JMh.z);\n\n    if (!applyGamutCompression)\n      return JMh;\n    if (project_from.y == 0.0f)\n      return JMh;\n\n    // Calculate where the out of gamut color is projected to\n    float focusJ = lerp(JMcusp.x, midJ, cuspMidBlend);\n\n    // https://www.desmos.com/calculator/9u0wiiz9ys\n    float Mratio = project_from.y / (focusDistance * JMcusp.y);\n    float a = max(0.001f, Mratio / focusJ);\n    float b0 = 1.0f - Mratio;\n    float b1 = -(1.0f + Mratio + (a * limitJmax));\n    float b = project_from.x < focusJ ? b0 : b1;\n    float c0 = -project_from.x;\n    float c1 = project_from.x + limitJmax * Mratio;\n    float c = project_from.x < focusJ ? c0 : c1;\n\n    // XXX this sqrt can cause NaNs (subtraction goes negative)\n    float J0 = sqrt(b * b - 4 * a * c);\n    float J1 = (-b - J0) / (2 * a);\n          J0 = (-b + J0) / (2 * a);\n    float projectJ = project_from.x < focusJ ? J0 : J1;\n\n    // Find gamut intersection\n    float2 project_to = float2(projectJ, 0.0f);\n    float2 JMboundary = find_gamut_intersection(JMcusp, project_from, project_to, smoothCusps);\n\n    // Get hue dependent compression parameters\n    float4 interpolatedCompressionFuncParams = getCompressionFuncParams(JMh.z);\n\n    // Compress the out of gamut color along the projection line\n    float2 JMcompressed = project_from;\n    float v = project_from.y / JMboundary.y;\n    if (v >= interpolatedCompressionFuncParams.x)\n    \{\n      v = compressPowerP(v, interpolatedCompressionFuncParams.x,\n                         lerp(interpolatedCompressionFuncParams.z, interpolatedCompressionFuncParams.y, projectJ / limitJmax),\n                         interpolatedCompressionFuncParams.w, invert);\n      JMcompressed = project_to + v * (JMboundary - project_to);\n    \}\n\n    if (diagnosticMode == 5)\n    \{\n      return float3(focusJ, Mratio, projectJ);\n    \}\n    if (diagnosticMode == 12)\n    \{\n      return float3(JMboundary.x, JMboundary.y, JMh.z);\n    \}\n    else\n    \{\n      return float3(JMcompressed.x, JMcompressed.y, JMh.z);\n    \}\n  \}\n\n  // Generate the Hellwig2022 post adaptation non-linear compression matrix\n  // that is used in the inverse of the model (JMh-to-XYZ).\n  //\n  // Original:\n  //  460.0f, 451.0f, 288.0f,\n  //  460.0f, -891.0f, -261.0f,\n  //  460.0f, -220.0f, -6300.0f\n  void generate_panlrcm()\n  \{\n    float panlrcm_data\[]=\n    \{\n      // original values: 2.0f, 1.0f, 0.05f,\n      ra, 1.0f, ba,\n      1.0f, -12.0f / 11.0f, 1.0f / 11.0f,\n      1.0f / 9.0f, 1.0f / 9.0f, -2.0f / 9.0f\n    \};\n    panlrcm.setArray(panlrcm_data);\n    panlrcm = panlrcm.invert();\n\n    // Normalize rows so that first column is 460\n    for (int i = 0; i < 3; i++)\n    \{\n      float n = 460.0f / panlrcm\[i]\[0];\n      panlrcm\[i]\[0] *= n;\n      panlrcm\[i]\[1] *= n;\n      panlrcm\[i]\[2] *= n;\n    \}\n  \}\n\n  void init()\n  \{\n    HALF_MINIMUM = 0.0000000596046448f;\n    HALF_MAXIMUM = 65504.0f;\n\n    st2084_m_1=2610.0f / 4096.0f * (1.0f / 4.0f);\n    st2084_m_2=2523.0f / 4096.0f * 128.0f;\n    st2084_c_1=3424.0f / 4096.0f;\n    st2084_c_2=2413.0f / 4096.0f * 32.0f;\n    st2084_c_3=2392.0f / 4096.0f * 32.0f;\n    st2084_m_1_d = 1.0f / st2084_m_1;\n    st2084_m_2_d = 1.0f / st2084_m_2;\n    st2084_L_p = 10000.0f;\n\n    // pre-calculate Daniele Evo constants\n    daniele_r_hit = daniele_r_hit_min + (daniele_r_hit_max - daniele_r_hit_min) * (log(daniele_n / daniele_n_r) / log(10000.0f / 100.0f));\n    daniele_m_0 = daniele_n / daniele_n_r;\n    daniele_m_1 = 0.5f * (daniele_m_0 + sqrt(daniele_m_0 * (daniele_m_0 + 4.0f * daniele_t_1)));\n    daniele_u = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + 1.0f), daniele_g);\n    daniele_m = daniele_m_1 / daniele_u;\n    daniele_w_i = log(daniele_n / 100.0f) / log(2.0f);\n    daniele_c_t = daniele_c_d * (1.0f + daniele_w_i * daniele_w_g) / daniele_n_r;\n    daniele_g_ip = 0.5f * (daniele_c_t + sqrt(daniele_c_t * (daniele_c_t + 4.0f * daniele_t_1)));\n    daniele_g_ipp2 = -daniele_m_1 * pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) / (pow(daniele_g_ip / daniele_m, 1.0f / daniele_g) - 1.0f);\n    daniele_w_2 = daniele_c / daniele_g_ipp2;\n    daniele_s_2 = daniele_w_2 * daniele_m_1;\n    daniele_u_2 = pow((daniele_r_hit / daniele_m_1) / ((daniele_r_hit / daniele_m_1) + daniele_w_2), daniele_g);\n    daniele_m_2 = daniele_m_1 / daniele_u_2;\n\n    // Pre-calculate chroma compression constants. Tonescale based scaling factor and exponent to bring\n    // colorfulness at middle grey and under closer with different peak luminances for better appearance match.\n    // https://www.desmos.com/calculator/wdsyjmhcsh\n    scaleM = daniele_n > 100 ? 1.0f - (4.4f - daniele_m_0 * 0.0007f) * daniele_c_t + 0.25f : 1.0f;\n    nJ_exp = max(0.935f, 1.1f - 0.001f * daniele_n);\n\n    float identity_matrix_data\[]=\{ 1.0f, 0.0f, 0.0f,\n                                   0.0f, 1.0f, 0.0f,\n                                   0.0f, 0.0f, 1.0f \};\n    identity_matrix.setArray(identity_matrix_data);\n\n    // Blink does not seem to support initialising multidimensional arrays\n    // So instead of being able to index the matrix data directly from one\n    // we need to use long if/else statements to populate the\n    // input, limit & output primary matrices\n    // (maybe there is a better way?)\n\n    float XYZ_to_AP0_ACES_matrix_data\[]=\n    \{\n       1.0498110175f,  0.0000000000f, -0.0000974845f,\n      -0.4959030231f,  1.3733130458f,  0.0982400361f,\n       0.0000000000f,  0.0000000000f,  0.9912520182f\n    \};\n\n    float XYZ_to_AP1_ACES_matrix_data\[]=\n    \{\n       1.6410233797f, -0.3248032942f, -0.2364246952f,\n      -0.6636628587f,  1.6153315917f,  0.0167563477f,\n       0.0117218943f, -0.0082844420f,  0.9883948585f,\n    \};\n\n    float XYZ_to_Rec709_D65_matrix_data\[]=\n    \{\n       3.2409699419f, -1.5373831776f, -0.4986107603f,\n      -0.9692436363f,  1.8759675015f,  0.0415550574f,\n       0.0556300797f, -0.2039769589f,  1.0569715142f,\n    \};\n\n    float XYZ_to_Rec2020_D65_matrix_data\[]=\n    \{\n       1.7166511880f, -0.3556707838f, -0.2533662814f,\n      -0.6666843518f,  1.6164812366f,  0.0157685458f,\n       0.0176398574f, -0.0427706133f,  0.9421031212f,\n    \};\n\n    float XYZ_to_P3_D65_matrix_data\[]=\n    \{\n       2.4934969119f, -0.9313836179f, -0.4027107845f,\n      -0.8294889696f,  1.7626640603f,  0.0236246858f,\n       0.0358458302f, -0.0761723893f,  0.9568845240f,\n    \};\n\n    float XYZ_to_P3_DCI_matrix_data\[]=\n    \{\n       2.7253940305f, -1.0180030062f, -0.4401631952f,\n      -0.7951680258f,  1.6897320548f,  0.0226471906f,\n       0.0412418914f, -0.0876390192f,  1.1009293786f\n    \};\n\n    float CAT_CAT16_data\[]=\n    \{\n      0.401288, 0.650173, -0.051461,\n      -0.250268, 1.204414, 0.045854,\n      -0.002079, 0.048952, 0.953127,\n    \};\n\n    float Modified_CAT16_data\[]=\n    \{\n      0.656619, 0.342071, 0.00131062,\n      -0.222571, 1.10658, 0.115987,\n      -0.000634146, 0.05855, 0.942084,\n    \};\n\n    // populate the input primaries matrix\n    if( primariesIn == 0 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesIn == 1 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesIn == 2 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesIn == 3 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesIn == 4 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesIn == 5 )\n    \{\n      XYZ_to_RGB_input.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_input.setArray(identity_matrix_data);\n    \}\n\n    // populate the limiting primaries matrix\n    if( primariesLimit == 0 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 1 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesLimit == 2 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesLimit == 3 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesLimit == 4 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesLimit == 5 )\n    \{\n      XYZ_to_RGB_limit.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_limit.setArray(identity_matrix_data);\n    \}\n\n    // populate the output primaries matrix\n    if( primariesOut == 0 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP0_ACES_matrix_data);\n    \}\n    else if( primariesOut == 1 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_AP1_ACES_matrix_data);\n    \}\n    else if( primariesOut == 2 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec709_D65_matrix_data);\n    \}\n    else if( primariesOut == 3 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_Rec2020_D65_matrix_data);\n    \}\n    else if( primariesOut == 4 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_D65_matrix_data);\n    \}\n    else if( primariesOut == 5 )\n    \{\n      XYZ_to_RGB_output.setArray(XYZ_to_P3_DCI_matrix_data);\n    \}\n    else\n    \{\n      XYZ_to_RGB_output.setArray(identity_matrix_data);\n    \}\n\n    RGB_to_XYZ_input  = XYZ_to_RGB_input.invert();\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    RGB_to_XYZ_output = XYZ_to_RGB_output.invert();\n\n    float3x3 XYZ_to_RGB_sRGB;\n    XYZ_to_RGB_sRGB.setArray(XYZ_to_Rec709_D65_matrix_data);\n    float3 white(1.0f, 1.0f, 1.0f);\n\n    d65White = vector_dot(XYZ_to_RGB_sRGB.invert(), white);\n    inWhite = vector_dot(RGB_to_XYZ_input, white);\n    outWhite = vector_dot(RGB_to_XYZ_output, white);\n    refWhite = vector_dot(RGB_to_XYZ_limit, white);\n    limitWhite = vector_dot(RGB_to_XYZ_limit, white);\n\n    boundaryRGB = sstsLuminance.z / referenceLuminance;\n\n    if (catDataSelection == 0)\n    \{\n        CAT_CAT16.setArray(CAT_CAT16_data);\n    \}\n    else if (catDataSelection == 1)\n    \{\n        CAT_CAT16.setArray(Modified_CAT16_data);\n    \}\n    else if (catDataSelection == 2)\n    \{\n        CAT_CAT16 = RGBPrimsToXYZMatrix(rxy,gxy,bxy,wxy,1.0f,1);\n    \}\n\n    generate_panlrcm();\n\n    //\n    // solving the RGB cusp from JMh is very expensive\n    // instead we go the other way and start with a RGB cusp sweep\n    // which is easily calculated by converting via HSV (Hue, 1.0, 1.0)\n    // we then convert each cusp to JMh and add them to a table \n    //\n\n    gamutCuspTableSize = 360;\n\n  // Cusp table for chroma compression gamut\n  \{\n    float3x3 tmpx = XYZ_to_RGB_limit;\n    float3x3 tmpr = RGB_to_XYZ_limit;\n\n    XYZ_to_RGB_limit = RGBPrimsToXYZMatrix(crxy, cgxy, cbxy, cwxy, 1.0f, 1);\n    RGB_to_XYZ_limit  = XYZ_to_RGB_limit.invert();\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      cgamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n    XYZ_to_RGB_limit = tmpx;\n    RGB_to_XYZ_limit = tmpr;\n  \}\n \n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      float hNorm = float(i) / (gamutCuspTableSize);\n      float3 RGB = HSV_to_RGB(float3(hNorm, 1.0f, 1.0f));\n      gamutCuspTableUnsorted\[i] = limit_RGB_to_JMh(RGB);\n    \}\n\n    int minhIndex = 0;\n    for( int i = 1; i < gamutCuspTableSize; ++i )\n    \{\n      if( gamutCuspTableUnsorted\[i].z <  gamutCuspTableUnsorted\[minhIndex].z)\n      \{\n        minhIndex = i;\n      \}\n    \}\n\n    for( int i = 0; i < gamutCuspTableSize; ++i )\n    \{\n      gamutCuspTable\[i] = gamutCuspTableUnsorted\[(minhIndex+i)%gamutCuspTableSize];\n    \}\n\n    // limitJmax (asumed to match limitRGB white)\n    limitJmax = limit_RGB_to_JMh(float3(1.0f)).x;\n\n    midJ = XYZ_to_JMh(refWhite * sstsLuminance.y, refWhite, d65White, outputViewingConditions, L_A_out, Y_b_out, discountIlluminant_mid, HK_mode_mid).x;\n    gamut_gamma = 1.0f / (viewingConditionsToSurround(outputViewingConditions).y * (1.48f + sqrt(Y_b_out / L_A_out)));\n  \}\n\n\n  void process()\n  \{\n    SampleType(src) source = src();\n    float3 srcRGB(source.x, source.y, source.z);\n    float3 dstRGB;\n    float3 diagnostic;\n    float3 compressedJMh;\n    float3 tonemappedJMh;\n    float3 JMh;\n\n    if( invert )\n    \{\n      compressedJMh = output_RGB_to_JMh(srcRGB);\n      tonemappedJMh = compressGamut(compressedJMh, 1);\n      JMh = inverseTonescale(tonemappedJMh);\n      dstRGB = JMh_to_input_RGB(JMh);\n      diagnostic =  dstRGB;\n    \}\n    else\n    \{\n      JMh = input_RGB_to_JMh(srcRGB);\n      tonemappedJMh = forwardTonescale(JMh, srcRGB);\n      compressedJMh = compressGamut(tonemappedJMh, 0);\n\n      dstRGB = JMh_to_output_RGB(compressedJMh);\n      diagnostic =  dstRGB;\n    \}\n\n    if ( diagnosticMode == 1 || diagnosticMode == 6 )\n    \{\n      // Mode 6 actually returns XYZ, mode 1 returns real JMh\n      diagnostic =  JMh;\n    \}\n    else if ( diagnosticMode == 2)\n    \{\n      diagnostic = tonemappedJMh;\n    \}\n    else if ( diagnosticMode == 3 || diagnosticMode == 5 )\n    \{\n      diagnostic =  compressedJMh;\n    \}\n    else if ( diagnosticMode == 4 || diagnosticMode == 7 )\n    \{\n      if (diagnosticMode == 4)\n        srcRGB = JMh;\n      dstRGB = JMh_to_output_RGB(srcRGB);\n      diagnostic =  dstRGB;\n    \}\n    else if ( diagnosticMode == 8)\n    \{\n      diagnostic =  inWhite;\n    \}\n    else if ( diagnosticMode == 9)\n    \{\n      diagnostic =  outWhite;\n    \}\n    else if ( diagnosticMode == 10)\n    \{\n      diagnostic =  limitWhite;\n    \}\n    else if ( diagnosticMode == 11)\n    \{\n      diagnostic =  d65White;\n    \}\n    else if (diagnosticMode == 12)\n    \{\n      // output gamut boundry\n      diagnostic = compressGamut(srcRGB, 0);\n    \}\n\n    dst() = float4(diagnostic.x, diagnostic.y, diagnostic.z, source.w ); \n  \}\n\};\n"
  useGPUIfAvailable {{parent.use_gpu}}
  rebuild ""
  DRT_CAM_Kernel_encodingIn {{parent.encoding_in}}
  DRT_CAM_Kernel_primariesIn {{parent.primaries_in}}
  DRT_CAM_Kernel_toneScaleMode {{parent.toneScaleMode}}
  DRT_CAM_Kernel_discountIlluminant_in true
  DRT_CAM_Kernel_discountIlluminant_mid true
  DRT_CAM_Kernel_discountIlluminant_out true
  DRT_CAM_Kernel_compressMode {{parent.compress_mode}}
  DRT_CAM_Kernel_referenceLuminance {{parent.reference_luminance x446 0.185}}
  DRT_CAM_Kernel_backgroundLuminance {{parent.background_luminance}}
  DRT_CAM_Kernel_viewingConditions {{inputViewingConditions}}
  DRT_CAM_Kernel_outputViewingConditions {{parent.viewing_conditions}}
  DRT_CAM_Kernel_applyTonecurve {{applyTonecurve}}
  DRT_CAM_Kernel_sstsLuminance {{parent.ssts_luminance.x} {parent.ssts_luminance.y} {parent.ssts_luminance.z}}
  DRT_CAM_Kernel_applyChromaCompression {{parent.applyChromaCompression}}
  DRT_CAM_Kernel_chromaCParams {{"max(0.9, parent.chromaCompress.x - 0.0003 * parent.ssts_luminance.z)"} {parent.chromaCompress.y} {parent.chromaCompress.z x2 0.755}}
  DRT_CAM_Kernel_cc_et {{parent.et}}
  DRT_CAM_Kernel_crxy {0.69 0.325}
  DRT_CAM_Kernel_cgxy {0.29 0.65}
  DRT_CAM_Kernel_cbxy {0.115 0.05}
  DRT_CAM_Kernel_cwxy {0.32168 0.33767}
  DRT_CAM_Kernel_sat {{"0.96 * parent.saturation" x114 0.175 x203 0.49 x278 0.21}}
  DRT_CAM_Kernel_primariesLimit {{parent.primaries_limit}}
  DRT_CAM_Kernel_applyGamutCompression {{parent.apply_gamut_compression}}
  DRT_CAM_Kernel_cuspMidBlend {{parent.cusp_mid_blend}}
  DRT_CAM_Kernel_focusDistance {{parent.focus_distance}}
  DRT_CAM_Kernel_compressionFuncParams {{parent.compression_params.r} {parent.compression_params.g} {"max(1.23, parent.compression_params.b - 0.0007 * parent.ssts_luminance.z)"} {parent.compression_params.a}}
  DRT_CAM_Kernel_sixAxisCompressionMode {{parent.sixAxisCompressionMode}}
  DRT_CAM_Kernel_compressionFuncParamsR {{parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR} {parent.compressionFuncParamsR}}
  DRT_CAM_Kernel_compressionFuncParamsY {{parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY} {parent.compressionFuncParamsY}}
  DRT_CAM_Kernel_compressionFuncParamsG {{parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG} {parent.compressionFuncParamsG}}
  DRT_CAM_Kernel_compressionFuncParamsC {{parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC} {parent.compressionFuncParamsC}}
  DRT_CAM_Kernel_compressionFuncParamsB {{parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB} {parent.compressionFuncParamsB}}
  DRT_CAM_Kernel_compressionFuncParamsM {{parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM} {parent.compressionFuncParamsM}}
  DRT_CAM_Kernel_smoothCusps {{parent.smooth_cusps}}
  DRT_CAM_Kernel_encodingOut {{parent.encoding_out}}
  DRT_CAM_Kernel_primariesOut {{parent.primaries_out}}
  DRT_CAM_Kernel_clampOutput {{parent.clamp_output}}
  DRT_CAM_Kernel_softclampOutput {{parent.soft_clamp}}
  DRT_CAM_Kernel_clamp_thr 0.99
  DRT_CAM_Kernel_clamp_dist 1.1
  DRT_CAM_Kernel_invert {{parent.invert}}
  DRT_CAM_Kernel_diagnosticMode 1
  DRT_CAM_Kernel_mmScaleFactor 100
  DRT_CAM_Kernel_daniele_n {{parent.ssts_luminance.z}}
  DRT_CAM_Kernel_daniele_n_r 100
  DRT_CAM_Kernel_daniele_g 1.15
  DRT_CAM_Kernel_daniele_c 0.18
  DRT_CAM_Kernel_daniele_c_d 10.013
  DRT_CAM_Kernel_daniele_w_g 0.14
  DRT_CAM_Kernel_daniele_t_1 0.04
  DRT_CAM_Kernel_daniele_r_hit_min 128
  DRT_CAM_Kernel_daniele_r_hit_max 896
  DRT_CAM_Kernel_catDataSelection {{parent.HellwigCam16Data}}
  DRT_CAM_Kernel_rxy {0.82 0.175}
  DRT_CAM_Kernel_gxy {-1.3 1.8}
  DRT_CAM_Kernel_bxy {0.13 -0.1}
  DRT_CAM_Kernel_wxy {0.333 0.333}
  DRT_CAM_Kernel_ra {{"parent.ac_resp * 2"}}
  DRT_CAM_Kernel_ba {{"0.05 + (2 - DRT_CAM_Kernel_ra)"}}
  DRT_CAM_Kernel_XYZ_w {95.05 100 108.88}
  DRT_CAM_Kernel_XYZ_w_scaler 100
  DRT_CAM_Kernel_L_A {{parent.BlinkScript1_DRT_CAM_Kernel_L_A}}
  DRT_CAM_Kernel_Y_b {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b}}
  DRT_CAM_Kernel_L_B {0 {DRT_CAM_Kernel_L_B.x} {DRT_CAM_Kernel_L_B.x}}
  DRT_CAM_Kernel_L_A_out {{parent.BlinkScript1_DRT_CAM_Kernel_L_A_out}}
  DRT_CAM_Kernel_Y_b_out {{parent.BlinkScript1_DRT_CAM_Kernel_Y_b_out}}
  rebuild_finalise ""
  name BlinkScript1
  note_font "Bitstream Vera Sans"
  xpos -908
  ypos -203
  addUserKnob {20 User}
  addUserKnob {7 matrixScaler R 0 2}
  matrixScaler 0.99415
 }
 Output {
  name Output1
  xpos -908
  ypos -84
 }
end_group
Shuffle {
 name Shuffle40
 label "\[value in]-->\[value out]"
 note_font "Bitstream Vera Sans"
 xpos 4201
 ypos 140
}
Multiply {
 value {0.01 0.01 {PI/360*2} 1}
 name Multiply17
 note_font "Bitstream Vera Sans"
 xpos 4201
 ypos 176
}
Expression {
 expr0 sin(b)*g
 expr1 r
 expr2 cos(b)*g
 expr3 1
 name Expression21
 note_font "Bitstream Vera Sans"
 xpos 4201
 ypos 212
}
push $Naeb05600
PositionToPoints2 {
 inputs 2
 display textured
 render_mode textured
 detail 1
 pointSize 1
 name PositionToPoints19
 xpos 4298
 ypos 291
}
push 0
push $Nb9ffba00
Scene {
 inputs 5
 name Scene6
 xpos 3866
 ypos 656
}
Reformat {
 inputs 0
 name Reformat15
 xpos 1021
 ypos -626
}
push $N64419200
push $N2d595000
push $N6d6f9a00
Viewer {
 inputs 3
 frame 61
 frame_range 1-200
 frame_range_lock true
 colour_sample_bbox {0.3913894296 -0.2211350352 0.3933463693 -0.2191780806}
 samplepoints {{1.310546875 -0.0654296875}
   }
 translate {0.2370000035 -0.1140000001}
 monitorOutOutputTransform rec709
 name Viewer1
 xpos -313
 ypos 281
}
